<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <style>html, body {
  margin: 0;
  padding: 0;
}

.app {
  margin: 10px;
  padding: 0;
}

.files-list {
  margin: 10px 0 0;
  width: 100%;
  border-collapse: collapse;
}
.files-list__head {
  border: 1px solid #999;
}
.files-list__head > tr > th {
  padding: 10px;
  border: 1px solid #999;
  text-align: left;
  font-weight: normal;
  background: #ddd;
}
.files-list__body {
}
.files-list__file {
  cursor: pointer;
}
.files-list__file:hover {
  background: #ccf;
}
.files-list__file > td {
  padding: 10px;
  border: 1px solid #999;
}
.files-list__file > td:first-child::before {
  content: '\01F4C4';
  margin-right: 1em;
}
.files-list__file_low {
  background: #fcc;
}
.files-list__file_medium {
  background: #ffc;
}
.files-list__file_high {
  background: #cfc;
}
.files-list__file_folder > td:first-child::before {
  content: '\01F4C1';
  margin-right: 1em;
}

.file-header {
  border: 1px solid #999;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.file-header__back {
  margin: 10px;
  cursor: pointer;
  flex-shrink: 0;
  flex-grow: 0;
  text-decoration: underline;
  color: #338;
}

.file-header__name {
  margin: 10px;
  flex-shrink: 2;
  flex-grow: 2;
}

.file-header__stat {
  margin: 10px;
  flex-shrink: 0;
  flex-grow: 0;
}

.file-content {
  margin: 10px 0 0;
  border: 1px solid #999;
  padding: 10px;
}

.code-line {
  margin: 0;
  padding: 0.3em;
  height: 1em;
}
.code-line_covered {
  background: #cfc;
}
.code-line_uncovered {
  background: #fcc;
}
</style>
</head>
<body>
    <div id="root"></div>
    <script>
        var data = {"files":[{"path":["/","Users","haitran","AURA-NETWORK","smart-contracts-halotrade-zone","contracts","halo-factory","src","contract.rs"],"content":"#[cfg(not(feature = \"library\"))]\nuse cosmwasm_std::entry_point;\nuse cosmwasm_std::{\n    to_binary, Addr, Binary, CosmosMsg, Deps, DepsMut, Env, MessageInfo, Reply, ReplyOn, Response,\n    StdError, StdResult, SubMsg, WasmMsg,\n};\nuse cw2::set_contract_version;\nuse haloswap::querier::{query_balance, query_pair_info_from_pair};\n\nuse crate::state::{\n    add_allow_native_token, pair_key, read_pairs, Config, TmpPairInfo, ALLOW_NATIVE_TOKENS, CONFIG,\n    PAIRS, TMP_PAIR_INFO,\n};\n\nuse cw_utils::parse_reply_instantiate_data;\nuse haloswap::asset::{AssetInfo, PairInfo, PairInfoRaw, CreatePairRequirements};\nuse haloswap::factory::{\n    ConfigResponse, ExecuteMsg, InstantiateMsg, MigrateMsg, NativeTokenDecimalsResponse,\n    PairsResponse, QueryMsg,\n};\nuse haloswap::pair::{InstantiateMsg as PairInstantiateMsg, MigrateMsg as PairMigrateMsg};\n\n// version info for migration info\nconst CONTRACT_NAME: \u0026str = \"crates.io:halo-factory\";\nconst CONTRACT_VERSION: \u0026str = env!(\"CARGO_PKG_VERSION\");\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn instantiate(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    msg: InstantiateMsg,\n) -\u003e StdResult\u003cResponse\u003e {\n    set_contract_version(deps.storage, CONTRACT_NAME, CONTRACT_VERSION)?;\n\n    let config = Config {\n        owner: deps.api.addr_canonicalize(info.sender.as_str())?,\n        token_code_id: msg.token_code_id,\n        pair_code_id: msg.pair_code_id,\n    };\n\n    CONFIG.save(deps.storage, \u0026config)?;\n\n    Ok(Response::new())\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn execute(deps: DepsMut, env: Env, info: MessageInfo, msg: ExecuteMsg) -\u003e StdResult\u003cResponse\u003e {\n    match msg {\n        ExecuteMsg::UpdateConfig {\n            owner,\n            token_code_id,\n            pair_code_id,\n        } =\u003e execute_update_config(deps, env, info, owner, token_code_id, pair_code_id),\n        ExecuteMsg::CreatePair { asset_infos, requirements } =\u003e execute_create_pair(deps, env, info, asset_infos, requirements),\n        ExecuteMsg::AddNativeTokenDecimals { denom, decimals } =\u003e {\n            execute_add_native_token_decimals(deps, env, info, denom, decimals)\n        }\n        ExecuteMsg::MigratePair { contract, code_id } =\u003e {\n            execute_migrate_pair(deps, env, info, contract, code_id)\n        }\n    }\n}\n\n// Only owner can execute it\npub fn execute_update_config(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    owner: Option\u003cString\u003e,\n    token_code_id: Option\u003cu64\u003e,\n    pair_code_id: Option\u003cu64\u003e,\n) -\u003e StdResult\u003cResponse\u003e {\n    let mut config: Config = CONFIG.load(deps.storage)?;\n\n    // permission check\n    if deps.api.addr_canonicalize(info.sender.as_str())? != config.owner {\n        return Err(StdError::generic_err(\"unauthorized\"));\n    }\n\n    if let Some(owner) = owner {\n        // validate address format\n        let _ = deps.api.addr_validate(\u0026owner)?;\n\n        config.owner = deps.api.addr_canonicalize(\u0026owner)?;\n    }\n\n    if let Some(token_code_id) = token_code_id {\n        config.token_code_id = token_code_id;\n    }\n\n    if let Some(pair_code_id) = pair_code_id {\n        config.pair_code_id = pair_code_id;\n    }\n\n    CONFIG.save(deps.storage, \u0026config)?;\n\n    Ok(Response::new().add_attribute(\"action\", \"update_config\"))\n}\n\n// Anyone can execute it to create swap pair\npub fn execute_create_pair(\n    deps: DepsMut,\n    env: Env,\n    _info: MessageInfo,\n    asset_infos: [AssetInfo; 2],\n    requirements: CreatePairRequirements,\n) -\u003e StdResult\u003cResponse\u003e {\n    let config: Config = CONFIG.load(deps.storage)?;\n\n    // don't allow to create pair with same token\n    if asset_infos[0] == asset_infos[1] {\n        return Err(StdError::generic_err(\"same asset\"));\n    }\n\n    let asset_1_decimal =\n        match asset_infos[0].query_decimals(env.contract.address.clone(), \u0026deps.querier) {\n            Ok(decimal) =\u003e decimal,\n            Err(_) =\u003e return Err(StdError::generic_err(\"asset1 is invalid\")),\n        };\n\n    let asset_2_decimal =\n        match asset_infos[1].query_decimals(env.contract.address.clone(), \u0026deps.querier) {\n            Ok(decimal) =\u003e decimal,\n            Err(_) =\u003e return Err(StdError::generic_err(\"asset2 is invalid\")),\n        };\n\n    let raw_infos = [\n        asset_infos[0].to_raw(deps.api)?,\n        asset_infos[1].to_raw(deps.api)?,\n    ];\n\n    let asset_decimals = [asset_1_decimal, asset_2_decimal];\n\n    let pair_key = pair_key(\u0026raw_infos);\n    if let Ok(Some(_)) = PAIRS.may_load(deps.storage, \u0026pair_key) {\n        return Err(StdError::generic_err(\"Pair already exists\"));\n    }\n\n    TMP_PAIR_INFO.save(\n        deps.storage,\n        \u0026TmpPairInfo {\n            pair_key,\n            asset_infos: raw_infos,\n            asset_decimals,\n        },\n    )?;\n\n    Ok(Response::new()\n        .add_attributes(vec![\n            (\"action\", \"create_pair\"),\n            (\"pair\", \u0026format!(\"{}-{}\", asset_infos[0], asset_infos[1])),\n        ])\n        .add_submessage(SubMsg {\n            id: 1,\n            gas_limit: None,\n            msg: CosmosMsg::Wasm(WasmMsg::Instantiate {\n                code_id: config.pair_code_id,\n                funds: vec![],\n                admin: Some(env.contract.address.to_string()),\n                label: \"pair\".to_string(),\n                msg: to_binary(\u0026PairInstantiateMsg {\n                    asset_infos,\n                    token_code_id: config.token_code_id,\n                    asset_decimals,\n                    requirements,\n                })?,\n            }),\n            reply_on: ReplyOn::Success,\n        }))\n}\n\npub fn execute_add_native_token_decimals(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    denom: String,\n    decimals: u8,\n) -\u003e StdResult\u003cResponse\u003e {\n    let config: Config = CONFIG.load(deps.storage)?;\n\n    // permission check\n    if deps.api.addr_canonicalize(info.sender.as_str())? != config.owner {\n        return Err(StdError::generic_err(\"unauthorized\"));\n    }\n\n    let balance = query_balance(\u0026deps.querier, env.contract.address, denom.to_string())?;\n    if balance.is_zero() {\n        return Err(StdError::generic_err(\n            \"a balance greater than zero is required by the factory for verification\",\n        ));\n    }\n\n    add_allow_native_token(deps.storage, denom.to_string(), decimals)?;\n\n    Ok(Response::new().add_attributes(vec![\n        (\"action\", \"add_allow_native_token\"),\n        (\"denom\", \u0026denom),\n        (\"decimals\", \u0026decimals.to_string()),\n    ]))\n}\n\npub fn execute_migrate_pair(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    contract: String,\n    code_id: Option\u003cu64\u003e,\n) -\u003e StdResult\u003cResponse\u003e {\n    let config: Config = CONFIG.load(deps.storage)?;\n\n    // permission check\n    if deps.api.addr_canonicalize(info.sender.as_str())? != config.owner {\n        return Err(StdError::generic_err(\"unauthorized\"));\n    }\n\n    let code_id = code_id.unwrap_or(config.pair_code_id);\n\n    Ok(\n        Response::new().add_message(CosmosMsg::Wasm(WasmMsg::Migrate {\n            contract_addr: contract,\n            new_code_id: code_id,\n            msg: to_binary(\u0026PairMigrateMsg {})?,\n        })),\n    )\n}\n\n/// This just stores the result for future query\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn reply(deps: DepsMut, _env: Env, msg: Reply) -\u003e StdResult\u003cResponse\u003e {\n    let tmp_pair_info = TMP_PAIR_INFO.load(deps.storage)?;\n\n    let reply = parse_reply_instantiate_data(msg).unwrap();\n\n    // let res: MsgInstantiateContractResponse =\n    //     Message::parse_from_bytes(msg.result.unwrap().data.unwrap().as_slice()).map_err(|_| {\n    //         StdError::parse_err(\"MsgInstantiateContractResponse\", \"failed to parse data\")\n    //     })?;\n\n    let pair_contract = \u0026reply.contract_address;\n    let pair_info = query_pair_info_from_pair(\u0026deps.querier, Addr::unchecked(pair_contract))?;\n\n    PAIRS.save(\n        deps.storage,\n        \u0026tmp_pair_info.pair_key,\n        \u0026PairInfoRaw {\n            liquidity_token: deps.api.addr_canonicalize(\u0026pair_info.liquidity_token)?,\n            contract_addr: deps.api.addr_canonicalize(\u0026pair_contract)?,\n            asset_infos: tmp_pair_info.asset_infos,\n            asset_decimals: tmp_pair_info.asset_decimals,\n            requirements: pair_info.requirements,\n        },\n    )?;\n\n    Ok(Response::new().add_attributes(vec![\n        (\"pair_contract_addr\", pair_contract),\n        (\"liquidity_token_addr\", \u0026pair_info.liquidity_token.to_string()),\n    ]))\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn query(deps: Deps, _env: Env, msg: QueryMsg) -\u003e StdResult\u003cBinary\u003e {\n    match msg {\n        QueryMsg::Config {} =\u003e to_binary(\u0026query_config(deps)?),\n        QueryMsg::Pair { asset_infos } =\u003e to_binary(\u0026query_pair(deps, asset_infos)?),\n        QueryMsg::Pairs { start_after, limit } =\u003e {\n            to_binary(\u0026query_pairs(deps, start_after, limit)?)\n        }\n        QueryMsg::NativeTokenDecimals { denom } =\u003e {\n            to_binary(\u0026query_native_token_decimal(deps, denom)?)\n        }\n    }\n}\n\npub fn query_config(deps: Deps) -\u003e StdResult\u003cConfigResponse\u003e {\n    let state: Config = CONFIG.load(deps.storage)?;\n    let resp = ConfigResponse {\n        owner: deps.api.addr_humanize(\u0026state.owner)?.to_string(),\n        token_code_id: state.token_code_id,\n        pair_code_id: state.pair_code_id,\n    };\n\n    Ok(resp)\n}\n\npub fn query_pair(deps: Deps, asset_infos: [AssetInfo; 2]) -\u003e StdResult\u003cPairInfo\u003e {\n    let pair_key = pair_key(\u0026[\n        asset_infos[0].to_raw(deps.api)?,\n        asset_infos[1].to_raw(deps.api)?,\n    ]);\n    let pair_info: PairInfoRaw = PAIRS.load(deps.storage, \u0026pair_key)?;\n    pair_info.to_normal(deps.api)\n}\n\npub fn query_pairs(\n    deps: Deps,\n    start_after: Option\u003c[AssetInfo; 2]\u003e,\n    limit: Option\u003cu32\u003e,\n) -\u003e StdResult\u003cPairsResponse\u003e {\n    let start_after = if let Some(start_after) = start_after {\n        Some([\n            start_after[0].to_raw(deps.api)?,\n            start_after[1].to_raw(deps.api)?,\n        ])\n    } else {\n        None\n    };\n\n    let pairs: Vec\u003cPairInfo\u003e = read_pairs(deps.storage, deps.api, start_after, limit)?;\n    let resp = PairsResponse { pairs };\n\n    Ok(resp)\n}\n\npub fn query_native_token_decimal(\n    deps: Deps,\n    denom: String,\n) -\u003e StdResult\u003cNativeTokenDecimalsResponse\u003e {\n    let decimals = ALLOW_NATIVE_TOKENS.load(deps.storage, denom.as_bytes())?;\n\n    Ok(NativeTokenDecimalsResponse { decimals })\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn migrate(deps: DepsMut, _env: Env, _msg: MigrateMsg) -\u003e StdResult\u003cResponse\u003e {\n    set_contract_version(deps.storage, CONTRACT_NAME, CONTRACT_VERSION)?;\n\n    Ok(Response::default())\n}\n","traces":[{"line":34,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":250,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":264,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":265,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":266,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":269,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":275,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":278,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":279,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":280,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":283,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":286,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":287,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":288,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":289,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":291,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":292,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":295,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":300,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":302,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":303,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":306,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":309,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":310,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":312,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":315,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":319,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":321,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":326,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":328,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":133,"coverable":147},{"path":["/","Users","haitran","AURA-NETWORK","smart-contracts-halotrade-zone","contracts","halo-factory","src","lib.rs"],"content":"pub mod contract;\npub mod state;\n\n#[cfg(test)]\nmod testing;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","haitran","AURA-NETWORK","smart-contracts-halotrade-zone","contracts","halo-factory","src","state.rs"],"content":"use schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\n\nuse cosmwasm_std::{Api, CanonicalAddr, Order, StdResult, Storage};\nuse cw_storage_plus::{Bound, Item, Map};\nuse haloswap::asset::{AssetInfoRaw, PairInfo, PairInfoRaw};\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\npub struct Config {\n    pub owner: CanonicalAddr,\n    pub pair_code_id: u64,\n    pub token_code_id: u64,\n}\n\npub const CONFIG: Item\u003cConfig\u003e = Item::new(\"config\");\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\npub struct TmpPairInfo {\n    pub pair_key: Vec\u003cu8\u003e,\n    pub asset_infos: [AssetInfoRaw; 2],\n    pub asset_decimals: [u8; 2],\n}\n\npub const TMP_PAIR_INFO: Item\u003cTmpPairInfo\u003e = Item::new(\"tmp_pair_info\");\npub const PAIRS: Map\u003c\u0026[u8], PairInfoRaw\u003e = Map::new(\"pair_info\");\n\npub fn pair_key(asset_infos: \u0026[AssetInfoRaw; 2]) -\u003e Vec\u003cu8\u003e {\n    let mut asset_infos = asset_infos.to_vec();\n    asset_infos.sort_by(|a, b| a.as_bytes().cmp(b.as_bytes()));\n\n    [asset_infos[0].as_bytes(), asset_infos[1].as_bytes()].concat()\n}\n\n// settings for pagination\nconst MAX_LIMIT: u32 = 30;\nconst DEFAULT_LIMIT: u32 = 10;\npub fn read_pairs(\n    storage: \u0026dyn Storage,\n    api: \u0026dyn Api,\n    start_after: Option\u003c[AssetInfoRaw; 2]\u003e,\n    limit: Option\u003cu32\u003e,\n) -\u003e StdResult\u003cVec\u003cPairInfo\u003e\u003e {\n    let limit = limit.unwrap_or(DEFAULT_LIMIT).min(MAX_LIMIT) as usize;\n    let start = calc_range_start(start_after).map(Bound::ExclusiveRaw);\n\n    PAIRS\n        .range(storage, start, None, Order::Ascending)\n        .take(limit)\n        .map(|item| {\n            let (_, v) = item?;\n            v.to_normal(api)\n        })\n        .collect::\u003cStdResult\u003cVec\u003cPairInfo\u003e\u003e\u003e()\n}\n\n// this will set the first key after the provided key, by appending a 1 byte\nfn calc_range_start(start_after: Option\u003c[AssetInfoRaw; 2]\u003e) -\u003e Option\u003cVec\u003cu8\u003e\u003e {\n    start_after.map(|asset_infos| {\n        let mut asset_infos = asset_infos.to_vec();\n        asset_infos.sort_by(|a, b| a.as_bytes().cmp(b.as_bytes()));\n\n        let mut v = [asset_infos[0].as_bytes(), asset_infos[1].as_bytes()]\n            .concat()\n            .as_slice()\n            .to_vec();\n        v.push(1);\n        v\n    })\n}\n\n// key : asset info / value: decimals\npub const ALLOW_NATIVE_TOKENS: Map\u003c\u0026[u8], u8\u003e = Map::new(\"allow_native_token\");\npub fn add_allow_native_token(\n    storage: \u0026mut dyn Storage,\n    denom: String,\n    decimals: u8,\n) -\u003e StdResult\u003c()\u003e {\n    ALLOW_NATIVE_TOKENS.save(storage, denom.as_bytes(), \u0026decimals)\n}\n\n#[cfg(test)]\nmod allow_native_token {\n\n    use haloswap::mock_querier::mock_dependencies;\n\n    use super::*;\n\n    #[test]\n    fn normal() {\n        let mut deps = mock_dependencies(\u0026[]);\n        let denom = \"uluna\".to_string();\n        let decimals = 6u8;\n\n        add_allow_native_token(deps.as_mut().storage, denom.to_string(), decimals).unwrap();\n\n        assert_eq!(\n            decimals,\n            ALLOW_NATIVE_TOKENS\n                .load(deps.as_ref().storage, denom.as_bytes())\n                .unwrap()\n        )\n    }\n\n    #[test]\n    fn duplicate_register_will_append() {\n        let mut deps = mock_dependencies(\u0026[]);\n        let denom = \"uluna\".to_string();\n\n        add_allow_native_token(deps.as_mut().storage, denom.to_string(), 6u8).unwrap();\n\n        assert_eq!(\n            ALLOW_NATIVE_TOKENS\n                .load(deps.as_ref().storage, denom.as_bytes())\n                .unwrap(),\n            6u8\n        );\n\n        add_allow_native_token(deps.as_mut().storage, denom.to_string(), 7u8).unwrap();\n        assert_eq!(\n            ALLOW_NATIVE_TOKENS\n                .load(deps.as_ref().storage, denom.as_bytes())\n                .unwrap(),\n            7u8\n        );\n    }\n}\n","traces":[{"line":27,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":6},"fn_name":null}],"covered":6,"coverable":25},{"path":["/","Users","haitran","AURA-NETWORK","smart-contracts-halotrade-zone","contracts","halo-factory","src","testing.rs"],"content":"use crate::contract::{execute, instantiate, query, reply};\nuse haloswap::mock_querier::{mock_dependencies, WasmMockQuerier};\n\nuse crate::state::{pair_key, TmpPairInfo, TMP_PAIR_INFO};\n\nuse cosmwasm_std::testing::{\n    mock_dependencies_with_balance, mock_env, mock_info, MockApi, MockStorage, MOCK_CONTRACT_ADDR,\n};\nuse cosmwasm_std::{\n    attr, coin, from_binary, to_binary, CosmosMsg, OwnedDeps, Reply, ReplyOn, Response, StdError,\n    SubMsg, SubMsgResponse, SubMsgResult, Uint128, WasmMsg, Addr,\n};\nuse haloswap::asset::{AssetInfo, PairInfo, CreatePairRequirements};\nuse haloswap::factory::{\n    ConfigResponse, ExecuteMsg, InstantiateMsg, NativeTokenDecimalsResponse, QueryMsg,\n};\nuse haloswap::pair::{InstantiateMsg as PairInstantiateMsg, MigrateMsg as PairMigrateMsg};\n\n#[test]\nfn proper_initialization() {\n    let mut deps = mock_dependencies(\u0026[]);\n\n    let msg = InstantiateMsg {\n        pair_code_id: 321u64,\n        token_code_id: 123u64,\n    };\n\n    let info = mock_info(\"addr0000\", \u0026[]);\n\n    // we can just call .unwrap() to assert this was a success\n    let _res = instantiate(deps.as_mut(), mock_env(), info, msg).unwrap();\n\n    let query_res = query(deps.as_ref(), mock_env(), QueryMsg::Config {}).unwrap();\n    let config_res: ConfigResponse = from_binary(\u0026query_res).unwrap();\n    assert_eq!(123u64, config_res.token_code_id);\n    assert_eq!(321u64, config_res.pair_code_id);\n    assert_eq!(\"addr0000\".to_string(), config_res.owner);\n}\n\n#[test]\nfn update_config() {\n    let mut deps = mock_dependencies(\u0026[]);\n\n    let msg = InstantiateMsg {\n        pair_code_id: 321u64,\n        token_code_id: 123u64,\n    };\n\n    let info = mock_info(\"addr0000\", \u0026[]);\n\n    // we can just call .unwrap() to assert this was a success\n    let _res = instantiate(deps.as_mut(), mock_env(), info, msg).unwrap();\n\n    // update owner\n    let info = mock_info(\"addr0000\", \u0026[]);\n    let msg = ExecuteMsg::UpdateConfig {\n        owner: Some(\"addr0001\".to_string()),\n        pair_code_id: None,\n        token_code_id: None,\n    };\n\n    let res = execute(deps.as_mut(), mock_env(), info, msg).unwrap();\n    assert_eq!(0, res.messages.len());\n\n    // it worked, let's query the state\n    let query_res = query(deps.as_ref(), mock_env(), QueryMsg::Config {}).unwrap();\n    let config_res: ConfigResponse = from_binary(\u0026query_res).unwrap();\n    assert_eq!(123u64, config_res.token_code_id);\n    assert_eq!(321u64, config_res.pair_code_id);\n    assert_eq!(\"addr0001\".to_string(), config_res.owner);\n\n    // update left items\n    let env = mock_env();\n    let info = mock_info(\"addr0001\", \u0026[]);\n    let msg = ExecuteMsg::UpdateConfig {\n        owner: None,\n        pair_code_id: Some(100u64),\n        token_code_id: Some(200u64),\n    };\n\n    let res = execute(deps.as_mut(), env, info, msg).unwrap();\n    assert_eq!(0, res.messages.len());\n\n    // it worked, let's query the state\n    let query_res = query(deps.as_ref(), mock_env(), QueryMsg::Config {}).unwrap();\n    let config_res: ConfigResponse = from_binary(\u0026query_res).unwrap();\n    assert_eq!(200u64, config_res.token_code_id);\n    assert_eq!(100u64, config_res.pair_code_id);\n    assert_eq!(\"addr0001\".to_string(), config_res.owner);\n\n    // Unauthorized err\n    let env = mock_env();\n    let info = mock_info(\"addr0000\", \u0026[]);\n    let msg = ExecuteMsg::UpdateConfig {\n        owner: None,\n        pair_code_id: None,\n        token_code_id: None,\n    };\n\n    let res = execute(deps.as_mut(), env, info, msg);\n    match res {\n        Err(StdError::GenericErr { msg, .. }) =\u003e assert_eq!(msg, \"unauthorized\"),\n        _ =\u003e panic!(\"Must return unauthorized error\"),\n    }\n}\n\nfn init(\n    mut deps: OwnedDeps\u003cMockStorage, MockApi, WasmMockQuerier\u003e,\n) -\u003e OwnedDeps\u003cMockStorage, MockApi, WasmMockQuerier\u003e {\n    let msg = InstantiateMsg {\n        pair_code_id: 321u64,\n        token_code_id: 123u64,\n    };\n\n    let env = mock_env();\n    let info = mock_info(\"addr0000\", \u0026[]);\n\n    deps.querier.with_token_balances(\u0026[(\n        \u0026\"asset0001\".to_string(),\n        \u0026[(\u0026\"addr0000\".to_string(), \u0026Uint128::zero())],\n    )]);\n    // we can just call .unwrap() to assert this was a success\n    let _res = instantiate(deps.as_mut(), env, info, msg).unwrap();\n\n    deps\n}\n\n#[test]\nfn create_pair() {\n    let mut deps = mock_dependencies(\u0026[coin(10u128, \"uusd\".to_string())]);\n    deps = init(deps);\n    deps.querier\n        .with_halo_factory(\u0026[], \u0026[(\"uusd\".to_string(), 6u8)]);\n    let asset_infos = [\n        AssetInfo::NativeToken {\n            denom: \"uusd\".to_string(),\n        },\n        AssetInfo::Token {\n            contract_addr: \"asset0001\".to_string(),\n        },\n    ];\n\n    let msg = ExecuteMsg::CreatePair {\n        asset_infos: asset_infos.clone(),\n        requirements: CreatePairRequirements {\n            whitelist: vec![Addr::unchecked(\"deployer\")],\n            first_asset_minimum: Uint128::zero(),\n            second_asset_minimum: Uint128::zero(),\n        },\n    };\n\n    let env = mock_env();\n    let info = mock_info(\"addr0000\", \u0026[]);\n    let res = execute(deps.as_mut(), env, info, msg).unwrap();\n    assert_eq!(\n        res.attributes,\n        vec![\n            attr(\"action\", \"create_pair\"),\n            attr(\"pair\", \"uusd-asset0001\")\n        ]\n    );\n    assert_eq!(\n        res.messages,\n        vec![SubMsg {\n            id: 1,\n            gas_limit: None,\n            reply_on: ReplyOn::Success,\n            msg: WasmMsg::Instantiate {\n                msg: to_binary(\u0026PairInstantiateMsg {\n                    asset_infos: asset_infos.clone(),\n                    token_code_id: 123u64,\n                    asset_decimals: [6u8, 8u8],\n                    requirements: CreatePairRequirements {\n                        whitelist: vec![Addr::unchecked(\"deployer\")],\n                        first_asset_minimum: Uint128::zero(),\n                        second_asset_minimum: Uint128::zero(),\n                    },\n                })\n                .unwrap(),\n                code_id: 321u64,\n                funds: vec![],\n                label: \"pair\".to_string(),\n                admin: Some(MOCK_CONTRACT_ADDR.to_string()),\n            }\n            .into()\n        },]\n    );\n\n    let raw_infos = [\n        asset_infos[0].to_raw(deps.as_ref().api).unwrap(),\n        asset_infos[1].to_raw(deps.as_ref().api).unwrap(),\n    ];\n\n    assert_eq!(\n        TMP_PAIR_INFO.load(\u0026deps.storage).unwrap(),\n        TmpPairInfo {\n            asset_infos: raw_infos.clone(),\n            pair_key: pair_key(\u0026raw_infos),\n            asset_decimals: [6u8, 8u8]\n        }\n    );\n}\n\n#[test]\nfn create_pair_native_token_and_ibc_token() {\n    let mut deps = mock_dependencies(\u0026[\n        coin(10u128, \"uusd\".to_string()),\n        coin(10u128, \"ibc/HASH\".to_string()),\n    ]);\n    deps = init(deps);\n    deps.querier.with_halo_factory(\n        \u0026[],\n        \u0026[(\"uusd\".to_string(), 6u8), (\"ibc/HASH\".to_string(), 6u8)],\n    );\n\n    let asset_infos = [\n        AssetInfo::NativeToken {\n            denom: \"uusd\".to_string(),\n        },\n        AssetInfo::NativeToken {\n            denom: \"ibc/HASH\".to_string(),\n        },\n    ];\n\n    let msg = ExecuteMsg::CreatePair {\n        asset_infos: asset_infos.clone(),\n        requirements: CreatePairRequirements {\n            whitelist: vec![Addr::unchecked(\"deployer\")],\n            first_asset_minimum: Uint128::zero(),\n            second_asset_minimum: Uint128::zero(),\n        },\n    };\n\n    let env = mock_env();\n    let info = mock_info(\"addr0000\", \u0026[]);\n    let res = execute(deps.as_mut(), env, info, msg).unwrap();\n    assert_eq!(\n        res.attributes,\n        vec![attr(\"action\", \"create_pair\"), attr(\"pair\", \"uusd-ibc/HASH\")]\n    );\n    assert_eq!(\n        res.messages,\n        vec![SubMsg {\n            id: 1,\n            gas_limit: None,\n            reply_on: ReplyOn::Success,\n            msg: WasmMsg::Instantiate {\n                msg: to_binary(\u0026PairInstantiateMsg {\n                    asset_infos: asset_infos.clone(),\n                    token_code_id: 123u64,\n                    asset_decimals: [6u8, 6u8],\n                    requirements: CreatePairRequirements {\n                        whitelist: vec![Addr::unchecked(\"deployer\")],\n                        first_asset_minimum: Uint128::zero(),\n                        second_asset_minimum: Uint128::zero(),\n                    },\n                })\n                .unwrap(),\n                code_id: 321u64,\n                funds: vec![],\n                label: \"pair\".to_string(),\n                admin: Some(MOCK_CONTRACT_ADDR.to_string()),\n            }\n            .into()\n        },]\n    );\n\n    let raw_infos = [\n        asset_infos[0].to_raw(deps.as_ref().api).unwrap(),\n        asset_infos[1].to_raw(deps.as_ref().api).unwrap(),\n    ];\n\n    assert_eq!(\n        TMP_PAIR_INFO.load(\u0026deps.storage).unwrap(),\n        TmpPairInfo {\n            asset_infos: raw_infos.clone(),\n            pair_key: pair_key(\u0026raw_infos),\n            asset_decimals: [6u8, 6u8]\n        }\n    );\n}\n\n#[test]\nfn fail_to_create_same_pair() {\n    let mut deps = mock_dependencies(\u0026[coin(10u128, \"uusd\".to_string())]);\n    deps = init(deps);\n\n    let asset_infos = [\n        AssetInfo::NativeToken {\n            denom: \"uusd\".to_string(),\n        },\n        AssetInfo::NativeToken {\n            denom: \"uusd\".to_string(),\n        },\n    ];\n\n    let requirements = CreatePairRequirements {\n        whitelist: vec![Addr::unchecked(\"deployer\")],\n        first_asset_minimum: Uint128::zero(),\n        second_asset_minimum: Uint128::zero(),\n    };\n\n    let msg = ExecuteMsg::CreatePair { asset_infos, requirements };\n\n    let env = mock_env();\n    let info = mock_info(\"addr0000\", \u0026[]);\n    execute(deps.as_mut(), env, info, msg).unwrap_err();\n}\n\n#[test]\nfn fail_to_create_pair_with_unactive_denoms() {\n    let mut deps = mock_dependencies(\u0026[coin(10u128, \"uusd\".to_string())]);\n    deps = init(deps);\n\n    let asset_infos = [\n        AssetInfo::NativeToken {\n            denom: \"uusd\".to_string(),\n        },\n        AssetInfo::NativeToken {\n            denom: \"uxxx\".to_string(),\n        },\n    ];\n\n    let requirements = CreatePairRequirements {\n        whitelist: vec![Addr::unchecked(\"deployer\")],\n        first_asset_minimum: Uint128::zero(),\n        second_asset_minimum: Uint128::zero(),\n    };\n\n    let msg = ExecuteMsg::CreatePair { asset_infos, requirements };\n\n    let env = mock_env();\n    let info = mock_info(\"addr0000\", \u0026[]);\n    execute(deps.as_mut(), env, info, msg).unwrap_err();\n}\n\n#[test]\nfn fail_to_create_pair_with_invalid_denom() {\n    let mut deps = mock_dependencies(\u0026[coin(10u128, \"uluna\".to_string())]);\n    deps = init(deps);\n\n    let asset_infos = [\n        AssetInfo::NativeToken {\n            denom: \"uluna\".to_string(),\n        },\n        AssetInfo::NativeToken {\n            denom: \"xxx\".to_string(),\n        },\n    ];\n\n    let requirements = CreatePairRequirements {\n        whitelist: vec![Addr::unchecked(\"deployer\")],\n        first_asset_minimum: Uint128::zero(),\n        second_asset_minimum: Uint128::zero(),\n    };\n\n    let msg = ExecuteMsg::CreatePair { asset_infos, requirements };\n\n    let env = mock_env();\n    let info = mock_info(\"addr0000\", \u0026[]);\n    execute(deps.as_mut(), env, info, msg).unwrap_err();\n}\n\n#[test]\nfn fail_to_create_pair_with_unknown_token() {\n    let mut deps = mock_dependencies(\u0026[coin(10u128, \"uusd\".to_string())]);\n\n    let msg = InstantiateMsg {\n        pair_code_id: 321u64,\n        token_code_id: 123u64,\n    };\n\n    let env = mock_env();\n    let info = mock_info(\"addr0000\", \u0026[]);\n\n    // we can just call .unwrap() to assert this was a success\n    let _res = instantiate(deps.as_mut(), env, info, msg).unwrap();\n\n    let asset_infos = [\n        AssetInfo::NativeToken {\n            denom: \"uluna\".to_string(),\n        },\n        AssetInfo::Token {\n            contract_addr: \"xxx\".to_string(),\n        },\n    ];\n\n    let requirements = CreatePairRequirements {\n        whitelist: vec![Addr::unchecked(\"deployer\")],\n        first_asset_minimum: Uint128::zero(),\n        second_asset_minimum: Uint128::zero(),\n    };\n\n    let msg = ExecuteMsg::CreatePair { asset_infos, requirements };\n\n    let env = mock_env();\n    let info = mock_info(\"addr0000\", \u0026[]);\n    execute(deps.as_mut(), env, info, msg).unwrap_err();\n}\n\n#[test]\nfn fail_to_create_pair_with_unknown_ibc_token() {\n    let mut deps = mock_dependencies_with_balance(\u0026[coin(10u128, \"uusd\".to_string())]);\n\n    let msg = InstantiateMsg {\n        pair_code_id: 321u64,\n        token_code_id: 123u64,\n    };\n\n    let env = mock_env();\n    let info = mock_info(\"addr0000\", \u0026[]);\n\n    // we can just call .unwrap() to assert this was a success\n    let _res = instantiate(deps.as_mut(), env, info, msg).unwrap();\n\n    let asset_infos = [\n        AssetInfo::NativeToken {\n            denom: \"uluna\".to_string(),\n        },\n        AssetInfo::NativeToken {\n            denom: \"ibc/HA\".to_string(),\n        },\n    ];\n\n    let requirements = CreatePairRequirements {\n        whitelist: vec![Addr::unchecked(\"deployer\")],\n        first_asset_minimum: Uint128::zero(),\n        second_asset_minimum: Uint128::zero(),\n    };\n\n    let msg = ExecuteMsg::CreatePair { asset_infos, requirements };\n\n    let env = mock_env();\n    let info = mock_info(\"addr0000\", \u0026[]);\n    execute(deps.as_mut(), env, info, msg).unwrap_err();\n}\n\n#[test]\nfn reply_test() {\n    let mut deps = mock_dependencies(\u0026[]);\n\n    deps.querier.with_token_balances(\u0026[(\n        \u0026MOCK_CONTRACT_ADDR.to_string(),\n        \u0026[\n            (\u0026\"asset0000\".to_string(), \u0026Uint128::from(100u128)),\n            (\u0026\"asset0001\".to_string(), \u0026Uint128::from(100u128)),\n        ],\n    )]);\n\n    let asset_infos = [\n        AssetInfo::Token {\n            contract_addr: \"asset0000\".to_string(),\n        },\n        AssetInfo::Token {\n            contract_addr: \"asset0001\".to_string(),\n        },\n    ];\n\n    let raw_infos = [\n        asset_infos[0].to_raw(deps.as_ref().api).unwrap(),\n        asset_infos[1].to_raw(deps.as_ref().api).unwrap(),\n    ];\n\n    let pair_key = pair_key(\u0026raw_infos);\n    TMP_PAIR_INFO\n        .save(\n            \u0026mut deps.storage,\n            \u0026TmpPairInfo {\n                asset_infos: raw_infos,\n                pair_key,\n                asset_decimals: [8u8, 8u8],\n            },\n        )\n        .unwrap();\n\n    let reply_msg = Reply {\n        id: 1,\n        result: SubMsgResult::Ok(SubMsgResponse {\n            events: vec![],\n            data: Some(vec![10, 4, 48, 48, 48, 48].into()),\n        }),\n    };\n\n    // register halo pair querier\n    deps.querier.with_halo_factory(\n        \u0026[(\n            \u0026\"0000\".to_string(),\n            \u0026PairInfo {\n                asset_infos: [\n                    AssetInfo::Token {\n                        contract_addr: \"asset0000\".to_string(),\n                    },\n                    AssetInfo::Token {\n                        contract_addr: \"asset0001\".to_string(),\n                    },\n                ],\n                contract_addr: \"0000\".to_string(),\n                liquidity_token: \"liquidity0000\".to_string(),\n                asset_decimals: [8u8, 8u8],\n                requirements: CreatePairRequirements {\n                    whitelist: vec![Addr::unchecked(\"deployer\")],\n                    first_asset_minimum: Uint128::zero(),\n                    second_asset_minimum: Uint128::zero(),\n                },\n            },\n        )],\n        \u0026[],\n    );\n\n    let _res = reply(deps.as_mut(), mock_env(), reply_msg).unwrap();\n\n    let query_res = query(\n        deps.as_ref(),\n        mock_env(),\n        QueryMsg::Pair {\n            asset_infos: asset_infos.clone(),\n        },\n    )\n    .unwrap();\n\n    let pair_res: PairInfo = from_binary(\u0026query_res).unwrap();\n    assert_eq!(\n        pair_res,\n        PairInfo {\n            liquidity_token: \"liquidity0000\".to_string(),\n            contract_addr: \"0000\".to_string(),\n            asset_infos,\n            asset_decimals: [8u8, 8u8],\n            requirements: CreatePairRequirements {\n                whitelist: vec![Addr::unchecked(\"deployer\")],\n                first_asset_minimum: Uint128::zero(),\n                second_asset_minimum: Uint128::zero(),\n            },\n        }\n    );\n}\n\n#[test]\nfn normal_add_allow_native_token() {\n    let mut deps = mock_dependencies(\u0026[coin(1u128, \"uluna\".to_string())]);\n    deps = init(deps);\n\n    let msg = ExecuteMsg::AddNativeTokenDecimals {\n        denom: \"uluna\".to_string(),\n        decimals: 6u8,\n    };\n\n    let info = mock_info(\"addr0000\", \u0026[]);\n\n    assert_eq!(\n        execute(deps.as_mut(), mock_env(), info, msg).unwrap(),\n        Response::new().add_attributes(vec![\n            (\"action\", \"add_allow_native_token\"),\n            (\"denom\", \"uluna\"),\n            (\"decimals\", \"6\"),\n        ])\n    );\n\n    let res = query(\n        deps.as_ref(),\n        mock_env(),\n        QueryMsg::NativeTokenDecimals {\n            denom: \"uluna\".to_string(),\n        },\n    )\n    .unwrap();\n    let res: NativeTokenDecimalsResponse = from_binary(\u0026res).unwrap();\n    assert_eq!(6u8, res.decimals)\n}\n\n#[test]\nfn failed_add_allow_native_token_with_non_admin() {\n    let mut deps = mock_dependencies(\u0026[coin(1u128, \"uluna\".to_string())]);\n    deps = init(deps);\n\n    let msg = ExecuteMsg::AddNativeTokenDecimals {\n        denom: \"uluna\".to_string(),\n        decimals: 6u8,\n    };\n\n    let info = mock_info(\"noadmin\", \u0026[]);\n\n    assert_eq!(\n        execute(deps.as_mut(), mock_env(), info, msg),\n        Err(StdError::generic_err(\"unauthorized\"))\n    );\n}\n\n#[test]\nfn failed_add_allow_native_token_with_zero_factory_balance() {\n    let mut deps = mock_dependencies(\u0026[coin(0u128, \"uluna\".to_string())]);\n    deps = init(deps);\n\n    let msg = ExecuteMsg::AddNativeTokenDecimals {\n        denom: \"uluna\".to_string(),\n        decimals: 6u8,\n    };\n\n    let info = mock_info(\"addr0000\", \u0026[]);\n\n    assert_eq!(\n        execute(deps.as_mut(), mock_env(), info, msg),\n        Err(StdError::generic_err(\n            \"a balance greater than zero is required by the factory for verification\",\n        ))\n    );\n}\n\n#[test]\nfn append_add_allow_native_token_with_already_exist_token() {\n    let mut deps = mock_dependencies(\u0026[coin(1u128, \"uluna\".to_string())]);\n    deps = init(deps);\n\n    let msg = ExecuteMsg::AddNativeTokenDecimals {\n        denom: \"uluna\".to_string(),\n\n        decimals: 6u8,\n    };\n\n    let info = mock_info(\"addr0000\", \u0026[]);\n\n    execute(deps.as_mut(), mock_env(), info.clone(), msg).unwrap();\n\n    let res = query(\n        deps.as_ref(),\n        mock_env(),\n        QueryMsg::NativeTokenDecimals {\n            denom: \"uluna\".to_string(),\n        },\n    )\n    .unwrap();\n    let res: NativeTokenDecimalsResponse = from_binary(\u0026res).unwrap();\n    assert_eq!(6u8, res.decimals);\n\n    let msg = ExecuteMsg::AddNativeTokenDecimals {\n        denom: \"uluna\".to_string(),\n        decimals: 7u8,\n    };\n\n    execute(deps.as_mut(), mock_env(), info, msg).unwrap();\n\n    let res = query(\n        deps.as_ref(),\n        mock_env(),\n        QueryMsg::NativeTokenDecimals {\n            denom: \"uluna\".to_string(),\n        },\n    )\n    .unwrap();\n    let res: NativeTokenDecimalsResponse = from_binary(\u0026res).unwrap();\n    assert_eq!(7u8, res.decimals)\n}\n\n#[test]\nfn normal_migrate_pair() {\n    let mut deps = mock_dependencies(\u0026[coin(1u128, \"uluna\".to_string())]);\n    deps = init(deps);\n\n    let msg = ExecuteMsg::MigratePair {\n        code_id: Some(123u64),\n        contract: \"contract0000\".to_string(),\n    };\n\n    let info = mock_info(\"addr0000\", \u0026[]);\n\n    assert_eq!(\n        execute(deps.as_mut(), mock_env(), info, msg).unwrap(),\n        Response::new().add_message(CosmosMsg::Wasm(WasmMsg::Migrate {\n            contract_addr: \"contract0000\".to_string(),\n            new_code_id: 123u64,\n            msg: to_binary(\u0026PairMigrateMsg {}).unwrap(),\n        })),\n    );\n}\n\n#[test]\nfn normal_migrate_pair_with_none_code_id_will_config_code_id() {\n    let mut deps = mock_dependencies(\u0026[coin(1u128, \"uluna\".to_string())]);\n    deps = init(deps);\n\n    let msg = ExecuteMsg::MigratePair {\n        code_id: None,\n        contract: \"contract0000\".to_string(),\n    };\n\n    let info = mock_info(\"addr0000\", \u0026[]);\n\n    assert_eq!(\n        execute(deps.as_mut(), mock_env(), info, msg).unwrap(),\n        Response::new().add_message(CosmosMsg::Wasm(WasmMsg::Migrate {\n            contract_addr: \"contract0000\".to_string(),\n            new_code_id: 321u64,\n            msg: to_binary(\u0026PairMigrateMsg {}).unwrap(),\n        })),\n    );\n}\n\n#[test]\nfn failed_migrate_pair_with_no_admin() {\n    let mut deps = mock_dependencies(\u0026[coin(1u128, \"uluna\".to_string())]);\n    deps = init(deps);\n\n    let msg = ExecuteMsg::MigratePair {\n        code_id: None,\n        contract: \"contract0000\".to_string(),\n    };\n\n    let info = mock_info(\"noadmin\", \u0026[]);\n\n    assert_eq!(\n        execute(deps.as_mut(), mock_env(), info, msg),\n        Err(StdError::generic_err(\"unauthorized\")),\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","haitran","AURA-NETWORK","smart-contracts-halotrade-zone","contracts","halo-pair","src","contract.rs"],"content":"use crate::error::ContractError;\nuse crate::state::PAIR_INFO;\n\n#[cfg(not(feature = \"library\"))]\nuse cosmwasm_std::entry_point;\n\nuse cosmwasm_std::{\n    from_binary, to_binary, Addr, Binary, CanonicalAddr, Coin, CosmosMsg, Decimal, Deps, DepsMut,\n    Env, MessageInfo, Reply, ReplyOn, Response, StdError, StdResult, SubMsg, Uint128, WasmMsg,\n};\n\nuse bignumber::{Decimal256, Uint256};\nuse cw2::set_contract_version;\nuse cw20::{Cw20ExecuteMsg, Cw20ReceiveMsg, MinterResponse};\nuse cw_utils::parse_reply_instantiate_data;\nuse integer_sqrt::IntegerSquareRoot;\nuse std::cmp::Ordering;\nuse std::str::FromStr;\nuse haloswap::asset::{Asset, AssetInfo, PairInfo, PairInfoRaw};\nuse haloswap::pair::{\n    Cw20HookMsg, ExecuteMsg, InstantiateMsg, MigrateMsg, PoolResponse, QueryMsg,\n    ReverseSimulationResponse, SimulationResponse,\n};\nuse haloswap::querier::query_token_info;\nuse haloswap::token::InstantiateMsg as TokenInstantiateMsg;\n\n// version info for migration info\nconst CONTRACT_NAME: \u0026str = \"crates.io:halo-pair\";\nconst CONTRACT_VERSION: \u0026str = env!(\"CARGO_PKG_VERSION\");\n\nconst INSTANTIATE_REPLY_ID: u64 = 1;\n\n/// Commission rate == 0.3%\nconst COMMISSION_RATE: \u0026str = \"0.003\";\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn instantiate(\n    deps: DepsMut,\n    env: Env,\n    _info: MessageInfo,\n    msg: InstantiateMsg,\n) -\u003e StdResult\u003cResponse\u003e {\n    set_contract_version(deps.storage, CONTRACT_NAME, CONTRACT_VERSION)?;\n\n    let pair_info: \u0026PairInfoRaw = \u0026PairInfoRaw {\n        contract_addr: deps.api.addr_canonicalize(env.contract.address.as_str())?,\n        liquidity_token: CanonicalAddr::from(vec![]),\n        asset_infos: [\n            msg.asset_infos[0].to_raw(deps.api)?,\n            msg.asset_infos[1].to_raw(deps.api)?,\n        ],\n        asset_decimals: msg.asset_decimals,\n        requirements: msg.requirements,\n    };\n\n    PAIR_INFO.save(deps.storage, pair_info)?;\n\n    Ok(Response::new().add_submessage(SubMsg {\n        // Create LP token\n        msg: WasmMsg::Instantiate {\n            admin: None,\n            code_id: msg.token_code_id,\n            msg: to_binary(\u0026TokenInstantiateMsg {\n                name: \"halo liquidity token\".to_string(),\n                symbol: \"uLP\".to_string(),\n                decimals: 6,\n                initial_balances: vec![],\n                mint: Some(MinterResponse {\n                    minter: env.contract.address.to_string(),\n                    cap: None,\n                }),\n            })?,\n            funds: vec![],\n            label: \"lp\".to_string(),\n        }\n        .into(),\n        gas_limit: None,\n        id: INSTANTIATE_REPLY_ID,\n        reply_on: ReplyOn::Success,\n    }))\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn execute(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    msg: ExecuteMsg,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    match msg {\n        ExecuteMsg::Receive(msg) =\u003e receive_cw20(deps, env, info, msg),\n        ExecuteMsg::ProvideLiquidity {\n            assets,\n            slippage_tolerance,\n            receiver,\n        } =\u003e provide_liquidity(deps, env, info, assets, slippage_tolerance, receiver),\n        ExecuteMsg::Swap {\n            offer_asset,\n            belief_price,\n            max_spread,\n            to,\n        } =\u003e {\n            if !offer_asset.is_native_token() {\n                return Err(ContractError::Unauthorized {});\n            }\n\n            let to_addr = if let Some(to_addr) = to {\n                Some(deps.api.addr_validate(\u0026to_addr)?)\n            } else {\n                None\n            };\n\n            swap(\n                deps,\n                env,\n                info.clone(),\n                info.sender,\n                offer_asset,\n                belief_price,\n                max_spread,\n                to_addr,\n            )\n        }\n    }\n}\n\npub fn receive_cw20(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    cw20_msg: Cw20ReceiveMsg,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let contract_addr = info.sender.clone();\n\n    match from_binary(\u0026cw20_msg.msg) {\n        Ok(Cw20HookMsg::Swap {\n            belief_price,\n            max_spread,\n            to,\n        }) =\u003e {\n            // only asset contract can execute this message\n            let mut authorized: bool = false;\n            let config: PairInfoRaw = PAIR_INFO.load(deps.storage)?;\n            let pools: [Asset; 2] =\n                config.query_pools(\u0026deps.querier, deps.api, env.contract.address.clone())?;\n            for pool in pools.iter() {\n                if let AssetInfo::Token { contract_addr, .. } = \u0026pool.info {\n                    if contract_addr == \u0026info.sender {\n                        authorized = true;\n                    }\n                }\n            }\n\n            if !authorized {\n                return Err(ContractError::Unauthorized {});\n            }\n\n            let to_addr = if let Some(to_addr) = to {\n                Some(deps.api.addr_validate(to_addr.as_str())?)\n            } else {\n                None\n            };\n\n            swap(\n                deps,\n                env,\n                info,\n                Addr::unchecked(cw20_msg.sender),\n                Asset {\n                    info: AssetInfo::Token {\n                        contract_addr: contract_addr.to_string(),\n                    },\n                    amount: cw20_msg.amount,\n                },\n                belief_price,\n                max_spread,\n                to_addr,\n            )\n        }\n        Ok(Cw20HookMsg::WithdrawLiquidity {}) =\u003e {\n            let config: PairInfoRaw = PAIR_INFO.load(deps.storage)?;\n            if deps.api.addr_canonicalize(info.sender.as_str())? != config.liquidity_token {\n                return Err(ContractError::Unauthorized {});\n            }\n\n            let sender_addr = deps.api.addr_validate(cw20_msg.sender.as_str())?;\n            withdraw_liquidity(deps, env, info, sender_addr, cw20_msg.amount)\n        }\n        Err(err) =\u003e Err(ContractError::Std(err)),\n    }\n}\n\n/// This just stores the result for future query\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn reply(deps: DepsMut, _env: Env, msg: Reply) -\u003e StdResult\u003cResponse\u003e {\n    let res = parse_reply_instantiate_data(msg).unwrap();\n    let liquidity_token = res.contract_address;\n\n    let api = deps.api;\n    PAIR_INFO.update(deps.storage, |mut meta| -\u003e StdResult\u003c_\u003e {\n        meta.liquidity_token = api.addr_canonicalize(\u0026liquidity_token)?;\n        Ok(meta)\n    })?;\n\n    Ok(Response::new().add_attribute(\"liquidity_token_addr\", liquidity_token))\n}\n\n/// CONTRACT - should approve contract to use the amount of token\npub fn provide_liquidity(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    assets: [Asset; 2],\n    slippage_tolerance: Option\u003cDecimal\u003e,\n    receiver: Option\u003cString\u003e,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    for asset in assets.iter() {\n        // check the balance of native token is sent with the message\n        asset.assert_sent_native_token_balance(\u0026info)?;\n    }\n\n    // get information of the pair\n    let pair_info: PairInfoRaw = PAIR_INFO.load(deps.storage)?;\n\n    // query the information of the pair of assets\n    let mut pools: [Asset; 2] = pair_info.query_pools(\u0026deps.querier, deps.api, env.contract.address.clone())?;\n\n    // get the amount of assets that user deposited after checking the assets is same as the assets in pair\n    let deposits: [Uint128; 2] = [\n        assets\n            .iter()\n            .find(|a| a.info.equal(\u0026pools[0].info))\n            .map(|a| a.amount)\n            .expect(\"Wrong asset info is given\"),\n        assets\n            .iter()\n            .find(|a| a.info.equal(\u0026pools[1].info))\n            .map(|a| a.amount)\n            .expect(\"Wrong asset info is given\"),\n    ];\n\n    // If the asset is a token, the value of pools[i] is correct. But we must take the token from the user.\n    // If the asset is a native token, the amount of native token is already sent with the message to the pool.\n    // So we must subtract that ammount of native token from the pools[i].\n    // pools[] will be used to calculate the amount of LP token to mint after.\n    let mut messages: Vec\u003cCosmosMsg\u003e = vec![];\n    for (i, pool) in pools.iter_mut().enumerate() {\n        // If the asset 'pool' is a token, then we need to execute TransferFrom msg to receive funds\n        // User must approve the pool contract to transfer the token before calling this function\n        if let AssetInfo::Token { contract_addr, .. } = \u0026pool.info {\n            messages.push(CosmosMsg::Wasm(WasmMsg::Execute {\n                contract_addr: contract_addr.to_string(),\n                msg: to_binary(\u0026Cw20ExecuteMsg::TransferFrom {\n                    owner: info.sender.to_string(),\n                    recipient: env.contract.address.to_string(),\n                    amount: deposits[i],\n                })?,\n                funds: vec![],\n            }));\n        } else {\n            // If the asset 'pool' is native token, balance is already increased\n            // To calculated properly we should subtract user deposit from the pool\n            pool.amount = pool.amount.checked_sub(deposits[i])?;\n        }\n    }\n\n    // if the user provides the slippage tolerance, we should check it\n    assert_slippage_tolerance(\u0026slippage_tolerance, \u0026deposits, \u0026pools)?;\n\n    // get the address of the LP token\n    let liquidity_token = deps.api.addr_humanize(\u0026pair_info.liquidity_token)?;\n\n    // get total supply of the LP token\n    let total_share = query_token_info(\u0026deps.querier, liquidity_token)?.total_supply;\n\n    // calculate the amount of LP token is minted to the user\n    let share = if total_share == Uint128::zero() {\n        // when pool is empty\n        // if the sender is not in whitelist of requirements, then return error\n        if !pair_info.requirements.whitelist.contains(\u0026info.sender) {\n            return Err(ContractError::Std(StdError::generic_err(\"the sender is not in whitelist\")));\n        }\n\n        // if the minimum amount of deposit is not satisfied, then return error\n        if  deposits[0] \u003c pair_info.requirements.first_asset_minimum || \n            deposits[1] \u003c pair_info.requirements.second_asset_minimum {\n            return Err(ContractError::Std(StdError::generic_err(\"the minimum deposit is not satisfied\")));\n        }\n\n        // if the total supply of the LP token is zero, Initial share = collateral amount\n        // hoanm: EQUATION - LP = \\sqrt{A * B}\n        Uint128::from((deposits[0].u128() * deposits[1].u128()).integer_sqrt())\n    } else {\n        // hoanm: update these equations by using the formula of Uniswap V2\n        // min(1, 2)\n        // 1. sqrt(deposit_0 * exchange_rate_0_to_1 * deposit_0) * (total_share / sqrt(pool_0 * pool_1))\n        // == deposit_0 * total_share / pool_0\n        // 2. sqrt(deposit_1 * exchange_rate_1_to_0 * deposit_1) * (total_share / sqrt(pool_1 * pool_1))\n        // == deposit_1 * total_share / pool_1\n        std::cmp::min(\n            deposits[0].multiply_ratio(total_share, pools[0].amount),\n            deposits[1].multiply_ratio(total_share, pools[1].amount),\n        )\n    };\n\n    // prevent providing free token (hoanm: is this necessary?)\n    if share.is_zero() {\n        return Err(ContractError::InvalidZeroAmount {});\n    }\n\n    // mint LP token to sender\n    // if the user provides the receiver, mint LP token to the receiver else mint to the sender\n    let receiver = receiver.unwrap_or_else(|| info.sender.to_string());\n\n    // mint amount of 'share' LP token to the receiver\n    messages.push(CosmosMsg::Wasm(WasmMsg::Execute {\n        contract_addr: deps\n            .api\n            .addr_humanize(\u0026pair_info.liquidity_token)?\n            .to_string(),\n        msg: to_binary(\u0026Cw20ExecuteMsg::Mint {\n            recipient: receiver.to_string(),\n            amount: share,\n        })?,\n        funds: vec![],\n    }));\n\n    Ok(Response::new().add_messages(messages).add_attributes(vec![\n        (\"action\", \"provide_liquidity\"),\n        (\"sender\", info.sender.as_str()),\n        (\"receiver\", receiver.as_str()),\n        (\"assets\", \u0026format!(\"{}, {}\", assets[0], assets[1])),\n        (\"share\", \u0026share.to_string()),\n    ]))\n}\n\npub fn withdraw_liquidity(\n    deps: DepsMut,\n    env: Env,\n    _info: MessageInfo,\n    sender: Addr,\n    amount: Uint128,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let pair_info: PairInfoRaw = PAIR_INFO.load(deps.storage)?;\n    let liquidity_addr: Addr = deps.api.addr_humanize(\u0026pair_info.liquidity_token)?;\n\n    let pools: [Asset; 2] = pair_info.query_pools(\u0026deps.querier, deps.api, env.contract.address)?;\n    let total_share: Uint128 = query_token_info(\u0026deps.querier, liquidity_addr)?.total_supply;\n\n    let share_ratio: Decimal = Decimal::from_ratio(amount, total_share);\n    let refund_assets: Vec\u003cAsset\u003e = pools\n        .iter()\n        .map(|a| Asset {\n            info: a.info.clone(),\n            amount: a.amount * share_ratio,\n        })\n        .collect();\n\n    // update pool info\n    Ok(Response::new()\n        .add_messages(vec![\n            refund_assets[0].clone().into_msg(sender.clone())?,\n            refund_assets[1].clone().into_msg(sender.clone())?,\n            // burn liquidity token\n            CosmosMsg::Wasm(WasmMsg::Execute {\n                contract_addr: deps\n                    .api\n                    .addr_humanize(\u0026pair_info.liquidity_token)?\n                    .to_string(),\n                msg: to_binary(\u0026Cw20ExecuteMsg::Burn { amount })?,\n                funds: vec![],\n            }),\n        ])\n        .add_attributes(vec![\n            (\"action\", \"withdraw_liquidity\"),\n            (\"sender\", sender.as_str()),\n            (\"withdrawn_share\", \u0026amount.to_string()),\n            (\n                \"refund_assets\",\n                \u0026format!(\"{}, {}\", refund_assets[0], refund_assets[1]),\n            ),\n        ]))\n}\n\n// CONTRACT - a user must do token approval\n#[allow(clippy::too_many_arguments)]\npub fn swap(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    sender: Addr,\n    offer_asset: Asset,\n    belief_price: Option\u003cDecimal\u003e,\n    max_spread: Option\u003cDecimal\u003e,\n    to: Option\u003cAddr\u003e,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    offer_asset.assert_sent_native_token_balance(\u0026info)?;\n\n    let pair_info: PairInfoRaw = PAIR_INFO.load(deps.storage)?;\n\n    let pools: [Asset; 2] = pair_info.query_pools(\u0026deps.querier, deps.api, env.contract.address)?;\n\n    let offer_pool: Asset;\n    let ask_pool: Asset;\n\n    let offer_decimal: u8;\n    let ask_decimal: u8;\n    // If the asset balance is already increased\n    // To calculated properly we should subtract user deposit from the pool\n    if offer_asset.info.equal(\u0026pools[0].info) {\n        offer_pool = Asset {\n            amount: pools[0].amount.checked_sub(offer_asset.amount)?,\n            info: pools[0].info.clone(),\n        };\n        ask_pool = pools[1].clone();\n\n        offer_decimal = pair_info.asset_decimals[0];\n        ask_decimal = pair_info.asset_decimals[1];\n    } else if offer_asset.info.equal(\u0026pools[1].info) {\n        offer_pool = Asset {\n            amount: pools[1].amount.checked_sub(offer_asset.amount)?,\n            info: pools[1].info.clone(),\n        };\n        ask_pool = pools[0].clone();\n\n        offer_decimal = pair_info.asset_decimals[1];\n        ask_decimal = pair_info.asset_decimals[0];\n    } else {\n        return Err(ContractError::AssetMismatch {});\n    }\n\n    let offer_amount = offer_asset.amount;\n    let (return_amount, spread_amount, commission_amount) =\n        compute_swap(offer_pool.amount, ask_pool.amount, offer_amount);\n\n    let return_asset = Asset {\n        info: ask_pool.info.clone(),\n        amount: return_amount,\n    };\n\n    // check max spread limit if exist\n    assert_max_spread(\n        belief_price,\n        max_spread,\n        offer_asset.clone(),\n        return_asset.clone(),\n        spread_amount,\n        offer_decimal,\n        ask_decimal,\n    )?;\n\n    let receiver = to.unwrap_or_else(|| sender.clone());\n\n    let mut messages: Vec\u003cCosmosMsg\u003e = vec![];\n    if !return_amount.is_zero() {\n        messages.push(return_asset.into_msg(receiver.clone())?);\n    }\n\n    // 1. send collateral token from the contract to a user\n    // 2. send inactive commission to collector\n    Ok(Response::new().add_messages(messages).add_attributes(vec![\n        (\"action\", \"swap\"),\n        (\"sender\", sender.as_str()),\n        (\"receiver\", receiver.as_str()),\n        (\"offer_asset\", \u0026offer_asset.info.to_string()),\n        (\"ask_asset\", \u0026ask_pool.info.to_string()),\n        (\"offer_amount\", \u0026offer_amount.to_string()),\n        (\"return_amount\", \u0026return_amount.to_string()),\n        (\"spread_amount\", \u0026spread_amount.to_string()),\n        (\"commission_amount\", \u0026commission_amount.to_string()),\n    ]))\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn query(deps: Deps, _env: Env, msg: QueryMsg) -\u003e Result\u003cBinary, ContractError\u003e {\n    match msg {\n        QueryMsg::Pair {} =\u003e Ok(to_binary(\u0026query_pair_info(deps)?)?),\n        QueryMsg::Pool {} =\u003e Ok(to_binary(\u0026query_pool(deps)?)?),\n        QueryMsg::Simulation { offer_asset } =\u003e {\n            Ok(to_binary(\u0026query_simulation(deps, offer_asset)?)?)\n        }\n        QueryMsg::ReverseSimulation { ask_asset } =\u003e {\n            Ok(to_binary(\u0026query_reverse_simulation(deps, ask_asset)?)?)\n        }\n    }\n}\n\npub fn query_pair_info(deps: Deps) -\u003e Result\u003cPairInfo, ContractError\u003e {\n    let pair_info: PairInfoRaw = PAIR_INFO.load(deps.storage)?;\n    let pair_info = pair_info.to_normal(deps.api)?;\n\n    Ok(pair_info)\n}\n\npub fn query_pool(deps: Deps) -\u003e Result\u003cPoolResponse, ContractError\u003e {\n    let pair_info: PairInfoRaw = PAIR_INFO.load(deps.storage)?;\n    let contract_addr = deps.api.addr_humanize(\u0026pair_info.contract_addr)?;\n    let assets: [Asset; 2] = pair_info.query_pools(\u0026deps.querier, deps.api, contract_addr)?;\n    let total_share: Uint128 = query_token_info(\n        \u0026deps.querier,\n        deps.api.addr_humanize(\u0026pair_info.liquidity_token)?,\n    )?\n    .total_supply;\n\n    let resp = PoolResponse {\n        assets,\n        total_share,\n    };\n\n    Ok(resp)\n}\n\npub fn query_simulation(\n    deps: Deps,\n    offer_asset: Asset,\n) -\u003e Result\u003cSimulationResponse, ContractError\u003e {\n    let pair_info: PairInfoRaw = PAIR_INFO.load(deps.storage)?;\n\n    let contract_addr = deps.api.addr_humanize(\u0026pair_info.contract_addr)?;\n    let pools: [Asset; 2] = pair_info.query_pools(\u0026deps.querier, deps.api, contract_addr)?;\n\n    let offer_pool: Asset;\n    let ask_pool: Asset;\n    if offer_asset.info.equal(\u0026pools[0].info) {\n        offer_pool = pools[0].clone();\n        ask_pool = pools[1].clone();\n    } else if offer_asset.info.equal(\u0026pools[1].info) {\n        offer_pool = pools[1].clone();\n        ask_pool = pools[0].clone();\n    } else {\n        return Err(ContractError::AssetMismatch {});\n    }\n\n    let (return_amount, spread_amount, commission_amount) =\n        compute_swap(offer_pool.amount, ask_pool.amount, offer_asset.amount);\n\n    Ok(SimulationResponse {\n        return_amount,\n        spread_amount,\n        commission_amount,\n    })\n}\n\npub fn query_reverse_simulation(\n    deps: Deps,\n    ask_asset: Asset,\n) -\u003e Result\u003cReverseSimulationResponse, ContractError\u003e {\n    // get pair info\n    let pair_info: PairInfoRaw = PAIR_INFO.load(deps.storage)?;\n\n    // get address of the pair contract\n    let contract_addr = deps.api.addr_humanize(\u0026pair_info.contract_addr)?;\n    \n    // get pool info of the pair contract\n    let pools: [Asset; 2] = pair_info.query_pools(\u0026deps.querier, deps.api, contract_addr)?;\n\n    let offer_pool: Asset;\n    let ask_pool: Asset;\n    if ask_asset.info.equal(\u0026pools[0].info) {\n        ask_pool = pools[0].clone();\n        offer_pool = pools[1].clone();\n    } else if ask_asset.info.equal(\u0026pools[1].info) {\n        ask_pool = pools[1].clone();\n        offer_pool = pools[0].clone();\n    } else {\n        return Err(ContractError::AssetMismatch {});\n    }\n\n    // compute offer amount, spread amount, commission amount when user provide ask amount\n    let (offer_amount, spread_amount, commission_amount) =\n        compute_offer_amount(offer_pool.amount, ask_pool.amount, ask_asset.amount);\n\n    Ok(ReverseSimulationResponse {\n        offer_amount,\n        spread_amount,\n        commission_amount,\n    })\n}\n\npub fn amount_of(coins: \u0026[Coin], denom: String) -\u003e Uint128 {\n    match coins.iter().find(|x| x.denom == denom) {\n        Some(coin) =\u003e coin.amount,\n        None =\u003e Uint128::zero(),\n    }\n}\n\n// User want to swap from 'offer' to 'ask'\n// Calculate the expected return_amount, spread_amount and commission_amount based on the formula\n// return_amount = offer_amount * (1 - spread) * ask_pool / (offer_pool + offer_amount)\nfn  compute_swap(\n    offer_pool: Uint128,\n    ask_pool: Uint128,\n    offer_amount: Uint128,\n) -\u003e (Uint128, Uint128, Uint128) {\n    let offer_pool: Uint256 = Uint256::from(offer_pool);\n    let ask_pool: Uint256 = ask_pool.into();\n    let offer_amount: Uint256 = offer_amount.into();\n\n    // Commission rate OR Fee amount for framework\n    let commission_rate = Decimal256::from_str(COMMISSION_RATE).unwrap();\n\n    // offer =\u003e ask\n    // hoanm: EQUATION - B = (R_B - \\frac{K}{R_A + A}) * (1 - F)\n    // ask_amount = (ask_pool - cp / (offer_pool + offer_amount)) * (1 - commission_rate)\n\n    // cp (constant product) is K  in the EQUATION\n    let cp: Uint256 = offer_pool * ask_pool;\n\n    // calculate the ask_amount without commission\n    let return_amount: Uint256 = (Decimal256::from_uint256(ask_pool)\n        - Decimal256::from_ratio(cp, offer_pool + offer_amount))\n        * Uint256::one();\n\n    // calculate the spread_amount\n    // hoanm: EQUATION - SPREAD = (A * \\frac{R_B}{R_A}) - B\n    let spread_amount: Uint256 =\n        (offer_amount * Decimal256::from_ratio(ask_pool, offer_pool)) - return_amount;\n\n    // calculate the commission_amount\n    let commission_amount: Uint256 = return_amount * commission_rate;\n\n    // commission will be absorbed to pool and the currency will be the same as the ask currency\n    let return_amount: Uint256 = return_amount - commission_amount;\n    (\n        return_amount.into(),\n        spread_amount.into(),\n        commission_amount.into(),\n    )\n}\n\n#[test]\nfn test_compute_swap_with_huge_pool_variance() {\n    let offer_pool = Uint128::from(395451850234u128);\n    let ask_pool = Uint128::from(317u128);\n\n    assert_eq!(\n        compute_swap(offer_pool, ask_pool, Uint128::from(1u128)).0,\n        Uint128::zero()\n    );\n}\n\n// The function to get the offer_amount when user provide ask_amount\nfn compute_offer_amount(\n    offer_pool: Uint128,\n    ask_pool: Uint128,\n    ask_amount: Uint128,\n) -\u003e (Uint128, Uint128, Uint128) {\n    let offer_pool: Uint256 = offer_pool.into();\n    let ask_pool: Uint256 = ask_pool.into();\n    let ask_amount: Uint256 = ask_amount.into();\n\n    let commission_rate = Decimal256::from_str(COMMISSION_RATE).unwrap();\n\n    // EQUATION: A = \\frac{K}{R_B - (B * (1-P))} - R_A\n    // ask =\u003e offer\n    // offer_amount = cp / (ask_pool - ask_amount / (1 - commission_rate)) - offer_pool\n    let cp: Uint256 = offer_pool * ask_pool;\n\n    let one_minus_commission = Decimal256::one() - commission_rate;\n    let inv_one_minus_commission = Decimal256::one() / one_minus_commission;\n\n    let offer_amount: Uint256 = Uint256::one()\n        .multiply_ratio(cp, ask_pool - ask_amount * inv_one_minus_commission)\n        - offer_pool;\n\n    let before_commission_deduction: Uint256 = ask_amount * inv_one_minus_commission;\n    let before_spread_deduction: Uint256 =\n        offer_amount * Decimal256::from_ratio(ask_pool, offer_pool);\n\n    let spread_amount = if before_spread_deduction \u003e before_commission_deduction {\n        before_spread_deduction - before_commission_deduction\n    } else {\n        Uint256::zero()\n    };\n\n    let commission_amount = before_commission_deduction * commission_rate;\n\n    (\n        offer_amount.into(),\n        spread_amount.into(),\n        commission_amount.into(),\n    )\n}\n\n/// If `belief_price` and `max_spread` both are given,\n/// we compute new spread else we just use halo\n/// spread to check `max_spread`\npub fn assert_max_spread(\n    belief_price: Option\u003cDecimal\u003e,\n    max_spread: Option\u003cDecimal\u003e,\n    offer_asset: Asset,\n    return_asset: Asset,\n    spread_amount: Uint128,\n    offer_decimal: u8,\n    return_decimal: u8,\n) -\u003e Result\u003c(), ContractError\u003e {\n    let (offer_amount, return_amount, spread_amount): (Uint256, Uint256, Uint256) =\n        match offer_decimal.cmp(\u0026return_decimal) {\n            Ordering::Greater =\u003e {\n                let diff_decimal = 10u64.pow((offer_decimal - return_decimal).into());\n\n                (\n                    offer_asset.amount.into(),\n                    return_asset\n                        .amount\n                        .checked_mul(Uint128::from(diff_decimal))?\n                        .into(),\n                    spread_amount\n                        .checked_mul(Uint128::from(diff_decimal))?\n                        .into(),\n                )\n            }\n            Ordering::Less =\u003e {\n                let diff_decimal = 10u64.pow((return_decimal - offer_decimal).into());\n\n                (\n                    offer_asset\n                        .amount\n                        .checked_mul(Uint128::from(diff_decimal))?\n                        .into(),\n                    return_asset.amount.into(),\n                    spread_amount.into(),\n                )\n            }\n            Ordering::Equal =\u003e (\n                offer_asset.amount.into(),\n                return_asset.amount.into(),\n                spread_amount.into(),\n            ),\n        };\n\n    if let (Some(max_spread), Some(belief_price)) = (max_spread, belief_price) {\n        let belief_price: Decimal256 = belief_price.into();\n        let max_spread: Decimal256 = max_spread.into();\n\n        let expected_return = offer_amount / belief_price;\n        let spread_amount = if expected_return \u003e return_amount {\n            expected_return - return_amount\n        } else {\n            Uint256::zero()\n        };\n\n        if return_amount \u003c expected_return\n            \u0026\u0026 Decimal256::from_ratio(spread_amount, expected_return) \u003e max_spread\n        {\n            return Err(ContractError::MaxSpreadAssertion {});\n        }\n    } else if let Some(max_spread) = max_spread {\n        let max_spread: Decimal256 = max_spread.into();\n        if Decimal256::from_ratio(spread_amount, return_amount + spread_amount) \u003e max_spread {\n            return Err(ContractError::MaxSpreadAssertion {});\n        }\n    }\n\n    Ok(())\n}\n\nfn assert_slippage_tolerance(\n    slippage_tolerance: \u0026Option\u003cDecimal\u003e,\n    deposits: \u0026[Uint128; 2],\n    pools: \u0026[Asset; 2],\n) -\u003e Result\u003c(), ContractError\u003e {\n    if let Some(slippage_tolerance) = *slippage_tolerance {\n        let slippage_tolerance: Decimal256 = slippage_tolerance.into();\n        // the slippage tolerance cannot be greater than 100%\n        if slippage_tolerance \u003e Decimal256::one() {\n            return Err(StdError::generic_err(\"slippage_tolerance cannot bigger than 1\").into());\n        }\n\n        let one_minus_slippage_tolerance = Decimal256::one() - slippage_tolerance;\n        let deposits: [Uint256; 2] = [deposits[0].into(), deposits[1].into()];\n        let pools: [Uint256; 2] = [pools[0].amount.into(), pools[1].amount.into()];\n\n        // Ensure each prices are not dropped as much as slippage tolerance rate\n        // hoanm: EQUATION - \\frac{A}{B} * (1-ST) \u003e \\frac{R_A}{R_B} \\parallel \\frac{B}{A} * (1-ST) \u003e \\frac{R_B}{R_A}\n        if Decimal256::from_ratio(deposits[0], deposits[1]) * one_minus_slippage_tolerance\n            \u003e Decimal256::from_ratio(pools[0], pools[1])\n            || Decimal256::from_ratio(deposits[1], deposits[0]) * one_minus_slippage_tolerance\n                \u003e Decimal256::from_ratio(pools[1], pools[0])\n        {\n            return Err(ContractError::MaxSlippageAssertion {});\n        }\n    }\n\n    Ok(())\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn migrate(deps: DepsMut, _env: Env, _msg: MigrateMsg) -\u003e Result\u003cResponse, ContractError\u003e {\n    set_contract_version(deps.storage, CONTRACT_NAME, CONTRACT_VERSION)?;\n\n    Ok(Response::default())\n}\n","traces":[{"line":42,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":252,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":273,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":279,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":280,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":283,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":284,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":285,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":286,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":289,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":290,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":291,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":300,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":306,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":307,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":310,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":311,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":312,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":314,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":315,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":316,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":317,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":318,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":319,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":320,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":321,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":322,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":324,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":327,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":328,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":329,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":330,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":331,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":332,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":336,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":343,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":344,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":346,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":347,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":349,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":350,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":352,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":353,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":354,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":358,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":359,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":360,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":361,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":362,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":365,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":366,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":367,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":368,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":369,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":370,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":373,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":374,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":375,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":376,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":378,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":379,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":396,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":398,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":400,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":409,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":411,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":412,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":414,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":416,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":417,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":418,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":420,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":421,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":423,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":425,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":426,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":428,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":431,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":432,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":433,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":436,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":440,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":442,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":443,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":444,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":445,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":446,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":447,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":448,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":451,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":453,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":454,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":455,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":460,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":461,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":462,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":463,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":464,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":465,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":466,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":467,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":468,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":469,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":474,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":475,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":476,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":477,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":478,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":479,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":481,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":482,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":487,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":488,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":489,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":491,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":494,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":495,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":496,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":497,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":498,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":499,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":500,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":509,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":512,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":516,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":518,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":519,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":523,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":524,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":525,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":526,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":527,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":528,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":530,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":533,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":534,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":536,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":537,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":538,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":539,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":543,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":548,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":551,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":554,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":558,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":559,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":560,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":561,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":562,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":563,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":565,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":569,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":570,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":572,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":573,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":574,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":575,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":579,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":580,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":581,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":582,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":589,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":594,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":595,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":596,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":598,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":599,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":601,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":602,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":603,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":605,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":606,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":608,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":609,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":610,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":611,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":613,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":614,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":615,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":616,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":618,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":619,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":621,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":622,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":624,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":625,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":626,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":642,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":647,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":648,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":649,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":651,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":653,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":654,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":655,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":656,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":658,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":659,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":661,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":662,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":663,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":665,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":666,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":667,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":669,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":670,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":672,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":675,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":678,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":679,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":680,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":687,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":696,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":697,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":699,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":702,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":703,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":704,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":705,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":706,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":707,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":708,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":709,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":713,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":716,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":717,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":718,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":719,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":720,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":721,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":724,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":725,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":726,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":727,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":731,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":732,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":733,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":735,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":736,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":737,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":739,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":742,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":743,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":745,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":747,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":748,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":749,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":750,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":754,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":762,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":763,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":764,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":765,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":766,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":769,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":770,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":771,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":773,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":774,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":775,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":776,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":777,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":778,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":780,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":784,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":789,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":791,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":373,"coverable":399},{"path":["/","Users","haitran","AURA-NETWORK","smart-contracts-halotrade-zone","contracts","halo-pair","src","error.rs"],"content":"use cosmwasm_std::{OverflowError, StdError};\nuse thiserror::Error;\n\n#[derive(Error, Debug, PartialEq)]\npub enum ContractError {\n    #[error(\"{0}\")]\n    Std(#[from] StdError),\n\n    #[error(\"{0}\")]\n    OverflowError(#[from] OverflowError),\n\n    #[error(\"Unauthorized\")]\n    Unauthorized {},\n\n    #[error(\"Invalid zero amount\")]\n    InvalidZeroAmount {},\n\n    #[error(\"Max spread assertion\")]\n    MaxSpreadAssertion {},\n\n    #[error(\"Max slippage assertion\")]\n    MaxSlippageAssertion {},\n\n    #[error(\"Asset mismatch\")]\n    AssetMismatch {},\n\n    #[error(\"Too small offer amount\")]\n    TooSmallOfferAmount {},\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","haitran","AURA-NETWORK","smart-contracts-halotrade-zone","contracts","halo-pair","src","lib.rs"],"content":"pub mod contract;\npub mod state;\n\nmod error;\n\n#[cfg(test)]\nmod testing;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","haitran","AURA-NETWORK","smart-contracts-halotrade-zone","contracts","halo-pair","src","state.rs"],"content":"use cw_storage_plus::Item;\nuse haloswap::asset::PairInfoRaw;\n\npub const PAIR_INFO: Item\u003cPairInfoRaw\u003e = Item::new(\"pair_info\");\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","haitran","AURA-NETWORK","smart-contracts-halotrade-zone","contracts","halo-pair","src","testing.rs"],"content":"use crate::contract::{\n    assert_max_spread, execute, instantiate, query_pair_info, query_pool, query_reverse_simulation,\n    query_simulation, reply,\n};\nuse crate::error::ContractError;\nuse haloswap::mock_querier::mock_dependencies;\n\nuse cosmwasm_std::testing::{mock_env, mock_info, MOCK_CONTRACT_ADDR};\nuse cosmwasm_std::{\n    attr, to_binary, BankMsg, Coin, CosmosMsg, Decimal, Reply, ReplyOn, Response, StdError, SubMsg,\n    SubMsgResponse, SubMsgResult, Uint128, WasmMsg, Addr,\n};\nuse cw20::{Cw20ExecuteMsg, Cw20ReceiveMsg, MinterResponse};\nuse haloswap::asset::{Asset, AssetInfo, PairInfo, CreatePairRequirements};\nuse haloswap::pair::{\n    Cw20HookMsg, ExecuteMsg, InstantiateMsg, PoolResponse, ReverseSimulationResponse,\n    SimulationResponse,\n};\nuse haloswap::token::InstantiateMsg as TokenInstantiateMsg;\n\n#[test]\nfn proper_initialization() {\n    let mut deps = mock_dependencies(\u0026[]);\n\n    let msg = InstantiateMsg {\n        asset_infos: [\n            AssetInfo::NativeToken {\n                denom: \"uusd\".to_string(),\n            },\n            AssetInfo::Token {\n                contract_addr: \"asset0000\".to_string(),\n            },\n        ],\n        token_code_id: 10u64,\n        asset_decimals: [6u8, 8u8],\n        requirements: CreatePairRequirements {\n            whitelist: vec![Addr::unchecked(\"addr0000\")],\n            first_asset_minimum: Uint128::zero(),\n            second_asset_minimum: Uint128::zero(),\n        },\n    };\n\n    // we can just call .unwrap() to assert this was a success\n    let env = mock_env();\n    let info = mock_info(\"addr0000\", \u0026[]);\n    let res = instantiate(deps.as_mut(), env, info, msg).unwrap();\n    assert_eq!(\n        res.messages,\n        vec![SubMsg {\n            msg: WasmMsg::Instantiate {\n                code_id: 10u64,\n                msg: to_binary(\u0026TokenInstantiateMsg {\n                    name: \"halo liquidity token\".to_string(),\n                    symbol: \"uLP\".to_string(),\n                    decimals: 6,\n                    initial_balances: vec![],\n                    mint: Some(MinterResponse {\n                        minter: MOCK_CONTRACT_ADDR.to_string(),\n                        cap: None,\n                    }),\n                })\n                .unwrap(),\n                funds: vec![],\n                label: \"lp\".to_string(),\n                admin: None,\n            }\n            .into(),\n            gas_limit: None,\n            id: 1,\n            reply_on: ReplyOn::Success,\n        }]\n    );\n\n    // store liquidity token\n    let reply_msg = Reply {\n        id: 1,\n        result: SubMsgResult::Ok(SubMsgResponse {\n            events: vec![],\n            data: Some(\n                vec![\n                    10, 13, 108, 105, 113, 117, 105, 100, 105, 116, 121, 48, 48, 48, 48,\n                ]\n                .into(),\n            ),\n        }),\n    };\n\n    let _res = reply(deps.as_mut(), mock_env(), reply_msg).unwrap();\n\n    // it worked, let's query the state\n    let pair_info: PairInfo = query_pair_info(deps.as_ref()).unwrap();\n    assert_eq!(\"liquidity0000\", pair_info.liquidity_token.as_str());\n    assert_eq!(\n        pair_info.asset_infos,\n        [\n            AssetInfo::NativeToken {\n                denom: \"uusd\".to_string(),\n            },\n            AssetInfo::Token {\n                contract_addr: \"asset0000\".to_string()\n            }\n        ]\n    );\n}\n\n#[test]\nfn provide_liquidity() {\n    let mut deps = mock_dependencies(\u0026[Coin {\n        denom: \"uusd\".to_string(),\n        amount: Uint128::from(200u128),\n    }]);\n\n    deps.querier.with_token_balances(\u0026[\n        (\n            \u0026\"liquidity0000\".to_string(),\n            \u0026[(\u0026MOCK_CONTRACT_ADDR.to_string(), \u0026Uint128::zero())],\n        ),\n        (\u0026\"asset0000\".to_string(), \u0026[]),\n    ]);\n\n    let msg = InstantiateMsg {\n        asset_infos: [\n            AssetInfo::NativeToken {\n                denom: \"uusd\".to_string(),\n            },\n            AssetInfo::Token {\n                contract_addr: \"asset0000\".to_string(),\n            },\n        ],\n        token_code_id: 10u64,\n        asset_decimals: [6u8, 8u8],\n        requirements: CreatePairRequirements {\n            whitelist: vec![Addr::unchecked(\"addr0000\")],\n            first_asset_minimum: Uint128::zero(),\n            second_asset_minimum: Uint128::zero(),\n        },\n    };\n\n    let env = mock_env();\n    let info = mock_info(\"addr0000\", \u0026[]);\n    // we can just call .unwrap() to assert this was a success\n    let _res = instantiate(deps.as_mut(), env, info, msg).unwrap();\n\n    // store liquidity token\n    let reply_msg = Reply {\n        id: 1,\n        result: SubMsgResult::Ok(SubMsgResponse {\n            events: vec![],\n            data: Some(\n                vec![\n                    10, 13, 108, 105, 113, 117, 105, 100, 105, 116, 121, 48, 48, 48, 48,\n                ]\n                .into(),\n            ),\n        }),\n    };\n\n    let _res = reply(deps.as_mut(), mock_env(), reply_msg).unwrap();\n\n    // successfully provide liquidity for the exist pool\n    let msg = ExecuteMsg::ProvideLiquidity {\n        assets: [\n            Asset {\n                info: AssetInfo::Token {\n                    contract_addr: \"asset0000\".to_string(),\n                },\n                amount: Uint128::from(100u128),\n            },\n            Asset {\n                info: AssetInfo::NativeToken {\n                    denom: \"uusd\".to_string(),\n                },\n                amount: Uint128::from(100u128),\n            },\n        ],\n        slippage_tolerance: None,\n        receiver: None,\n    };\n\n    let env = mock_env();\n    let info = mock_info(\n        \"addr0000\",\n        \u0026[Coin {\n            denom: \"uusd\".to_string(),\n            amount: Uint128::from(100u128),\n        }],\n    );\n    let res = execute(deps.as_mut(), env, info, msg).unwrap();\n    let transfer_from_msg = res.messages.get(0).expect(\"no message\");\n    let mint_msg = res.messages.get(1).expect(\"no message\");\n    assert_eq!(\n        transfer_from_msg,\n        \u0026SubMsg::new(CosmosMsg::Wasm(WasmMsg::Execute {\n            contract_addr: \"asset0000\".to_string(),\n            msg: to_binary(\u0026Cw20ExecuteMsg::TransferFrom {\n                owner: \"addr0000\".to_string(),\n                recipient: MOCK_CONTRACT_ADDR.to_string(),\n                amount: Uint128::from(100u128),\n            })\n            .unwrap(),\n            funds: vec![],\n        }))\n    );\n    assert_eq!(\n        mint_msg,\n        \u0026SubMsg::new(CosmosMsg::Wasm(WasmMsg::Execute {\n            contract_addr: \"liquidity0000\".to_string(),\n            msg: to_binary(\u0026Cw20ExecuteMsg::Mint {\n                recipient: \"addr0000\".to_string(),\n                amount: Uint128::from(100u128),\n            })\n            .unwrap(),\n            funds: vec![],\n        }))\n    );\n\n    // provide more liquidity 1:2, which is not proportional to 1:1,\n    // then it must accept 1:1 and treat left amount as donation\n    deps.querier.with_balance(\u0026[(\n        \u0026MOCK_CONTRACT_ADDR.to_string(),\n        vec![Coin {\n            denom: \"uusd\".to_string(),\n            amount: Uint128::from(\n                200u128 + 200u128, /* user deposit must be pre-applied */\n            ),\n        }],\n    )]);\n\n    deps.querier.with_token_balances(\u0026[\n        (\n            \u0026\"liquidity0000\".to_string(),\n            \u0026[(\u0026MOCK_CONTRACT_ADDR.to_string(), \u0026Uint128::from(100u128))],\n        ),\n        (\n            \u0026\"asset0000\".to_string(),\n            \u0026[(\u0026MOCK_CONTRACT_ADDR.to_string(), \u0026Uint128::from(200u128))],\n        ),\n    ]);\n\n    let msg = ExecuteMsg::ProvideLiquidity {\n        assets: [\n            Asset {\n                info: AssetInfo::Token {\n                    contract_addr: \"asset0000\".to_string(),\n                },\n                amount: Uint128::from(100u128),\n            },\n            Asset {\n                info: AssetInfo::NativeToken {\n                    denom: \"uusd\".to_string(),\n                },\n                amount: Uint128::from(200u128),\n            },\n        ],\n        slippage_tolerance: None,\n        receiver: Some(\"staking0000\".to_string()), // try changing receiver\n    };\n\n    let env = mock_env();\n    let info = mock_info(\n        \"addr0000\",\n        \u0026[Coin {\n            denom: \"uusd\".to_string(),\n            amount: Uint128::from(200u128),\n        }],\n    );\n\n    // only accept 100, then 50 share will be generated with 100 * (100 / 200)\n    let res: Response = execute(deps.as_mut(), env, info, msg).unwrap();\n    let transfer_from_msg = res.messages.get(0).expect(\"no message\");\n    let mint_msg = res.messages.get(1).expect(\"no message\");\n    assert_eq!(\n        transfer_from_msg,\n        \u0026SubMsg::new(CosmosMsg::Wasm(WasmMsg::Execute {\n            contract_addr: \"asset0000\".to_string(),\n            msg: to_binary(\u0026Cw20ExecuteMsg::TransferFrom {\n                owner: \"addr0000\".to_string(),\n                recipient: MOCK_CONTRACT_ADDR.to_string(),\n                amount: Uint128::from(100u128),\n            })\n            .unwrap(),\n            funds: vec![],\n        }))\n    );\n    assert_eq!(\n        mint_msg,\n        \u0026SubMsg::new(CosmosMsg::Wasm(WasmMsg::Execute {\n            contract_addr: \"liquidity0000\".to_string(),\n            msg: to_binary(\u0026Cw20ExecuteMsg::Mint {\n                recipient: \"staking0000\".to_string(), // LP tokens sent to specified receiver\n                amount: Uint128::from(50u128),\n            })\n            .unwrap(),\n            funds: vec![],\n        }))\n    );\n\n    // check wrong argument\n    let msg = ExecuteMsg::ProvideLiquidity {\n        assets: [\n            Asset {\n                info: AssetInfo::Token {\n                    contract_addr: \"asset0000\".to_string(),\n                },\n                amount: Uint128::from(100u128),\n            },\n            Asset {\n                info: AssetInfo::NativeToken {\n                    denom: \"uusd\".to_string(),\n                },\n                amount: Uint128::from(50u128),\n            },\n        ],\n        slippage_tolerance: None,\n        receiver: None,\n    };\n\n    let env = mock_env();\n    let info = mock_info(\n        \"addr0000\",\n        \u0026[Coin {\n            denom: \"uusd\".to_string(),\n            amount: Uint128::from(100u128),\n        }],\n    );\n    let res = execute(deps.as_mut(), env, info, msg).unwrap_err();\n    match res {\n        ContractError::Std(StdError::GenericErr { msg, .. }) =\u003e assert_eq!(\n            msg,\n            \"Native token balance mismatch between the argument and the transferred\".to_string()\n        ),\n        _ =\u003e panic!(\"Must return generic error\"),\n    }\n\n    // initialize token balance to 1:1\n    deps.querier.with_balance(\u0026[(\n        \u0026MOCK_CONTRACT_ADDR.to_string(),\n        vec![Coin {\n            denom: \"uusd\".to_string(),\n            amount: Uint128::from(\n                100u128 + 100u128, /* user deposit must be pre-applied */\n            ),\n        }],\n    )]);\n\n    deps.querier.with_token_balances(\u0026[\n        (\n            \u0026\"liquidity0000\".to_string(),\n            \u0026[(\u0026MOCK_CONTRACT_ADDR.to_string(), \u0026Uint128::from(100u128))],\n        ),\n        (\n            \u0026\"asset0000\".to_string(),\n            \u0026[(\u0026MOCK_CONTRACT_ADDR.to_string(), \u0026Uint128::from(100u128))],\n        ),\n    ]);\n\n    // failed because the price is under slippage_tolerance\n    let msg = ExecuteMsg::ProvideLiquidity {\n        assets: [\n            Asset {\n                info: AssetInfo::Token {\n                    contract_addr: \"asset0000\".to_string(),\n                },\n                amount: Uint128::from(98u128),\n            },\n            Asset {\n                info: AssetInfo::NativeToken {\n                    denom: \"uusd\".to_string(),\n                },\n                amount: Uint128::from(100u128),\n            },\n        ],\n        slippage_tolerance: Some(Decimal::percent(1)),\n        receiver: None,\n    };\n\n    let env = mock_env();\n    let info = mock_info(\n        \"addr0001\",\n        \u0026[Coin {\n            denom: \"uusd\".to_string(),\n            amount: Uint128::from(100u128),\n        }],\n    );\n    let res = execute(deps.as_mut(), env, info, msg).unwrap_err();\n    match res {\n        ContractError::MaxSlippageAssertion {} =\u003e {}\n        _ =\u003e panic!(\"DO NOT ENTER HERE\"),\n    }\n\n    // initialize token balance to 1:1\n    deps.querier.with_balance(\u0026[(\n        \u0026MOCK_CONTRACT_ADDR.to_string(),\n        vec![Coin {\n            denom: \"uusd\".to_string(),\n            amount: Uint128::from(100u128 + 98u128 /* user deposit must be pre-applied */),\n        }],\n    )]);\n\n    // failed because the price is under slippage_tolerance\n    let msg = ExecuteMsg::ProvideLiquidity {\n        assets: [\n            Asset {\n                info: AssetInfo::Token {\n                    contract_addr: \"asset0000\".to_string(),\n                },\n                amount: Uint128::from(100u128),\n            },\n            Asset {\n                info: AssetInfo::NativeToken {\n                    denom: \"uusd\".to_string(),\n                },\n                amount: Uint128::from(98u128),\n            },\n        ],\n        slippage_tolerance: Some(Decimal::percent(1)),\n        receiver: None,\n    };\n\n    let env = mock_env();\n    let info = mock_info(\n        \"addr0001\",\n        \u0026[Coin {\n            denom: \"uusd\".to_string(),\n            amount: Uint128::from(98u128),\n        }],\n    );\n    let res = execute(deps.as_mut(), env, info, msg).unwrap_err();\n    match res {\n        ContractError::MaxSlippageAssertion {} =\u003e {}\n        _ =\u003e panic!(\"DO NOT ENTER HERE\"),\n    }\n\n    // initialize token balance to 1:1\n    deps.querier.with_balance(\u0026[(\n        \u0026MOCK_CONTRACT_ADDR.to_string(),\n        vec![Coin {\n            denom: \"uusd\".to_string(),\n            amount: Uint128::from(\n                100u128 + 100u128, /* user deposit must be pre-applied */\n            ),\n        }],\n    )]);\n\n    // successfully provides\n    let msg = ExecuteMsg::ProvideLiquidity {\n        assets: [\n            Asset {\n                info: AssetInfo::Token {\n                    contract_addr: \"asset0000\".to_string(),\n                },\n                amount: Uint128::from(99u128),\n            },\n            Asset {\n                info: AssetInfo::NativeToken {\n                    denom: \"uusd\".to_string(),\n                },\n                amount: Uint128::from(100u128),\n            },\n        ],\n        slippage_tolerance: Some(Decimal::percent(1)),\n        receiver: None,\n    };\n\n    let env = mock_env();\n    let info = mock_info(\n        \"addr0001\",\n        \u0026[Coin {\n            denom: \"uusd\".to_string(),\n            amount: Uint128::from(100u128),\n        }],\n    );\n    let _res = execute(deps.as_mut(), env, info, msg).unwrap();\n\n    // initialize token balance to 1:1\n    deps.querier.with_balance(\u0026[(\n        \u0026MOCK_CONTRACT_ADDR.to_string(),\n        vec![Coin {\n            denom: \"uusd\".to_string(),\n            amount: Uint128::from(100u128 + 99u128 /* user deposit must be pre-applied */),\n        }],\n    )]);\n\n    // successfully provides\n    let msg = ExecuteMsg::ProvideLiquidity {\n        assets: [\n            Asset {\n                info: AssetInfo::Token {\n                    contract_addr: \"asset0000\".to_string(),\n                },\n                amount: Uint128::from(100u128),\n            },\n            Asset {\n                info: AssetInfo::NativeToken {\n                    denom: \"uusd\".to_string(),\n                },\n                amount: Uint128::from(99u128),\n            },\n        ],\n        slippage_tolerance: Some(Decimal::percent(1)),\n        receiver: None,\n    };\n\n    let env = mock_env();\n    let info = mock_info(\n        \"addr0001\",\n        \u0026[Coin {\n            denom: \"uusd\".to_string(),\n            amount: Uint128::from(99u128),\n        }],\n    );\n    let _res = execute(deps.as_mut(), env, info, msg).unwrap();\n}\n\n#[test]\nfn withdraw_liquidity() {\n    let mut deps = mock_dependencies(\u0026[Coin {\n        denom: \"uusd\".to_string(),\n        amount: Uint128::from(100u128),\n    }]);\n\n    deps.querier.with_token_balances(\u0026[\n        (\n            \u0026\"liquidity0000\".to_string(),\n            \u0026[(\u0026\"addr0000\".to_string(), \u0026Uint128::from(100u128))],\n        ),\n        (\n            \u0026\"asset0000\".to_string(),\n            \u0026[(\u0026MOCK_CONTRACT_ADDR.to_string(), \u0026Uint128::from(100u128))],\n        ),\n    ]);\n\n    let msg = InstantiateMsg {\n        asset_infos: [\n            AssetInfo::NativeToken {\n                denom: \"uusd\".to_string(),\n            },\n            AssetInfo::Token {\n                contract_addr: \"asset0000\".to_string(),\n            },\n        ],\n        token_code_id: 10u64,\n        asset_decimals: [6u8, 8u8],\n        requirements: CreatePairRequirements {\n            whitelist: vec![Addr::unchecked(\"addr0000\")],\n            first_asset_minimum: Uint128::zero(),\n            second_asset_minimum: Uint128::zero(),\n        },\n    };\n\n    let env = mock_env();\n    let info = mock_info(\"addr0000\", \u0026[]);\n    // we can just call .unwrap() to assert this was a success\n    let _res = instantiate(deps.as_mut(), env, info, msg).unwrap();\n\n    // store liquidity token\n    let reply_msg = Reply {\n        id: 1,\n        result: SubMsgResult::Ok(SubMsgResponse {\n            events: vec![],\n            data: Some(\n                vec![\n                    10, 13, 108, 105, 113, 117, 105, 100, 105, 116, 121, 48, 48, 48, 48,\n                ]\n                .into(),\n            ),\n        }),\n    };\n\n    let _res = reply(deps.as_mut(), mock_env(), reply_msg).unwrap();\n\n    // withdraw liquidity\n    let msg = ExecuteMsg::Receive(Cw20ReceiveMsg {\n        sender: \"addr0000\".to_string(),\n        msg: to_binary(\u0026Cw20HookMsg::WithdrawLiquidity {}).unwrap(),\n        amount: Uint128::from(100u128),\n    });\n\n    let env = mock_env();\n    let info = mock_info(\"liquidity0000\", \u0026[]);\n    let res = execute(deps.as_mut(), env, info, msg).unwrap();\n    let log_withdrawn_share = res.attributes.get(2).expect(\"no log\");\n    let log_refund_assets = res.attributes.get(3).expect(\"no log\");\n    let msg_refund_0 = res.messages.get(0).expect(\"no message\");\n    let msg_refund_1 = res.messages.get(1).expect(\"no message\");\n    let msg_burn_liquidity = res.messages.get(2).expect(\"no message\");\n    assert_eq!(\n        msg_refund_0,\n        \u0026SubMsg::new(CosmosMsg::Bank(BankMsg::Send {\n            to_address: \"addr0000\".to_string(),\n            amount: vec![Coin {\n                denom: \"uusd\".to_string(),\n                amount: Uint128::from(100u128),\n            }],\n        }))\n    );\n    assert_eq!(\n        msg_refund_1,\n        \u0026SubMsg::new(CosmosMsg::Wasm(WasmMsg::Execute {\n            contract_addr: \"asset0000\".to_string(),\n            msg: to_binary(\u0026Cw20ExecuteMsg::Transfer {\n                recipient: \"addr0000\".to_string(),\n                amount: Uint128::from(100u128),\n            })\n            .unwrap(),\n            funds: vec![],\n        }))\n    );\n    assert_eq!(\n        msg_burn_liquidity,\n        \u0026SubMsg::new(CosmosMsg::Wasm(WasmMsg::Execute {\n            contract_addr: \"liquidity0000\".to_string(),\n            msg: to_binary(\u0026Cw20ExecuteMsg::Burn {\n                amount: Uint128::from(100u128),\n            })\n            .unwrap(),\n            funds: vec![],\n        }))\n    );\n\n    assert_eq!(\n        log_withdrawn_share,\n        \u0026attr(\"withdrawn_share\", 100u128.to_string())\n    );\n    assert_eq!(\n        log_refund_assets,\n        \u0026attr(\"refund_assets\", \"100uusd, 100asset0000\")\n    );\n}\n\n#[test]\nfn try_native_to_token() {\n    let total_share = Uint128::from(30000000000u128);\n    let asset_pool_amount = Uint128::from(20000000000u128);\n    let collateral_pool_amount = Uint128::from(30000000000u128);\n    let exchange_rate: Decimal = Decimal::from_ratio(asset_pool_amount, collateral_pool_amount);\n    let offer_amount = Uint128::from(1500000000u128);\n\n    let mut deps = mock_dependencies(\u0026[Coin {\n        denom: \"uusd\".to_string(),\n        amount: collateral_pool_amount + offer_amount, /* user deposit must be pre-applied */\n    }]);\n\n    deps.querier.with_token_balances(\u0026[\n        (\n            \u0026\"liquidity0000\".to_string(),\n            \u0026[(\u0026MOCK_CONTRACT_ADDR.to_string(), \u0026total_share)],\n        ),\n        (\n            \u0026\"asset0000\".to_string(),\n            \u0026[(\u0026MOCK_CONTRACT_ADDR.to_string(), \u0026asset_pool_amount)],\n        ),\n    ]);\n\n    let msg = InstantiateMsg {\n        asset_infos: [\n            AssetInfo::NativeToken {\n                denom: \"uusd\".to_string(),\n            },\n            AssetInfo::Token {\n                contract_addr: \"asset0000\".to_string(),\n            },\n        ],\n        token_code_id: 10u64,\n        asset_decimals: [6u8, 8u8],\n        requirements: CreatePairRequirements {\n            whitelist: vec![Addr::unchecked(\"addr0000\")],\n            first_asset_minimum: Uint128::zero(),\n            second_asset_minimum: Uint128::zero(),\n        },\n    };\n\n    let env = mock_env();\n    let info = mock_info(\"addr0000\", \u0026[]);\n    // we can just call .unwrap() to assert this was a success\n    let _res = instantiate(deps.as_mut(), env, info, msg).unwrap();\n\n    // store liquidity token\n    let reply_msg = Reply {\n        id: 1,\n        result: SubMsgResult::Ok(SubMsgResponse {\n            events: vec![],\n            data: Some(\n                vec![\n                    10, 13, 108, 105, 113, 117, 105, 100, 105, 116, 121, 48, 48, 48, 48,\n                ]\n                .into(),\n            ),\n        }),\n    };\n\n    let _res = reply(deps.as_mut(), mock_env(), reply_msg).unwrap();\n\n    // normal swap\n    let msg = ExecuteMsg::Swap {\n        offer_asset: Asset {\n            info: AssetInfo::NativeToken {\n                denom: \"uusd\".to_string(),\n            },\n            amount: offer_amount,\n        },\n        belief_price: None,\n        max_spread: None,\n        to: None,\n    };\n    let env = mock_env();\n    let info = mock_info(\n        \"addr0000\",\n        \u0026[Coin {\n            denom: \"uusd\".to_string(),\n            amount: offer_amount,\n        }],\n    );\n    let res = execute(deps.as_mut(), env, info, msg).unwrap();\n    let msg_transfer = res.messages.get(0).expect(\"no message\");\n\n    // current price is 1.5, so expected return without spread is 1000\n    // 952.380952 = 20000 - 20000 * 30000 / (30000 + 1500)\n    let expected_ret_amount = Uint128::from(952_380_952u128);\n    let expected_spread_amount = (offer_amount * exchange_rate)\n        .checked_sub(expected_ret_amount)\n        .unwrap();\n    let expected_commission_amount = expected_ret_amount.multiply_ratio(3u128, 1000u128); // 0.3%\n    let expected_return_amount = expected_ret_amount\n        .checked_sub(expected_commission_amount)\n        .unwrap();\n    // check simulation res\n    deps.querier.with_balance(\u0026[(\n        \u0026MOCK_CONTRACT_ADDR.to_string(),\n        vec![Coin {\n            denom: \"uusd\".to_string(),\n            amount: collateral_pool_amount, /* user deposit must be pre-applied */\n        }],\n    )]);\n\n    let simulation_res: SimulationResponse = query_simulation(\n        deps.as_ref(),\n        Asset {\n            info: AssetInfo::NativeToken {\n                denom: \"uusd\".to_string(),\n            },\n            amount: offer_amount,\n        },\n    )\n    .unwrap();\n    assert_eq!(expected_return_amount, simulation_res.return_amount);\n    assert_eq!(expected_commission_amount, simulation_res.commission_amount);\n    assert_eq!(expected_spread_amount, simulation_res.spread_amount);\n\n    // check reverse simulation res\n    let reverse_simulation_res: ReverseSimulationResponse = query_reverse_simulation(\n        deps.as_ref(),\n        Asset {\n            info: AssetInfo::Token {\n                contract_addr: \"asset0000\".to_string(),\n            },\n            amount: expected_return_amount,\n        },\n    )\n    .unwrap();\n\n    assert!(\n        (offer_amount.u128() as i128 - reverse_simulation_res.offer_amount.u128() as i128).abs()\n            \u003c 3i128\n    );\n    assert!(\n        (expected_commission_amount.u128() as i128\n            - reverse_simulation_res.commission_amount.u128() as i128)\n            .abs()\n            \u003c 3i128\n    );\n    assert!(\n        (expected_spread_amount.u128() as i128\n            - reverse_simulation_res.spread_amount.u128() as i128)\n            .abs()\n            \u003c 3i128\n    );\n\n    assert_eq!(\n        res.attributes,\n        vec![\n            attr(\"action\", \"swap\"),\n            attr(\"sender\", \"addr0000\"),\n            attr(\"receiver\", \"addr0000\"),\n            attr(\"offer_asset\", \"uusd\"),\n            attr(\"ask_asset\", \"asset0000\"),\n            attr(\"offer_amount\", offer_amount.to_string()),\n            attr(\"return_amount\", expected_return_amount.to_string()),\n            attr(\"spread_amount\", expected_spread_amount.to_string()),\n            attr(\"commission_amount\", expected_commission_amount.to_string()),\n        ]\n    );\n\n    assert_eq!(\n        \u0026SubMsg::new(CosmosMsg::Wasm(WasmMsg::Execute {\n            contract_addr: \"asset0000\".to_string(),\n            msg: to_binary(\u0026Cw20ExecuteMsg::Transfer {\n                recipient: \"addr0000\".to_string(),\n                amount: expected_return_amount,\n            })\n            .unwrap(),\n            funds: vec![],\n        })),\n        msg_transfer,\n    );\n}\n\n#[test]\nfn try_token_to_native() {\n    let total_share = Uint128::from(20000000000u128);\n    let asset_pool_amount = Uint128::from(30000000000u128);\n    let collateral_pool_amount = Uint128::from(20000000000u128);\n    let exchange_rate = Decimal::from_ratio(collateral_pool_amount, asset_pool_amount);\n    let offer_amount = Uint128::from(1500000000u128);\n\n    let mut deps = mock_dependencies(\u0026[Coin {\n        denom: \"uusd\".to_string(),\n        amount: collateral_pool_amount,\n    }]);\n    deps.querier.with_token_balances(\u0026[\n        (\n            \u0026\"liquidity0000\".to_string(),\n            \u0026[(\u0026MOCK_CONTRACT_ADDR.to_string(), \u0026total_share)],\n        ),\n        (\n            \u0026\"asset0000\".to_string(),\n            \u0026[(\n                \u0026MOCK_CONTRACT_ADDR.to_string(),\n                \u0026(asset_pool_amount + offer_amount),\n            )],\n        ),\n    ]);\n\n    let msg = InstantiateMsg {\n        asset_infos: [\n            AssetInfo::NativeToken {\n                denom: \"uusd\".to_string(),\n            },\n            AssetInfo::Token {\n                contract_addr: \"asset0000\".to_string(),\n            },\n        ],\n        token_code_id: 10u64,\n        asset_decimals: [8u8, 8u8],\n        requirements: CreatePairRequirements {\n            whitelist: vec![Addr::unchecked(\"addr0000\")],\n            first_asset_minimum: Uint128::zero(),\n            second_asset_minimum: Uint128::zero(),\n        },\n    };\n\n    let env = mock_env();\n    let info = mock_info(\"addr0000\", \u0026[]);\n    // we can just call .unwrap() to assert this was a success\n    let _res = instantiate(deps.as_mut(), env, info, msg).unwrap();\n\n    // store liquidity token\n    let reply_msg = Reply {\n        id: 1,\n        result: SubMsgResult::Ok(SubMsgResponse {\n            events: vec![],\n            data: Some(\n                vec![\n                    10, 13, 108, 105, 113, 117, 105, 100, 105, 116, 121, 48, 48, 48, 48,\n                ]\n                .into(),\n            ),\n        }),\n    };\n\n    let _res = reply(deps.as_mut(), mock_env(), reply_msg).unwrap();\n\n    // unauthorized access; can not execute swap directly for token swap\n    let msg = ExecuteMsg::Swap {\n        offer_asset: Asset {\n            info: AssetInfo::Token {\n                contract_addr: \"asset0000\".to_string(),\n            },\n            amount: offer_amount,\n        },\n        belief_price: None,\n        max_spread: None,\n        to: None,\n    };\n    let env = mock_env();\n    let info = mock_info(\"addr0000\", \u0026[]);\n    let res = execute(deps.as_mut(), env, info, msg).unwrap_err();\n    match res {\n        ContractError::Unauthorized {} =\u003e (),\n        _ =\u003e panic!(\"DO NOT ENTER HERE\"),\n    }\n\n    // normal sell\n    let msg = ExecuteMsg::Receive(Cw20ReceiveMsg {\n        sender: \"addr0000\".to_string(),\n        amount: offer_amount,\n        msg: to_binary(\u0026Cw20HookMsg::Swap {\n            belief_price: None,\n            max_spread: None,\n            to: None,\n        })\n        .unwrap(),\n    });\n    let env = mock_env();\n    let info = mock_info(\"asset0000\", \u0026[]);\n\n    let res = execute(deps.as_mut(), env, info, msg).unwrap();\n    let msg_transfer = res.messages.get(0).expect(\"no message\");\n\n    // current price is 1.5, so expected return without spread is 1000\n    // 952.380952 = 20000 - 20000 * 30000 / (30000 + 1500)\n    let expected_ret_amount = Uint128::from(952_380_952u128);\n    let expected_spread_amount = (offer_amount * exchange_rate)\n        .checked_sub(expected_ret_amount)\n        .unwrap();\n    let expected_commission_amount = expected_ret_amount.multiply_ratio(3u128, 1000u128); // 0.3%\n    let expected_return_amount = expected_ret_amount\n        .checked_sub(expected_commission_amount)\n        .unwrap();\n    // check simulation res\n    // return asset token balance as normal\n    deps.querier.with_token_balances(\u0026[\n        (\n            \u0026\"liquidity0000\".to_string(),\n            \u0026[(\u0026MOCK_CONTRACT_ADDR.to_string(), \u0026total_share)],\n        ),\n        (\n            \u0026\"asset0000\".to_string(),\n            \u0026[(\u0026MOCK_CONTRACT_ADDR.to_string(), \u0026(asset_pool_amount))],\n        ),\n    ]);\n\n    let simulation_res: SimulationResponse = query_simulation(\n        deps.as_ref(),\n        Asset {\n            amount: offer_amount,\n            info: AssetInfo::Token {\n                contract_addr: \"asset0000\".to_string(),\n            },\n        },\n    )\n    .unwrap();\n    assert_eq!(expected_return_amount, simulation_res.return_amount);\n    assert_eq!(expected_commission_amount, simulation_res.commission_amount);\n    assert_eq!(expected_spread_amount, simulation_res.spread_amount);\n\n    // check reverse simulation res\n    let reverse_simulation_res: ReverseSimulationResponse = query_reverse_simulation(\n        deps.as_ref(),\n        Asset {\n            amount: expected_return_amount,\n            info: AssetInfo::NativeToken {\n                denom: \"uusd\".to_string(),\n            },\n        },\n    )\n    .unwrap();\n    assert!(\n        (offer_amount.u128() as i128 - reverse_simulation_res.offer_amount.u128() as i128).abs()\n            \u003c 3i128\n    );\n    assert!(\n        (expected_commission_amount.u128() as i128\n            - reverse_simulation_res.commission_amount.u128() as i128)\n            .abs()\n            \u003c 3i128\n    );\n    assert!(\n        (expected_spread_amount.u128() as i128\n            - reverse_simulation_res.spread_amount.u128() as i128)\n            .abs()\n            \u003c 3i128\n    );\n\n    assert_eq!(\n        res.attributes,\n        vec![\n            attr(\"action\", \"swap\"),\n            attr(\"sender\", \"addr0000\"),\n            attr(\"receiver\", \"addr0000\"),\n            attr(\"offer_asset\", \"asset0000\"),\n            attr(\"ask_asset\", \"uusd\"),\n            attr(\"offer_amount\", offer_amount.to_string()),\n            attr(\"return_amount\", expected_return_amount.to_string()),\n            attr(\"spread_amount\", expected_spread_amount.to_string()),\n            attr(\"commission_amount\", expected_commission_amount.to_string()),\n        ]\n    );\n\n    assert_eq!(\n        \u0026SubMsg::new(CosmosMsg::Bank(BankMsg::Send {\n            to_address: \"addr0000\".to_string(),\n            amount: vec![Coin {\n                denom: \"uusd\".to_string(),\n                amount: expected_return_amount\n            }],\n        })),\n        msg_transfer,\n    );\n\n    // failed due to non asset token contract try to execute sell\n    let msg = ExecuteMsg::Receive(Cw20ReceiveMsg {\n        sender: \"addr0000\".to_string(),\n        amount: offer_amount,\n        msg: to_binary(\u0026Cw20HookMsg::Swap {\n            belief_price: None,\n            max_spread: None,\n            to: None,\n        })\n        .unwrap(),\n    });\n    let env = mock_env();\n    let info = mock_info(\"liquidity0000\", \u0026[]);\n    let res = execute(deps.as_mut(), env, info, msg).unwrap_err();\n    match res {\n        ContractError::Unauthorized {} =\u003e (),\n        _ =\u003e panic!(\"DO NOT ENTER HERE\"),\n    }\n}\n\n#[test]\nfn test_max_spread() {\n    let offer_asset_info = AssetInfo::NativeToken {\n        denom: \"offer_asset\".to_string(),\n    };\n    let ask_asset_info = AssetInfo::NativeToken {\n        denom: \"ask_asset_info\".to_string(),\n    };\n\n    assert_max_spread(\n        Some(Decimal::from_ratio(1200u128, 1u128)),\n        Some(Decimal::percent(1)),\n        Asset {\n            info: offer_asset_info.clone(),\n            amount: Uint128::from(1200000000u128),\n        },\n        Asset {\n            info: ask_asset_info.clone(),\n            amount: Uint128::from(989999u128),\n        },\n        Uint128::zero(),\n        6u8,\n        6u8,\n    )\n    .unwrap_err();\n\n    assert_max_spread(\n        Some(Decimal::from_ratio(1200u128, 1u128)),\n        Some(Decimal::percent(1)),\n        Asset {\n            info: offer_asset_info.clone(),\n            amount: Uint128::from(1200000000u128),\n        },\n        Asset {\n            info: ask_asset_info.clone(),\n            amount: Uint128::from(990000u128),\n        },\n        Uint128::zero(),\n        6u8,\n        6u8,\n    )\n    .unwrap();\n\n    assert_max_spread(\n        None,\n        Some(Decimal::percent(1)),\n        Asset {\n            info: offer_asset_info.clone(),\n            amount: Uint128::zero(),\n        },\n        Asset {\n            info: ask_asset_info.clone(),\n            amount: Uint128::from(989999u128),\n        },\n        Uint128::from(10001u128),\n        6u8,\n        6u8,\n    )\n    .unwrap_err();\n\n    assert_max_spread(\n        None,\n        Some(Decimal::percent(1)),\n        Asset {\n            info: offer_asset_info,\n            amount: Uint128::zero(),\n        },\n        Asset {\n            info: ask_asset_info,\n            amount: Uint128::from(990000u128),\n        },\n        Uint128::from(10000u128),\n        6u8,\n        6u8,\n    )\n    .unwrap();\n}\n\n#[test]\nfn test_max_spread_with_diff_decimal() {\n    let token_addr = \"ask_asset_info\".to_string();\n\n    let mut deps = mock_dependencies(\u0026[]);\n    deps.querier.with_token_balances(\u0026[(\n        \u0026token_addr,\n        \u0026[(\n            \u0026MOCK_CONTRACT_ADDR.to_string(),\n            \u0026Uint128::from(10000000000u64),\n        )],\n    )]);\n    let offer_asset_info = AssetInfo::NativeToken {\n        denom: \"offer_asset\".to_string(),\n    };\n    let ask_asset_info = AssetInfo::Token {\n        contract_addr: token_addr.to_string(),\n    };\n\n    assert_max_spread(\n        Some(Decimal::from_ratio(1200u128, 1u128)),\n        Some(Decimal::percent(1)),\n        Asset {\n            info: offer_asset_info.clone(),\n            amount: Uint128::from(1200000000u128),\n        },\n        Asset {\n            info: ask_asset_info.clone(),\n            amount: Uint128::from(100000000u128),\n        },\n        Uint128::zero(),\n        6u8,\n        8u8,\n    )\n    .unwrap();\n\n    assert_max_spread(\n        Some(Decimal::from_ratio(1200u128, 1u128)),\n        Some(Decimal::percent(1)),\n        Asset {\n            info: offer_asset_info,\n            amount: Uint128::from(1200000000u128),\n        },\n        Asset {\n            info: ask_asset_info,\n            amount: Uint128::from(98999999u128),\n        },\n        Uint128::zero(),\n        6u8,\n        8u8,\n    )\n    .unwrap_err();\n\n    let offer_asset_info = AssetInfo::Token {\n        contract_addr: token_addr,\n    };\n    let ask_asset_info = AssetInfo::NativeToken {\n        denom: \"offer_asset\".to_string(),\n    };\n\n    assert_max_spread(\n        Some(Decimal::from_ratio(1200u128, 1u128)),\n        Some(Decimal::percent(1)),\n        Asset {\n            info: offer_asset_info.clone(),\n            amount: Uint128::from(120000000000u128),\n        },\n        Asset {\n            info: ask_asset_info.clone(),\n            amount: Uint128::from(1000000u128),\n        },\n        Uint128::zero(),\n        8u8,\n        6u8,\n    )\n    .unwrap();\n\n    assert_max_spread(\n        Some(Decimal::from_ratio(1200u128, 1u128)),\n        Some(Decimal::percent(1)),\n        Asset {\n            info: offer_asset_info,\n            amount: Uint128::from(120000000000u128),\n        },\n        Asset {\n            info: ask_asset_info,\n            amount: Uint128::from(989999u128),\n        },\n        Uint128::zero(),\n        8u8,\n        6u8,\n    )\n    .unwrap_err();\n}\n\n#[test]\nfn test_query_pool() {\n    let total_share_amount = Uint128::from(111u128);\n    let asset_0_amount = Uint128::from(222u128);\n    let asset_1_amount = Uint128::from(333u128);\n    let mut deps = mock_dependencies(\u0026[Coin {\n        denom: \"uusd\".to_string(),\n        amount: asset_0_amount,\n    }]);\n\n    deps.querier.with_token_balances(\u0026[\n        (\n            \u0026\"asset0000\".to_string(),\n            \u0026[(\u0026MOCK_CONTRACT_ADDR.to_string(), \u0026asset_1_amount)],\n        ),\n        (\n            \u0026\"liquidity0000\".to_string(),\n            \u0026[(\u0026MOCK_CONTRACT_ADDR.to_string(), \u0026total_share_amount)],\n        ),\n    ]);\n\n    let msg = InstantiateMsg {\n        asset_infos: [\n            AssetInfo::NativeToken {\n                denom: \"uusd\".to_string(),\n            },\n            AssetInfo::Token {\n                contract_addr: \"asset0000\".to_string(),\n            },\n        ],\n        token_code_id: 10u64,\n        asset_decimals: [6u8, 8u8],\n        requirements: CreatePairRequirements {\n            whitelist: vec![Addr::unchecked(\"addr0000\")],\n            first_asset_minimum: Uint128::zero(),\n            second_asset_minimum: Uint128::zero(),\n        },\n    };\n\n    let env = mock_env();\n    let info = mock_info(\"addr0000\", \u0026[]);\n    // we can just call .unwrap() to assert this was a success\n    let _res = instantiate(deps.as_mut(), env, info, msg).unwrap();\n\n    // store liquidity token\n    let reply_msg = Reply {\n        id: 1,\n        result: SubMsgResult::Ok(SubMsgResponse {\n            events: vec![],\n            data: Some(\n                vec![\n                    10, 13, 108, 105, 113, 117, 105, 100, 105, 116, 121, 48, 48, 48, 48,\n                ]\n                .into(),\n            ),\n        }),\n    };\n\n    let _res = reply(deps.as_mut(), mock_env(), reply_msg).unwrap();\n\n    let res: PoolResponse = query_pool(deps.as_ref()).unwrap();\n\n    assert_eq!(\n        res.assets,\n        [\n            Asset {\n                info: AssetInfo::NativeToken {\n                    denom: \"uusd\".to_string(),\n                },\n                amount: asset_0_amount\n            },\n            Asset {\n                info: AssetInfo::Token {\n                    contract_addr: \"asset0000\".to_string(),\n                },\n                amount: asset_1_amount\n            }\n        ]\n    );\n    assert_eq!(res.total_share, total_share_amount);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","haitran","AURA-NETWORK","smart-contracts-halotrade-zone","contracts","halo-router","src","contract.rs"],"content":"#[cfg(not(feature = \"library\"))]\nuse cosmwasm_std::entry_point;\n\nuse cosmwasm_std::{\n    from_binary, to_binary, Addr, Api, Binary, CosmosMsg, Deps, DepsMut, Env, MessageInfo,\n    Response, StdError, StdResult, Uint128, WasmMsg,\n};\nuse cw2::set_contract_version;\n\nuse crate::operations::execute_swap_operation;\nuse crate::state::{Config, CONFIG};\n\nuse cw20::Cw20ReceiveMsg;\nuse std::collections::HashMap;\nuse haloswap::asset::{Asset, AssetInfo, PairInfo};\nuse haloswap::pair::SimulationResponse;\nuse haloswap::querier::{query_pair_info, reverse_simulate, simulate};\nuse haloswap::router::{\n    ConfigResponse, Cw20HookMsg, ExecuteMsg, InstantiateMsg, MigrateMsg, QueryMsg,\n    SimulateSwapOperationsResponse, SwapOperation,\n};\n\n// version info for migration info\nconst CONTRACT_NAME: \u0026str = \"crates.io:halo-router\";\nconst CONTRACT_VERSION: \u0026str = env!(\"CARGO_PKG_VERSION\");\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn instantiate(\n    deps: DepsMut,\n    _env: Env,\n    _info: MessageInfo,\n    msg: InstantiateMsg,\n) -\u003e StdResult\u003cResponse\u003e {\n    set_contract_version(deps.storage, CONTRACT_NAME, CONTRACT_VERSION)?;\n\n    CONFIG.save(\n        deps.storage,\n        \u0026Config {\n            halo_factory: deps.api.addr_canonicalize(\u0026msg.halo_factory)?,\n        },\n    )?;\n\n    Ok(Response::default())\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn execute(deps: DepsMut, env: Env, info: MessageInfo, msg: ExecuteMsg) -\u003e StdResult\u003cResponse\u003e {\n    match msg {\n        ExecuteMsg::Receive(msg) =\u003e receive_cw20(deps, env, info, msg),\n        ExecuteMsg::ExecuteSwapOperations {\n            operations,\n            minimum_receive,\n            to,\n        } =\u003e {\n            let api = deps.api;\n            execute_swap_operations(\n                deps,\n                env,\n                info.sender,\n                operations,\n                minimum_receive,\n                optional_addr_validate(api, to)?,\n            )\n        }\n        ExecuteMsg::ExecuteSwapOperation { operation, to } =\u003e {\n            let api = deps.api;\n            execute_swap_operation(\n                deps,\n                env,\n                info,\n                operation,\n                optional_addr_validate(api, to)?.map(|v| v.to_string()),\n            )\n        }\n        ExecuteMsg::AssertMinimumReceive {\n            asset_info,\n            prev_balance,\n            minimum_receive,\n            receiver,\n        } =\u003e assert_minium_receive(\n            deps.as_ref(),\n            asset_info,\n            prev_balance,\n            minimum_receive,\n            deps.api.addr_validate(\u0026receiver)?,\n        ),\n    }\n}\n\nfn optional_addr_validate(api: \u0026dyn Api, addr: Option\u003cString\u003e) -\u003e StdResult\u003cOption\u003cAddr\u003e\u003e {\n    let addr = if let Some(addr) = addr {\n        Some(api.addr_validate(\u0026addr)?)\n    } else {\n        None\n    };\n\n    Ok(addr)\n}\n\npub fn receive_cw20(\n    deps: DepsMut,\n    env: Env,\n    _info: MessageInfo,\n    cw20_msg: Cw20ReceiveMsg,\n) -\u003e StdResult\u003cResponse\u003e {\n    let sender = deps.api.addr_validate(\u0026cw20_msg.sender)?;\n    match from_binary(\u0026cw20_msg.msg)? {\n        Cw20HookMsg::ExecuteSwapOperations {\n            operations,\n            minimum_receive,\n            to,\n        } =\u003e {\n            let api = deps.api;\n            execute_swap_operations(\n                deps,\n                env,\n                sender,\n                operations,\n                minimum_receive,\n                optional_addr_validate(api, to)?,\n            )\n        }\n    }\n}\n\npub fn execute_swap_operations(\n    deps: DepsMut,\n    env: Env,\n    sender: Addr,\n    operations: Vec\u003cSwapOperation\u003e,\n    minimum_receive: Option\u003cUint128\u003e,\n    to: Option\u003cAddr\u003e,\n) -\u003e StdResult\u003cResponse\u003e {\n    let operations_len = operations.len();\n    if operations_len == 0 {\n        return Err(StdError::generic_err(\"must provide operations\"));\n    }\n\n    // Assert the operations are properly set\n    assert_operations(\u0026operations)?;\n\n    let to = if let Some(to) = to { to } else { sender };\n    let target_asset_info = operations.last().unwrap().get_target_asset_info();\n\n    let mut operation_index = 0;\n    let mut messages: Vec\u003cCosmosMsg\u003e = operations\n        .into_iter()\n        .map(|op| {\n            operation_index += 1;\n            Ok(CosmosMsg::Wasm(WasmMsg::Execute {\n                contract_addr: env.contract.address.to_string(),\n                funds: vec![],\n                msg: to_binary(\u0026ExecuteMsg::ExecuteSwapOperation {\n                    operation: op,\n                    to: if operation_index == operations_len {\n                        Some(to.to_string())\n                    } else {\n                        None\n                    },\n                })?,\n            }))\n        })\n        .collect::\u003cStdResult\u003cVec\u003cCosmosMsg\u003e\u003e\u003e()?;\n\n    // Execute minimum amount assertion\n    if let Some(minimum_receive) = minimum_receive {\n        let receiver_balance = target_asset_info.query_pool(\u0026deps.querier, deps.api, to.clone())?;\n\n        messages.push(CosmosMsg::Wasm(WasmMsg::Execute {\n            contract_addr: env.contract.address.to_string(),\n            funds: vec![],\n            msg: to_binary(\u0026ExecuteMsg::AssertMinimumReceive {\n                asset_info: target_asset_info,\n                prev_balance: receiver_balance,\n                minimum_receive,\n                receiver: to.to_string(),\n            })?,\n        }))\n    }\n\n    Ok(Response::new().add_messages(messages))\n}\n\nfn assert_minium_receive(\n    deps: Deps,\n    asset_info: AssetInfo,\n    prev_balance: Uint128,\n    minium_receive: Uint128,\n    receiver: Addr,\n) -\u003e StdResult\u003cResponse\u003e {\n    let receiver_balance = asset_info.query_pool(\u0026deps.querier, deps.api, receiver)?;\n    let swap_amount = receiver_balance.checked_sub(prev_balance)?;\n\n    if swap_amount \u003c minium_receive {\n        return Err(StdError::generic_err(format!(\n            \"assertion failed; minimum receive amount: {}, swap amount: {}\",\n            minium_receive, swap_amount\n        )));\n    }\n\n    Ok(Response::default())\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn query(deps: Deps, _env: Env, msg: QueryMsg) -\u003e StdResult\u003cBinary\u003e {\n    match msg {\n        QueryMsg::Config {} =\u003e to_binary(\u0026query_config(deps)?),\n        QueryMsg::SimulateSwapOperations {\n            offer_amount,\n            operations,\n        } =\u003e to_binary(\u0026simulate_swap_operations(deps, offer_amount, operations)?),\n        QueryMsg::ReverseSimulateSwapOperations {\n            ask_amount,\n            operations,\n        } =\u003e to_binary(\u0026reverse_simulate_swap_operations(\n            deps, ask_amount, operations,\n        )?),\n    }\n}\n\npub fn query_config(deps: Deps) -\u003e StdResult\u003cConfigResponse\u003e {\n    let state = CONFIG.load(deps.storage)?;\n    let resp = ConfigResponse {\n        halo_factory: deps\n            .api\n            .addr_humanize(\u0026state.halo_factory)?\n            .to_string(),\n    };\n\n    Ok(resp)\n}\n\nfn simulate_swap_operations(\n    deps: Deps,\n    offer_amount: Uint128,\n    operations: Vec\u003cSwapOperation\u003e,\n) -\u003e StdResult\u003cSimulateSwapOperationsResponse\u003e {\n    let config: Config = CONFIG.load(deps.storage)?;\n    let halo_factory = deps.api.addr_humanize(\u0026config.halo_factory)?;\n\n    let operations_len = operations.len();\n    if operations_len == 0 {\n        return Err(StdError::generic_err(\"must provide operations\"));\n    }\n\n    let mut offer_amount = offer_amount;\n    for operation in operations.into_iter() {\n        match operation {\n            SwapOperation::HaloSwap {\n                offer_asset_info,\n                ask_asset_info,\n            } =\u003e {\n                let pair_info: PairInfo = query_pair_info(\n                    \u0026deps.querier,\n                    halo_factory.clone(),\n                    \u0026[offer_asset_info.clone(), ask_asset_info.clone()],\n                )?;\n\n                let res: SimulationResponse = simulate(\n                    \u0026deps.querier,\n                    Addr::unchecked(pair_info.contract_addr),\n                    \u0026Asset {\n                        info: offer_asset_info,\n                        amount: offer_amount,\n                    },\n                )?;\n\n                offer_amount = res.return_amount;\n            }\n        }\n    }\n\n    Ok(SimulateSwapOperationsResponse {\n        amount: offer_amount,\n    })\n}\n\nfn reverse_simulate_swap_operations(\n    deps: Deps,\n    ask_amount: Uint128,\n    operations: Vec\u003cSwapOperation\u003e,\n) -\u003e StdResult\u003cSimulateSwapOperationsResponse\u003e {\n    let config: Config = CONFIG.load(deps.storage)?;\n\n    let operations_len = operations.len();\n    if operations_len == 0 {\n        return Err(StdError::generic_err(\"must provide operations\"));\n    }\n\n    let mut ask_amount = ask_amount;\n    for operation in operations.into_iter().rev() {\n        ask_amount = match operation {\n            SwapOperation::HaloSwap {\n                offer_asset_info,\n                ask_asset_info,\n            } =\u003e {\n                let halo_factory = deps.api.addr_humanize(\u0026config.halo_factory)?;\n\n                reverse_simulate_return_amount(\n                    deps,\n                    halo_factory,\n                    ask_amount,\n                    offer_asset_info,\n                    ask_asset_info,\n                )\n                .unwrap()\n            }\n        }\n    }\n\n    Ok(SimulateSwapOperationsResponse { amount: ask_amount })\n}\n\nfn reverse_simulate_return_amount(\n    deps: Deps,\n    factory: Addr,\n    ask_amount: Uint128,\n    offer_asset_info: AssetInfo,\n    ask_asset_info: AssetInfo,\n) -\u003e StdResult\u003cUint128\u003e {\n    let pair_info: PairInfo = query_pair_info(\n        \u0026deps.querier,\n        factory,\n        \u0026[offer_asset_info, ask_asset_info.clone()],\n    )?;\n\n    let res = reverse_simulate(\n        \u0026deps.querier,\n        Addr::unchecked(pair_info.contract_addr),\n        \u0026Asset {\n            amount: ask_amount,\n            info: ask_asset_info,\n        },\n    )?;\n\n    Ok(res.offer_amount)\n}\n\nfn assert_operations(operations: \u0026[SwapOperation]) -\u003e StdResult\u003c()\u003e {\n    let mut ask_asset_map: HashMap\u003cString, bool\u003e = HashMap::new();\n    for operation in operations.iter() {\n        let (offer_asset, ask_asset) = match operation {\n            SwapOperation::HaloSwap {\n                offer_asset_info,\n                ask_asset_info,\n            } =\u003e (offer_asset_info.clone(), ask_asset_info.clone()),\n        };\n\n        ask_asset_map.remove(\u0026offer_asset.to_string());\n        ask_asset_map.insert(ask_asset.to_string(), true);\n    }\n\n    if ask_asset_map.keys().len() != 1 {\n        return Err(StdError::generic_err(\n            \"invalid operations; multiple output token\",\n        ));\n    }\n\n    Ok(())\n}\n\n#[test]\nfn test_invalid_operations() {\n    // empty error\n    assert!(assert_operations(\u0026[]).is_err());\n\n    // uluna output\n    assert!(assert_operations(\u0026[\n        SwapOperation::HaloSwap {\n            offer_asset_info: AssetInfo::NativeToken {\n                denom: \"ukrw\".to_string(),\n            },\n            ask_asset_info: AssetInfo::Token {\n                contract_addr: \"asset0001\".to_string(),\n            },\n        },\n        SwapOperation::HaloSwap {\n            offer_asset_info: AssetInfo::Token {\n                contract_addr: \"asset0001\".to_string(),\n            },\n            ask_asset_info: AssetInfo::NativeToken {\n                denom: \"uluna\".to_string(),\n            },\n        }\n    ])\n    .is_ok());\n\n    // asset0002 output\n    assert!(assert_operations(\u0026[\n        SwapOperation::HaloSwap {\n            offer_asset_info: AssetInfo::NativeToken {\n                denom: \"ukrw\".to_string(),\n            },\n            ask_asset_info: AssetInfo::Token {\n                contract_addr: \"asset0001\".to_string(),\n            },\n        },\n        SwapOperation::HaloSwap {\n            offer_asset_info: AssetInfo::Token {\n                contract_addr: \"asset0001\".to_string(),\n            },\n            ask_asset_info: AssetInfo::NativeToken {\n                denom: \"uluna\".to_string(),\n            },\n        },\n        SwapOperation::HaloSwap {\n            offer_asset_info: AssetInfo::NativeToken {\n                denom: \"uluna\".to_string(),\n            },\n            ask_asset_info: AssetInfo::Token {\n                contract_addr: \"asset0002\".to_string(),\n            },\n        },\n    ])\n    .is_ok());\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn migrate(deps: DepsMut, _env: Env, _msg: MigrateMsg) -\u003e StdResult\u003cResponse\u003e {\n    set_contract_version(deps.storage, CONTRACT_NAME, CONTRACT_VERSION)?;\n    Ok(Response::default())\n}\n","traces":[{"line":34,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":250,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":260,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":264,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":268,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":273,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":274,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":278,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":283,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":285,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":286,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":287,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":290,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":291,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":292,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":293,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":294,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":295,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":297,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":299,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":300,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":302,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":303,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":304,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":306,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":311,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":314,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":322,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":323,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":324,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":328,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":329,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":330,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":331,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":332,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":336,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":339,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":340,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":341,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":342,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":343,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":344,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":345,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":346,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":349,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":350,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":353,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":354,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":355,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":359,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":420,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":421,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":171,"coverable":175},{"path":["/","Users","haitran","AURA-NETWORK","smart-contracts-halotrade-zone","contracts","halo-router","src","lib.rs"],"content":"pub mod contract;\npub mod state;\n\nmod operations;\n\n#[cfg(test)]\nmod testing;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","haitran","AURA-NETWORK","smart-contracts-halotrade-zone","contracts","halo-router","src","operations.rs"],"content":"use cosmwasm_std::{\n    to_binary, Addr, Coin, CosmosMsg, Decimal, Deps, DepsMut, Env, MessageInfo, Response, StdError,\n    StdResult, WasmMsg,\n};\n\nuse crate::state::{Config, CONFIG};\n\nuse cw20::Cw20ExecuteMsg;\nuse haloswap::asset::{Asset, AssetInfo, PairInfo};\nuse haloswap::pair::Cw20HookMsg as PairHookMsg;\nuse haloswap::querier::{query_balance, query_pair_info, query_token_balance};\nuse haloswap::router::SwapOperation;\n\n/// Execute swap operation\n/// swap all offer asset to ask asset\npub fn execute_swap_operation(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    operation: SwapOperation,\n    to: Option\u003cString\u003e,\n) -\u003e StdResult\u003cResponse\u003e {\n    if env.contract.address != info.sender {\n        return Err(StdError::generic_err(\"unauthorized\"));\n    }\n\n    let messages: Vec\u003cCosmosMsg\u003e = match operation {\n        SwapOperation::HaloSwap {\n            offer_asset_info,\n            ask_asset_info,\n        } =\u003e {\n            let config: Config = CONFIG.load(deps.as_ref().storage)?;\n            let halo_factory = deps.api.addr_humanize(\u0026config.halo_factory)?;\n            let pair_info: PairInfo = query_pair_info(\n                \u0026deps.querier,\n                halo_factory,\n                \u0026[offer_asset_info.clone(), ask_asset_info],\n            )?;\n\n            let amount = match offer_asset_info.clone() {\n                AssetInfo::NativeToken { denom } =\u003e {\n                    query_balance(\u0026deps.querier, env.contract.address, denom)?\n                }\n                AssetInfo::Token { contract_addr } =\u003e query_token_balance(\n                    \u0026deps.querier,\n                    deps.api.addr_validate(contract_addr.as_str())?,\n                    env.contract.address,\n                )?,\n            };\n            let offer_asset: Asset = Asset {\n                info: offer_asset_info,\n                amount,\n            };\n\n            vec![asset_into_swap_msg(\n                deps.as_ref(),\n                Addr::unchecked(pair_info.contract_addr),\n                offer_asset,\n                None,\n                to,\n            )?]\n        }\n    };\n\n    Ok(Response::new().add_messages(messages))\n}\n\npub fn asset_into_swap_msg(\n    _deps: Deps,\n    pair_contract: Addr,\n    offer_asset: Asset,\n    max_spread: Option\u003cDecimal\u003e,\n    to: Option\u003cString\u003e,\n) -\u003e StdResult\u003cCosmosMsg\u003e {\n    match offer_asset.info.clone() {\n        AssetInfo::NativeToken { denom } =\u003e Ok(CosmosMsg::Wasm(WasmMsg::Execute {\n            contract_addr: pair_contract.to_string(),\n            funds: vec![Coin {\n                denom,\n                amount: offer_asset.amount,\n            }],\n            msg: to_binary(\u0026PairHookMsg::Swap {\n                belief_price: None,\n                max_spread,\n                to,\n            })?,\n        })),\n        AssetInfo::Token { contract_addr } =\u003e Ok(CosmosMsg::Wasm(WasmMsg::Execute {\n            contract_addr,\n            funds: vec![],\n            msg: to_binary(\u0026Cw20ExecuteMsg::Send {\n                contract: pair_contract.to_string(),\n                amount: offer_asset.amount,\n                msg: to_binary(\u0026PairHookMsg::Swap {\n                    belief_price: None,\n                    max_spread,\n                    to,\n                })?,\n            })?,\n        })),\n    }\n}\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":2},"fn_name":null}],"covered":46,"coverable":46},{"path":["/","Users","haitran","AURA-NETWORK","smart-contracts-halotrade-zone","contracts","halo-router","src","state.rs"],"content":"use schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\n\nuse cosmwasm_std::CanonicalAddr;\nuse cw_storage_plus::Item;\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\npub struct Config {\n    pub halo_factory: CanonicalAddr,\n}\n\npub const CONFIG: Item\u003cConfig\u003e = Item::new(\"config\");\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","haitran","AURA-NETWORK","smart-contracts-halotrade-zone","contracts","halo-router","src","testing","integration_test.rs"],"content":"","traces":[],"covered":0,"coverable":0},{"path":["/","Users","haitran","AURA-NETWORK","smart-contracts-halotrade-zone","contracts","halo-router","src","testing","mod.rs"],"content":"mod tests;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","haitran","AURA-NETWORK","smart-contracts-halotrade-zone","contracts","halo-router","src","testing","tests.rs"],"content":"use cosmwasm_std::testing::{mock_env, mock_info, MOCK_CONTRACT_ADDR};\nuse cosmwasm_std::{\n    coin, from_binary, to_binary, Addr, Coin, CosmosMsg, StdError, SubMsg, Uint128, WasmMsg,\n};\n\nuse crate::contract::{execute, instantiate, query};\nuse crate::operations::asset_into_swap_msg;\nuse haloswap::mock_querier::mock_dependencies;\n\nuse cw20::{Cw20ExecuteMsg, Cw20ReceiveMsg};\nuse haloswap::asset::{Asset, AssetInfo, PairInfo, CreatePairRequirements};\nuse haloswap::pair::Cw20HookMsg as PairHookMsg;\nuse haloswap::router::{\n    ConfigResponse, Cw20HookMsg, ExecuteMsg, InstantiateMsg, QueryMsg,\n    SimulateSwapOperationsResponse, SwapOperation,\n};\n\n#[test]\nfn proper_initialization() {\n    let mut deps = mock_dependencies(\u0026[]);\n\n    let msg = InstantiateMsg {\n        halo_factory: \"halofactory\".to_string(),\n    };\n\n    let info = mock_info(\"addr0000\", \u0026[]);\n\n    // we can just call .unwrap() to assert this was a success\n    let _res = instantiate(deps.as_mut(), mock_env(), info, msg).unwrap();\n\n    // it worked, let's query the state\n    let config: ConfigResponse =\n        from_binary(\u0026query(deps.as_ref(), mock_env(), QueryMsg::Config {}).unwrap()).unwrap();\n    assert_eq!(\"halofactory\", config.halo_factory.as_str());\n}\n\n#[test]\nfn execute_swap_operations() {\n    let mut deps = mock_dependencies(\u0026[]);\n    deps.querier.with_token_balances(\u0026[(\n        \u0026\"asset0002\".to_string(),\n        \u0026[(\u0026MOCK_CONTRACT_ADDR.to_string(), \u0026Uint128::from(1000000u128))],\n    )]);\n\n    let msg = InstantiateMsg {\n        halo_factory: \"halofactory\".to_string(),\n    };\n\n    let info = mock_info(\"addr0000\", \u0026[]);\n\n    // we can just call .unwrap() to assert this was a success\n    let _res = instantiate(deps.as_mut(), mock_env(), info, msg).unwrap();\n\n    let msg = ExecuteMsg::ExecuteSwapOperations {\n        operations: vec![],\n        minimum_receive: None,\n        to: None,\n    };\n\n    let info = mock_info(\"addr0000\", \u0026[]);\n    let res = execute(deps.as_mut(), mock_env(), info, msg);\n    match res {\n        Err(StdError::GenericErr { msg, .. }) =\u003e assert_eq!(msg, \"must provide operations\"),\n        _ =\u003e panic!(\"DO NOT ENTER HERE\"),\n    }\n\n    let msg = ExecuteMsg::ExecuteSwapOperations {\n        operations: vec![\n            SwapOperation::HaloSwap {\n                offer_asset_info: AssetInfo::NativeToken {\n                    denom: \"ukrw\".to_string(),\n                },\n                ask_asset_info: AssetInfo::Token {\n                    contract_addr: \"asset0001\".to_string(),\n                },\n            },\n            SwapOperation::HaloSwap {\n                offer_asset_info: AssetInfo::Token {\n                    contract_addr: \"asset0001\".to_string(),\n                },\n                ask_asset_info: AssetInfo::NativeToken {\n                    denom: \"uluna\".to_string(),\n                },\n            },\n            SwapOperation::HaloSwap {\n                offer_asset_info: AssetInfo::NativeToken {\n                    denom: \"uluna\".to_string(),\n                },\n                ask_asset_info: AssetInfo::Token {\n                    contract_addr: \"asset0002\".to_string(),\n                },\n            },\n        ],\n        minimum_receive: Some(Uint128::from(1000000u128)),\n        to: None,\n    };\n\n    let info = mock_info(\"addr0000\", \u0026[]);\n    let res = execute(deps.as_mut(), mock_env(), info, msg).unwrap();\n    assert_eq!(\n        res.messages,\n        vec![\n            SubMsg::new(CosmosMsg::Wasm(WasmMsg::Execute {\n                contract_addr: MOCK_CONTRACT_ADDR.to_string(),\n                funds: vec![],\n                msg: to_binary(\u0026ExecuteMsg::ExecuteSwapOperation {\n                    operation: SwapOperation::HaloSwap {\n                        offer_asset_info: AssetInfo::NativeToken {\n                            denom: \"ukrw\".to_string(),\n                        },\n                        ask_asset_info: AssetInfo::Token {\n                            contract_addr: \"asset0001\".to_string(),\n                        },\n                    },\n                    to: None,\n                })\n                .unwrap(),\n            })),\n            SubMsg::new(CosmosMsg::Wasm(WasmMsg::Execute {\n                contract_addr: MOCK_CONTRACT_ADDR.to_string(),\n                funds: vec![],\n                msg: to_binary(\u0026ExecuteMsg::ExecuteSwapOperation {\n                    operation: SwapOperation::HaloSwap {\n                        offer_asset_info: AssetInfo::Token {\n                            contract_addr: \"asset0001\".to_string(),\n                        },\n                        ask_asset_info: AssetInfo::NativeToken {\n                            denom: \"uluna\".to_string(),\n                        },\n                    },\n                    to: None,\n                })\n                .unwrap(),\n            })),\n            SubMsg::new(CosmosMsg::Wasm(WasmMsg::Execute {\n                contract_addr: MOCK_CONTRACT_ADDR.to_string(),\n                funds: vec![],\n                msg: to_binary(\u0026ExecuteMsg::ExecuteSwapOperation {\n                    operation: SwapOperation::HaloSwap {\n                        offer_asset_info: AssetInfo::NativeToken {\n                            denom: \"uluna\".to_string(),\n                        },\n                        ask_asset_info: AssetInfo::Token {\n                            contract_addr: \"asset0002\".to_string(),\n                        },\n                    },\n                    to: Some(\"addr0000\".to_string()),\n                })\n                .unwrap(),\n            })),\n            SubMsg::new(CosmosMsg::Wasm(WasmMsg::Execute {\n                contract_addr: MOCK_CONTRACT_ADDR.to_string(),\n                funds: vec![],\n                msg: to_binary(\u0026ExecuteMsg::AssertMinimumReceive {\n                    asset_info: AssetInfo::Token {\n                        contract_addr: \"asset0002\".to_string(),\n                    },\n                    prev_balance: Uint128::zero(),\n                    minimum_receive: Uint128::from(1000000u128),\n                    receiver: \"addr0000\".to_string(),\n                })\n                .unwrap(),\n            })),\n        ]\n    );\n\n    let msg = ExecuteMsg::Receive(Cw20ReceiveMsg {\n        sender: \"addr0000\".to_string(),\n        amount: Uint128::from(1000000u128),\n        msg: to_binary(\u0026Cw20HookMsg::ExecuteSwapOperations {\n            operations: vec![\n                SwapOperation::HaloSwap {\n                    offer_asset_info: AssetInfo::NativeToken {\n                        denom: \"ukrw\".to_string(),\n                    },\n                    ask_asset_info: AssetInfo::Token {\n                        contract_addr: \"asset0001\".to_string(),\n                    },\n                },\n                SwapOperation::HaloSwap {\n                    offer_asset_info: AssetInfo::Token {\n                        contract_addr: \"asset0001\".to_string(),\n                    },\n                    ask_asset_info: AssetInfo::NativeToken {\n                        denom: \"uluna\".to_string(),\n                    },\n                },\n                SwapOperation::HaloSwap {\n                    offer_asset_info: AssetInfo::NativeToken {\n                        denom: \"uluna\".to_string(),\n                    },\n                    ask_asset_info: AssetInfo::Token {\n                        contract_addr: \"asset0002\".to_string(),\n                    },\n                },\n            ],\n            minimum_receive: None,\n            to: Some(\"addr0002\".to_string()),\n        })\n        .unwrap(),\n    });\n\n    let info = mock_info(\"asset0000\", \u0026[]);\n    let res = execute(deps.as_mut(), mock_env(), info, msg).unwrap();\n    assert_eq!(\n        res.messages,\n        vec![\n            SubMsg::new(CosmosMsg::Wasm(WasmMsg::Execute {\n                contract_addr: MOCK_CONTRACT_ADDR.to_string(),\n                funds: vec![],\n                msg: to_binary(\u0026ExecuteMsg::ExecuteSwapOperation {\n                    operation: SwapOperation::HaloSwap {\n                        offer_asset_info: AssetInfo::NativeToken {\n                            denom: \"ukrw\".to_string(),\n                        },\n                        ask_asset_info: AssetInfo::Token {\n                            contract_addr: \"asset0001\".to_string(),\n                        },\n                    },\n                    to: None,\n                })\n                .unwrap(),\n            })),\n            SubMsg::new(CosmosMsg::Wasm(WasmMsg::Execute {\n                contract_addr: MOCK_CONTRACT_ADDR.to_string(),\n                funds: vec![],\n                msg: to_binary(\u0026ExecuteMsg::ExecuteSwapOperation {\n                    operation: SwapOperation::HaloSwap {\n                        offer_asset_info: AssetInfo::Token {\n                            contract_addr: \"asset0001\".to_string(),\n                        },\n                        ask_asset_info: AssetInfo::NativeToken {\n                            denom: \"uluna\".to_string(),\n                        },\n                    },\n                    to: None,\n                })\n                .unwrap(),\n            })),\n            SubMsg::new(CosmosMsg::Wasm(WasmMsg::Execute {\n                contract_addr: MOCK_CONTRACT_ADDR.to_string(),\n                funds: vec![],\n                msg: to_binary(\u0026ExecuteMsg::ExecuteSwapOperation {\n                    operation: SwapOperation::HaloSwap {\n                        offer_asset_info: AssetInfo::NativeToken {\n                            denom: \"uluna\".to_string(),\n                        },\n                        ask_asset_info: AssetInfo::Token {\n                            contract_addr: \"asset0002\".to_string(),\n                        },\n                    },\n                    to: Some(\"addr0002\".to_string()),\n                })\n                .unwrap(),\n            }))\n        ]\n    );\n}\n\n#[test]\nfn execute_swap_operation() {\n    let mut deps = mock_dependencies(\u0026[]);\n    let msg = InstantiateMsg {\n        halo_factory: \"halofactory\".to_string(),\n    };\n\n    let info = mock_info(\"addr0000\", \u0026[]);\n\n    // we can just call .unwrap() to assert this was a success\n    let _res = instantiate(deps.as_mut(), mock_env(), info, msg).unwrap();\n\n    deps.querier.with_halo_factory(\n        \u0026[(\n            \u0026\"uusdasset0000\".to_string(),\n            \u0026PairInfo {\n                asset_infos: [\n                    AssetInfo::NativeToken {\n                        denom: \"uusd\".to_string(),\n                    },\n                    AssetInfo::Token {\n                        contract_addr: \"asset0000\".to_string(),\n                    },\n                ],\n                contract_addr: \"pair0000\".to_string(),\n                liquidity_token: \"liquidity0000\".to_string(),\n                asset_decimals: [6u8, 6u8],\n                requirements: CreatePairRequirements {\n                    whitelist: vec![Addr::unchecked(\"deployer\")],\n                    first_asset_minimum: Uint128::zero(),\n                    second_asset_minimum: Uint128::zero(),\n                },\n            },\n        )],\n        \u0026[(\"uusd\".to_string(), 6u8)],\n    );\n    deps.querier.with_balance(\u0026[(\n        \u0026MOCK_CONTRACT_ADDR.to_string(),\n        [Coin {\n            amount: Uint128::from(1000000u128),\n            denom: \"uusd\".to_string(),\n        }]\n        .to_vec(),\n    )]);\n\n    let msg = ExecuteMsg::ExecuteSwapOperation {\n        operation: SwapOperation::HaloSwap {\n            offer_asset_info: AssetInfo::NativeToken {\n                denom: \"uusd\".to_string(),\n            },\n            ask_asset_info: AssetInfo::Token {\n                contract_addr: \"asset0000\".to_string(),\n            },\n        },\n        to: None,\n    };\n    let info = mock_info(\"addr0000\", \u0026[]);\n    let res = execute(deps.as_mut(), mock_env(), info, msg.clone());\n    match res {\n        Err(StdError::GenericErr { msg, .. }) =\u003e assert_eq!(msg, \"unauthorized\"),\n        _ =\u003e panic!(\"DO NOT ENTER HERE\"),\n    }\n\n    let info = mock_info(MOCK_CONTRACT_ADDR, \u0026[]);\n    let res = execute(deps.as_mut(), mock_env(), info, msg).unwrap();\n    assert_eq!(\n        res.messages,\n        vec![SubMsg::new(\n            asset_into_swap_msg(\n                deps.as_ref(),\n                Addr::unchecked(\"pair0000\"),\n                Asset {\n                    info: AssetInfo::NativeToken {\n                        denom: \"uusd\".to_string(),\n                    },\n                    amount: Uint128::from(1000000u128)\n                },\n                None,\n                None\n            )\n            .unwrap()\n        )],\n    );\n\n    // optional to address\n    // swap_send\n    let msg = ExecuteMsg::ExecuteSwapOperation {\n        operation: SwapOperation::HaloSwap {\n            offer_asset_info: AssetInfo::NativeToken {\n                denom: \"uusd\".to_string(),\n            },\n            ask_asset_info: AssetInfo::Token {\n                contract_addr: \"asset0000\".to_string(),\n            },\n        },\n        to: Some(\"addr0000\".to_string()),\n    };\n    let info = mock_info(MOCK_CONTRACT_ADDR, \u0026[]);\n    let res = execute(deps.as_mut(), mock_env(), info, msg).unwrap();\n    assert_eq!(\n        res.messages,\n        vec![SubMsg::new(\n            asset_into_swap_msg(\n                deps.as_ref(),\n                Addr::unchecked(\"pair0000\"),\n                Asset {\n                    info: AssetInfo::NativeToken {\n                        denom: \"uusd\".to_string(),\n                    },\n                    amount: Uint128::from(1000000u128)\n                },\n                None,\n                Some(\"addr0000\".to_string())\n            )\n            .unwrap()\n        )],\n    );\n    deps.querier.with_halo_factory(\n        \u0026[(\n            \u0026\"assetuusd\".to_string(),\n            \u0026PairInfo {\n                asset_infos: [\n                    AssetInfo::Token {\n                        contract_addr: \"asset\".to_string(),\n                    },\n                    AssetInfo::NativeToken {\n                        denom: \"uusd\".to_string(),\n                    },\n                ],\n                contract_addr: \"pair0000\".to_string(),\n                liquidity_token: \"liquidity0000\".to_string(),\n                asset_decimals: [6u8, 6u8],\n                requirements: CreatePairRequirements {\n                    whitelist: vec![Addr::unchecked(\"deployer\")],\n                    first_asset_minimum: Uint128::zero(),\n                    second_asset_minimum: Uint128::zero(),\n                },\n            },\n        )],\n        \u0026[(\"uusd\".to_string(), 6u8)],\n    );\n    deps.querier.with_token_balances(\u0026[(\n        \u0026\"asset\".to_string(),\n        \u0026[(\u0026MOCK_CONTRACT_ADDR.to_string(), \u0026Uint128::from(1000000u128))],\n    )]);\n\n    let msg = ExecuteMsg::ExecuteSwapOperation {\n        operation: SwapOperation::HaloSwap {\n            offer_asset_info: AssetInfo::Token {\n                contract_addr: \"asset\".to_string(),\n            },\n            ask_asset_info: AssetInfo::NativeToken {\n                denom: \"uusd\".to_string(),\n            },\n        },\n        to: Some(\"addr0000\".to_string()),\n    };\n\n    let info = mock_info(MOCK_CONTRACT_ADDR, \u0026[]);\n    let res = execute(deps.as_mut(), mock_env(), info, msg).unwrap();\n    assert_eq!(\n        res.messages,\n        vec![SubMsg::new(CosmosMsg::Wasm(WasmMsg::Execute {\n            contract_addr: \"asset\".to_string(),\n            funds: vec![],\n            msg: to_binary(\u0026Cw20ExecuteMsg::Send {\n                contract: \"pair0000\".to_string(),\n                amount: Uint128::from(1000000u128),\n                msg: to_binary(\u0026PairHookMsg::Swap {\n                    belief_price: None,\n                    max_spread: None,\n                    to: Some(\"addr0000\".to_string()),\n                })\n                .unwrap()\n            })\n            .unwrap()\n        }))]\n    );\n}\n\n#[test]\nfn query_buy_with_routes() {\n    let mut deps = mock_dependencies(\u0026[]);\n\n    let msg = InstantiateMsg {\n        halo_factory: \"halofactory\".to_string(),\n    };\n\n    let info = mock_info(\"addr0000\", \u0026[]);\n\n    // we can just call .unwrap() to assert this was a success\n    let _res = instantiate(deps.as_mut(), mock_env(), info, msg).unwrap();\n\n    let msg = QueryMsg::SimulateSwapOperations {\n        offer_amount: Uint128::from(1000000u128),\n        operations: vec![\n            SwapOperation::HaloSwap {\n                offer_asset_info: AssetInfo::NativeToken {\n                    denom: \"ukrw\".to_string(),\n                },\n                ask_asset_info: AssetInfo::Token {\n                    contract_addr: \"asset0000\".to_string(),\n                },\n            },\n            SwapOperation::HaloSwap {\n                offer_asset_info: AssetInfo::Token {\n                    contract_addr: \"asset0000\".to_string(),\n                },\n                ask_asset_info: AssetInfo::NativeToken {\n                    denom: \"uluna\".to_string(),\n                },\n            },\n        ],\n    };\n\n    deps.querier.with_halo_factory(\n        \u0026[\n            (\n                \u0026\"ukrwasset0000\".to_string(),\n                \u0026PairInfo {\n                    asset_infos: [\n                        AssetInfo::NativeToken {\n                            denom: \"ukrw\".to_string(),\n                        },\n                        AssetInfo::Token {\n                            contract_addr: \"asset0000\".to_string(),\n                        },\n                    ],\n                    contract_addr: \"pair0000\".to_string(),\n                    liquidity_token: \"liquidity0000\".to_string(),\n                    asset_decimals: [6u8, 6u8],\n                    requirements: CreatePairRequirements {\n                        whitelist: vec![Addr::unchecked(\"deployer\")],\n                        first_asset_minimum: Uint128::zero(),\n                        second_asset_minimum: Uint128::zero(),\n                    },\n                },\n            ),\n            (\n                \u0026\"asset0000uluna\".to_string(),\n                \u0026PairInfo {\n                    asset_infos: [\n                        AssetInfo::Token {\n                            contract_addr: \"asset0000\".to_string(),\n                        },\n                        AssetInfo::NativeToken {\n                            denom: \"uluna\".to_string(),\n                        },\n                    ],\n                    contract_addr: \"pair0001\".to_string(),\n                    liquidity_token: \"liquidity0001\".to_string(),\n                    asset_decimals: [6u8, 6u8],\n                    requirements: CreatePairRequirements {\n                        whitelist: vec![Addr::unchecked(\"deployer\")],\n                        first_asset_minimum: Uint128::zero(),\n                        second_asset_minimum: Uint128::zero(),\n                    },\n                },\n            ),\n        ],\n        \u0026[(\"ukrw\".to_string(), 6u8), (\"uluna\".to_string(), 6u8)],\n    );\n\n    let res: SimulateSwapOperationsResponse =\n        from_binary(\u0026query(deps.as_ref(), mock_env(), msg).unwrap()).unwrap();\n    assert_eq!(\n        res,\n        SimulateSwapOperationsResponse {\n            amount: Uint128::from(1000000u128)\n        }\n    );\n}\n\n#[test]\nfn query_reverse_routes_with_from_native() {\n    let mut deps = mock_dependencies(\u0026[]);\n\n    let msg = InstantiateMsg {\n        halo_factory: \"halofactory\".to_string(),\n    };\n\n    let target_amount = 1000000u128;\n\n    let info = mock_info(\"addr0000\", \u0026[coin(10000000, \"ukrw\")]);\n\n    // we can just call .unwrap() to assert this was a success\n    let _res = instantiate(deps.as_mut(), mock_env(), info, msg).unwrap();\n\n    deps.querier.with_balance(\u0026[(\n        \u0026MOCK_CONTRACT_ADDR.to_string(),\n        [Coin {\n            amount: Uint128::from(1000000u128),\n            denom: \"ukrw\".to_string(),\n        }]\n        .to_vec(),\n    )]);\n\n    deps.querier.with_token_balances(\u0026[(\n        \u0026\"asset0001\".to_string(),\n        \u0026[(\u0026MOCK_CONTRACT_ADDR.to_string(), \u0026Uint128::from(1000000u128))],\n    )]);\n\n    let msg = QueryMsg::ReverseSimulateSwapOperations {\n        ask_amount: Uint128::from(target_amount),\n        operations: vec![SwapOperation::HaloSwap {\n            offer_asset_info: AssetInfo::NativeToken {\n                denom: \"ukrw\".to_string(),\n            },\n            ask_asset_info: AssetInfo::Token {\n                contract_addr: \"asset0000\".to_string(),\n            },\n        }],\n    };\n\n    deps.querier.with_halo_factory(\n        \u0026[\n            (\n                \u0026\"ukrwasset0000\".to_string(),\n                \u0026PairInfo {\n                    contract_addr: \"pair0000\".to_string(),\n                    liquidity_token: \"liquidity0000\".to_string(),\n                    asset_infos: [\n                        AssetInfo::Token {\n                            contract_addr: \"asset0000\".to_string(),\n                        },\n                        AssetInfo::NativeToken {\n                            denom: \"ukrw\".to_string(),\n                        },\n                    ],\n                    asset_decimals: [8u8, 6u8],\n                    requirements: CreatePairRequirements {\n                        whitelist: vec![Addr::unchecked(\"deployer\")],\n                        first_asset_minimum: Uint128::zero(),\n                        second_asset_minimum: Uint128::zero(),\n                    },\n                },\n            ),\n            (\n                \u0026\"asset0000uluna\".to_string(),\n                \u0026PairInfo {\n                    contract_addr: \"pair0001\".to_string(),\n                    liquidity_token: \"liquidity0001\".to_string(),\n                    asset_infos: [\n                        AssetInfo::Token {\n                            contract_addr: \"asset0000\".to_string(),\n                        },\n                        AssetInfo::NativeToken {\n                            denom: \"uluna\".to_string(),\n                        },\n                    ],\n                    asset_decimals: [8u8, 6u8],\n                    requirements: CreatePairRequirements {\n                        whitelist: vec![Addr::unchecked(\"deployer\")],\n                        first_asset_minimum: Uint128::zero(),\n                        second_asset_minimum: Uint128::zero(),\n                    },\n                },\n            ),\n        ],\n        \u0026[(\"ukrw\".to_string(), 6u8), (\"uluna\".to_string(), 6u8)],\n    );\n\n    let res: SimulateSwapOperationsResponse =\n        from_binary(\u0026query(deps.as_ref(), mock_env(), msg).unwrap()).unwrap();\n\n    assert_eq!(\n        res,\n        SimulateSwapOperationsResponse {\n            amount: Uint128::from(1000000u128),\n        }\n    );\n\n    let offer_amount = res.amount;\n\n    let msg = ExecuteMsg::ExecuteSwapOperation {\n        operation: SwapOperation::HaloSwap {\n            offer_asset_info: AssetInfo::NativeToken {\n                denom: \"ukrw\".to_string(),\n            },\n            ask_asset_info: AssetInfo::Token {\n                contract_addr: \"asset0000\".to_string(),\n            },\n        },\n        to: None,\n    };\n    let info = mock_info(\"addr0\", \u0026[coin(offer_amount.u128(), \"ukrw\")]);\n    let res = execute(deps.as_mut(), mock_env(), info, msg.clone());\n    match res {\n        Err(StdError::GenericErr { msg, .. }) =\u003e assert_eq!(msg, \"unauthorized\"),\n        _ =\u003e panic!(\"DO NOT ENTER HERE\"),\n    }\n\n    let info = mock_info(MOCK_CONTRACT_ADDR, \u0026[]);\n    let res = execute(deps.as_mut(), mock_env(), info, msg).unwrap();\n\n    assert_eq!(\n        res.messages,\n        vec![SubMsg::new(CosmosMsg::Wasm(WasmMsg::Execute {\n            contract_addr: \"pair0000\".to_string(),\n            funds: vec![coin(target_amount, \"ukrw\")],\n            msg: to_binary(\u0026PairHookMsg::Swap {\n                belief_price: None,\n                max_spread: None,\n                to: None,\n            })\n            .unwrap(),\n        })),],\n    );\n}\n\n#[test]\nfn query_reverse_routes_with_to_native() {\n    let mut deps = mock_dependencies(\u0026[]);\n\n    let msg = InstantiateMsg {\n        halo_factory: \"halofactory\".to_string(),\n    };\n\n    let target_amount = 1000000u128;\n\n    let info = mock_info(\"addr0000\", \u0026[]);\n\n    // we can just call .unwrap() to assert this was a success\n    let _res = instantiate(deps.as_mut(), mock_env(), info, msg).unwrap();\n\n    deps.querier.with_token_balances(\u0026[\n        (\n            \u0026\"asset0000\".to_string(),\n            \u0026[(\u0026\"pair0000\".to_string(), \u0026Uint128::from(1000000u128))],\n        ),\n        (\n            \u0026\"asset0000\".to_string(),\n            \u0026[(\u0026MOCK_CONTRACT_ADDR.to_string(), \u0026Uint128::from(1000000u128))],\n        ),\n    ]);\n\n    let msg = QueryMsg::ReverseSimulateSwapOperations {\n        ask_amount: Uint128::from(target_amount),\n        operations: vec![SwapOperation::HaloSwap {\n            offer_asset_info: AssetInfo::Token {\n                contract_addr: \"asset0000\".to_string(),\n            },\n            ask_asset_info: AssetInfo::NativeToken {\n                denom: \"ukrw\".to_string(),\n            },\n        }],\n    };\n\n    deps.querier.with_halo_factory(\n        \u0026[\n            (\n                \u0026\"ukrwasset0000\".to_string(),\n                \u0026PairInfo {\n                    contract_addr: \"pair0000\".to_string(),\n                    liquidity_token: \"liquidity0000\".to_string(),\n                    asset_infos: [\n                        AssetInfo::Token {\n                            contract_addr: \"asset0000\".to_string(),\n                        },\n                        AssetInfo::NativeToken {\n                            denom: \"ukrw\".to_string(),\n                        },\n                    ],\n                    asset_decimals: [8u8, 6u8],\n                    requirements: CreatePairRequirements {\n                        whitelist: vec![Addr::unchecked(\"deployer\")],\n                        first_asset_minimum: Uint128::zero(),\n                        second_asset_minimum: Uint128::zero(),\n                    },\n                },\n            ),\n            (\n                \u0026\"asset0000uluna\".to_string(),\n                \u0026PairInfo {\n                    contract_addr: \"pair0001\".to_string(),\n                    liquidity_token: \"liquidity0001\".to_string(),\n                    asset_infos: [\n                        AssetInfo::Token {\n                            contract_addr: \"asset0000\".to_string(),\n                        },\n                        AssetInfo::NativeToken {\n                            denom: \"uluna\".to_string(),\n                        },\n                    ],\n                    asset_decimals: [8u8, 6u8],\n                    requirements: CreatePairRequirements {\n                        whitelist: vec![Addr::unchecked(\"deployer\")],\n                        first_asset_minimum: Uint128::zero(),\n                        second_asset_minimum: Uint128::zero(),\n                    },\n                },\n            ),\n        ],\n        \u0026[(\"ukrw\".to_string(), 6u8), (\"uluna\".to_string(), 6u8)],\n    );\n\n    let res: SimulateSwapOperationsResponse =\n        from_binary(\u0026query(deps.as_ref(), mock_env(), msg).unwrap()).unwrap();\n\n    assert_eq!(\n        res,\n        SimulateSwapOperationsResponse {\n            amount: Uint128::from(target_amount),\n        }\n    );\n\n    let offer_amount = res.amount;\n\n    let msg = ExecuteMsg::Receive(Cw20ReceiveMsg {\n        sender: \"addr0\".to_string(),\n        amount: offer_amount,\n        msg: to_binary(\u0026Cw20HookMsg::ExecuteSwapOperations {\n            operations: vec![SwapOperation::HaloSwap {\n                offer_asset_info: AssetInfo::Token {\n                    contract_addr: \"asset0000\".to_string(),\n                },\n                ask_asset_info: AssetInfo::NativeToken {\n                    denom: \"ukrw\".to_string(),\n                },\n            }],\n            minimum_receive: None,\n            to: None,\n        })\n        .unwrap(),\n    });\n    let info = mock_info(\"addr0\", \u0026[]);\n    let res = execute(deps.as_mut(), mock_env(), info, msg).unwrap();\n\n    assert_eq!(\n        res.messages,\n        vec![SubMsg::new(CosmosMsg::Wasm(WasmMsg::Execute {\n            contract_addr: MOCK_CONTRACT_ADDR.to_string(),\n            funds: vec![],\n            msg: to_binary(\u0026ExecuteMsg::ExecuteSwapOperation {\n                operation: SwapOperation::HaloSwap {\n                    offer_asset_info: AssetInfo::Token {\n                        contract_addr: \"asset0000\".to_string(),\n                    },\n                    ask_asset_info: AssetInfo::NativeToken {\n                        denom: \"ukrw\".to_string(),\n                    },\n                },\n                to: Some(\"addr0\".to_string()),\n            })\n            .unwrap(),\n        })),],\n    );\n\n    let msg = ExecuteMsg::ExecuteSwapOperation {\n        operation: SwapOperation::HaloSwap {\n            offer_asset_info: AssetInfo::Token {\n                contract_addr: \"asset0000\".to_string(),\n            },\n            ask_asset_info: AssetInfo::NativeToken {\n                denom: \"ukrw\".to_string(),\n            },\n        },\n        to: None,\n    };\n\n    let info = mock_info(MOCK_CONTRACT_ADDR, \u0026[]);\n    let res = execute(deps.as_mut(), mock_env(), info, msg).unwrap();\n\n    assert_eq!(\n        res.messages,\n        vec![SubMsg::new(CosmosMsg::Wasm(WasmMsg::Execute {\n            contract_addr: \"asset0000\".to_string(),\n            funds: vec![],\n            msg: to_binary(\u0026Cw20ExecuteMsg::Send {\n                contract: \"pair0000\".to_string(),\n                amount: Uint128::from(target_amount),\n                msg: to_binary(\u0026PairHookMsg::Swap {\n                    belief_price: None,\n                    max_spread: None,\n                    to: None,\n                })\n                .unwrap(),\n            })\n            .unwrap(),\n        }))],\n    );\n}\n\n#[test]\nfn assert_minimum_receive_native_token() {\n    let mut deps = mock_dependencies(\u0026[]);\n    deps.querier.with_balance(\u0026[(\n        \u0026\"addr0000\".to_string(),\n        [Coin {\n            denom: \"uusd\".to_string(),\n            amount: Uint128::from(1000000u128),\n        }]\n        .to_vec(),\n    )]);\n\n    let info = mock_info(\"addr0000\", \u0026[]);\n    // success\n    let msg = ExecuteMsg::AssertMinimumReceive {\n        asset_info: AssetInfo::NativeToken {\n            denom: \"uusd\".to_string(),\n        },\n        prev_balance: Uint128::zero(),\n        minimum_receive: Uint128::from(1000000u128),\n        receiver: \"addr0000\".to_string(),\n    };\n    let _res = execute(deps.as_mut(), mock_env(), info.clone(), msg).unwrap();\n\n    // assertion failed; native token\n    let msg = ExecuteMsg::AssertMinimumReceive {\n        asset_info: AssetInfo::NativeToken {\n            denom: \"uusd\".to_string(),\n        },\n        prev_balance: Uint128::zero(),\n        minimum_receive: Uint128::from(1000001u128),\n        receiver: \"addr0000\".to_string(),\n    };\n    let res = execute(deps.as_mut(), mock_env(), info, msg);\n    match res {\n        Err(StdError::GenericErr { msg, .. }) =\u003e assert_eq!(\n            msg,\n            \"assertion failed; minimum receive amount: 1000001, swap amount: 1000000\"\n        ),\n        _ =\u003e panic!(\"DO NOT ENTER HERE\"),\n    }\n}\n\n#[test]\nfn assert_minimum_receive_token() {\n    let mut deps = mock_dependencies(\u0026[]);\n    deps.querier.with_token_balances(\u0026[(\n        \u0026\"token0000\".to_string(),\n        \u0026[(\u0026\"addr0000\".to_string(), \u0026Uint128::from(1000000u128))],\n    )]);\n\n    let info = mock_info(\"addr0000\", \u0026[]);\n    // success\n    let msg = ExecuteMsg::AssertMinimumReceive {\n        asset_info: AssetInfo::Token {\n            contract_addr: \"token0000\".to_string(),\n        },\n        prev_balance: Uint128::zero(),\n        minimum_receive: Uint128::from(1000000u128),\n        receiver: \"addr0000\".to_string(),\n    };\n    let _res = execute(deps.as_mut(), mock_env(), info.clone(), msg).unwrap();\n\n    // assertion failed; native token\n    let msg = ExecuteMsg::AssertMinimumReceive {\n        asset_info: AssetInfo::Token {\n            contract_addr: \"token0000\".to_string(),\n        },\n        prev_balance: Uint128::zero(),\n        minimum_receive: Uint128::from(1000001u128),\n        receiver: \"addr0000\".to_string(),\n    };\n    let res = execute(deps.as_mut(), mock_env(), info, msg);\n    match res {\n        Err(StdError::GenericErr { msg, .. }) =\u003e assert_eq!(\n            msg,\n            \"assertion failed; minimum receive amount: 1000001, swap amount: 1000000\"\n        ),\n        _ =\u003e panic!(\"DO NOT ENTER HERE\"),\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","haitran","AURA-NETWORK","smart-contracts-halotrade-zone","contracts","halo-token","src","contract.rs"],"content":"#[cfg(not(feature = \"library\"))]\nuse cosmwasm_std::entry_point;\nuse cosmwasm_std::{Binary, Deps, DepsMut, Env, MessageInfo, Response, StdError, StdResult};\n\nuse cw2::set_contract_version;\nuse cw20_base::contract::{create_accounts, execute as cw20_execute, query as cw20_query};\nuse cw20_base::msg::{ExecuteMsg, QueryMsg};\nuse cw20_base::state::{MinterData, TokenInfo, TOKEN_INFO};\nuse cw20_base::ContractError;\n\nuse haloswap::token::InstantiateMsg;\n\n// version info for migration info\nconst CONTRACT_NAME: \u0026str = \"crates.io:cw20-base\";\nconst CONTRACT_VERSION: \u0026str = env!(\"CARGO_PKG_VERSION\");\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn instantiate(\n    mut deps: DepsMut,\n    _env: Env,\n    _info: MessageInfo,\n    msg: InstantiateMsg,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    set_contract_version(deps.storage, CONTRACT_NAME, CONTRACT_VERSION)?;\n    // check valid token info\n    msg.validate()?;\n\n    // convert initial_balances to slice of Cw20Coin\n    let initial_balances_slice = msg.initial_balances.as_slice();\n\n    // create initial accounts\n    let total_supply = create_accounts(\u0026mut deps, initial_balances_slice)?;\n\n    if let Some(limit) = msg.get_cap() {\n        if total_supply \u003e limit {\n            return Err(ContractError::Std(StdError::generic_err(\n                \"Initial supply greater than cap\",\n            )));\n        }\n    }\n\n    let mint = match msg.mint {\n        Some(m) =\u003e Some(MinterData {\n            minter: deps.api.addr_validate(\u0026m.minter)?,\n            cap: m.cap,\n        }),\n        None =\u003e None,\n    };\n\n    // store token info\n    let data = TokenInfo {\n        name: msg.name,\n        symbol: msg.symbol,\n        decimals: msg.decimals,\n        total_supply,\n        mint,\n    };\n\n    TOKEN_INFO.save(deps.storage, \u0026data)?;\n    Ok(Response::default())\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn execute(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    msg: ExecuteMsg,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    cw20_execute(deps, env, info, msg)\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn query(deps: Deps, env: Env, msg: QueryMsg) -\u003e StdResult\u003cBinary\u003e {\n    cw20_query(deps, env, msg)\n}\n","traces":[{"line":24,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":22,"coverable":22},{"path":["/","Users","haitran","AURA-NETWORK","smart-contracts-halotrade-zone","contracts","halo-token","src","env_setup.rs"],"content":"#[cfg(test)]\npub mod env {\n    use cosmwasm_std::{Addr, Coin, Empty, StdError, Uint128};\n    use cw_multi_test::{App, AppBuilder, Contract, ContractWrapper, Executor};\n    use cw20::{Cw20Coin, MinterResponse};\n\n    use crate::contract::{execute as halo_token_execute, instantiate as halo_token_instantiate, query as halo_token_query};\n    use haloswap::token::InstantiateMsg;\n    // ****************************************\n    // You MUST define the constants value here\n    // ****************************************\n    pub const ADMIN: \u0026str = \"aura1uh24g2lc8hvvkaaf7awz25lrh5fptthu2dhq0n\";\n    pub const USER_1: \u0026str = \"aura1fqj2redmssckrdeekhkcvd2kzp9f4nks4fctrt\";\n\n    pub const NATIVE_DENOM: \u0026str = \"uaura\";\n    pub const NATIVE_BALANCE: u128 = 1_000_000_000_000u128;\n\n    pub const NATIVE_DENOM_2: \u0026str = \"uaura1\";\n    pub const NATIVE_BALANCE_2: u128 = 500_000_000_000u128;\n\n    pub struct ContractInfo {\n        pub contract_addr: String,\n        pub contract_code_id: u64,\n    }\n\n\n    fn mock_app() -\u003e App {\n        AppBuilder::new().build(|router, _, storage| {\n            router\n                .bank\n                .init_balance(\n                    storage,\n                    \u0026Addr::unchecked(ADMIN),\n                    vec![\n                        Coin {\n                            denom: NATIVE_DENOM.to_string(),\n                            amount: Uint128::new(NATIVE_BALANCE),\n                        },\n                        Coin {\n                            denom: NATIVE_DENOM_2.to_string(),\n                            amount: Uint128::new(NATIVE_BALANCE_2),\n                        },\n                    ],\n                )\n                .unwrap();\n        })\n    }\n\n    fn halo_contract_template() -\u003e Box\u003cdyn Contract\u003cEmpty\u003e\u003e {\n        let contract = ContractWrapper::new(halo_token_execute, halo_token_instantiate, halo_token_query);\n        Box::new(contract)\n    }\n\n    // *********************************************************\n    // You MUST store code and instantiate all contracts here\n    // Follow the example (2) below:\n    // @return App: the mock app\n    // @return String: the address of the contract\n    // @return u64: the code id of the contract\n    //    pub fn instantiate_contracts() -\u003e (App, String, u64) {\n    //        // Create a new app instance\n    //        let mut app = mock_app();\n    //\n    //        // store the code of all contracts to the app and get the code ids\n    //        let contract_code_id = app.store_code(contract_template());\n    //\n    //        // create instantiate message for contract\n    //        let contract_instantiate_msg = InstantiateMsg {\n    //            name: \"Contract_A\".to_string(),\n    //        };\n    //\n    //        // instantiate contract\n    //        let contract_addr = app\n    //            .instantiate_contract(\n    //                contract_code_id,\n    //                Addr::unchecked(ADMIN),\n    //                \u0026contract_instantiate_msg,\n    //                \u0026[],\n    //                \"test instantiate contract\",\n    //                None,\n    //            )\n    //            .unwrap();\n    //\n    //        // return the app instance, the addresses and code IDs of all contracts\n    //        (app, contract_addr, contract_code_id)\n    //    }\n    // *********************************************************\n    pub fn instantiate_contracts() -\u003e (App, Vec\u003cContractInfo\u003e) {\n        // Create a new app instance\n        let mut app = mock_app();\n\n        // halo token contract\n        // store the code of all contracts to the app and get the code ids\n        let halo_token_contract_code_id = app.store_code(halo_contract_template());\n\n        let mut contract_info_vec: Vec\u003cContractInfo\u003e = Vec::new();\n\n        // create instantiate message for contract\n        let contract_instantiate_msg = InstantiateMsg {\n            name: \"Halo Token\".to_string(),\n            symbol: \"HALO\".to_string(),\n            decimals: 6,\n            initial_balances: vec![],\n            mint: None,\n        };\n\n        // instantiate contract\n        let halo_token_contract_addr = app\n            .instantiate_contract(\n                halo_token_contract_code_id,\n                Addr::unchecked(ADMIN),\n                \u0026contract_instantiate_msg,\n                \u0026[],\n                \"test instantiate contract\",\n                None,\n            )\n            .unwrap();\n\n        // add contract info to the vector\n        contract_info_vec.push(ContractInfo {\n            contract_addr: halo_token_contract_addr.to_string(),\n            contract_code_id: halo_token_contract_code_id,\n        });\n\n        // return the app instance, the addresses and code IDs of all contracts\n        (app, contract_info_vec)\n    }\n\n    // can not instantiate halo token with wrong validate condition (name, symbol, decimals)\n#[test]\n    fn cannot_instantiate_with_wrong_validate_condition() {\n        let mut app = mock_app();\n        let halo_token_contract_code_id = app.store_code(halo_contract_template());\n\n        let too_short_token_name_instantiate_msg = InstantiateMsg {\n            name: \"H\".to_string(),\n            symbol: \"HALO\".to_string(),\n            decimals: 18,\n            initial_balances: vec![],\n            mint: None,\n        };\n\n        let too_long_token_name_instantiate_msg = InstantiateMsg {\n            name: \"0123456789a123456789b123456789c123456789d123456789e\".to_string(), // 51 characters\n            symbol: \"HALO\".to_string(),\n            decimals: 18,\n            initial_balances: vec![],\n            mint: None,\n        };\n\n        let too_short_token_symbol_instantiate_msg = InstantiateMsg {\n            name: \"Halo Token\".to_string(),\n            symbol: \"H\".to_string(),\n            decimals: 18,\n            initial_balances: vec![],\n            mint: None,\n        };\n\n        let too_long_token_symbol_instantiate_msg = InstantiateMsg {\n            name: \"Halo Token\".to_string(),\n            symbol: \"0123456789a123456789b123456789c123456789d123456789e\".to_string(), // 51 characters\n            decimals: 18,\n            initial_balances: vec![],\n            mint: None,\n        };\n\n        let too_big_token_decimals_instantiate_msg = InstantiateMsg {\n            name: \"Halo Token\".to_string(),\n            symbol: \"HALO\".to_string(),\n            decimals: 20,\n            initial_balances: vec![],\n            mint: None,\n        };\n\n        let initial_supply_greater_than_cap_msg = InstantiateMsg {\n            name: \"Halo Token\".to_string(),\n            symbol: \"HALO\".to_string(),\n            decimals: 18,\n            initial_balances: vec![Cw20Coin{\n                address: Addr::unchecked(ADMIN).to_string(),\n                amount: Uint128::new(100),\n            }],\n            mint: Some(MinterResponse {\n                minter: ADMIN.to_string(),\n                cap: Some(Uint128::new(90)),\n            }),\n        };\n\n        let err = app\n            .instantiate_contract(\n                halo_token_contract_code_id,\n                Addr::unchecked(ADMIN),\n                \u0026too_short_token_name_instantiate_msg,\n                \u0026[],\n                \"test wrong token name instantiate contract\",\n                None,\n            )\n            .unwrap_err();\n        \n        assert_eq!(\n            err.source().unwrap().to_string(),\n            StdError::generic_err(\"Name is not in the expected format (3-50 UTF-8 bytes)\").to_string()\n        );\n\n        let err = app\n            .instantiate_contract(\n                halo_token_contract_code_id,\n                Addr::unchecked(ADMIN),\n                \u0026too_long_token_name_instantiate_msg,\n                \u0026[],\n                \"test wrong token name instantiate contract\",\n                None,\n            )\n            .unwrap_err();\n        \n        assert_eq!(\n            err.source().unwrap().to_string(),\n            StdError::generic_err(\"Name is not in the expected format (3-50 UTF-8 bytes)\").to_string()\n        );\n\n        let err = app\n            .instantiate_contract(\n                halo_token_contract_code_id,\n                Addr::unchecked(ADMIN),\n                \u0026too_short_token_symbol_instantiate_msg,\n                \u0026[],\n                \"test wrong token symbol instantiate contract\",\n                None,\n            )\n            .unwrap_err();\n\n        assert_eq!(\n            err.source().unwrap().to_string(),\n            StdError::generic_err(\"Ticker symbol is not in expected format [a-zA-Z\\\\-]{3,12}\").to_string()\n        );\n\n        let err = app\n            .instantiate_contract(\n                halo_token_contract_code_id,\n                Addr::unchecked(ADMIN),\n                \u0026too_long_token_symbol_instantiate_msg,\n                \u0026[],\n                \"test wrong token symbol instantiate contract\",\n                None,\n            )\n            .unwrap_err();\n\n        assert_eq!(\n            err.source().unwrap().to_string(),\n            StdError::generic_err(\"Ticker symbol is not in expected format [a-zA-Z\\\\-]{3,12}\").to_string()\n        );\n\n        let err = app\n            .instantiate_contract(\n                halo_token_contract_code_id,\n                Addr::unchecked(ADMIN),\n                \u0026too_big_token_decimals_instantiate_msg,\n                \u0026[],\n                \"test wrong token decimals instantiate contract\",\n                None,\n            )\n            .unwrap_err();\n\n        assert_eq!(\n            err.source().unwrap().to_string(),\n            StdError::generic_err(\"Decimals must not exceed 18\").to_string()\n        );\n\n        let err = app\n            .instantiate_contract(\n                halo_token_contract_code_id,\n                Addr::unchecked(ADMIN),\n                \u0026initial_supply_greater_than_cap_msg,\n                \u0026[],\n                \"test initial supply greater than cap msg\",\n                None,\n            )\n            .unwrap_err();\n\n        assert_eq!(\n            err.source().unwrap().to_string(),\n            StdError::generic_err(\"Initial supply greater than cap\").to_string()\n        );\n\n    }\n}\n\n\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","haitran","AURA-NETWORK","smart-contracts-halotrade-zone","contracts","halo-token","src","integration_test.rs"],"content":"#[cfg(test)]\nmod tests {\n    use cosmwasm_std::{coins, from_binary, to_binary, Addr, DepsMut, Response, OwnedDeps, MemoryStorage, testing::{MockApi, MockQuerier, mock_dependencies, mock_info, mock_env}, WasmQuery, Uint128, ContractResult};\n\n    use cw20_base::{ContractError, msg::QueryMsg, msg::ExecuteMsg};\n    \n    use crate::env_setup::env::{instantiate_contracts, ADMIN, USER_1};\n    use crate::contract::*;\n    use cw20::{Expiration as Cw20Expiration, TokenInfoResponse, Cw20Coin, MinterResponse};\n    use haloswap::token::InstantiateMsg;\n\n    const MOCK_HALO_TOKEN_ADDR: \u0026str = \"halo_token_addr\";\n\n    const MOCK_OFFER_CW20_ADDR: \u0026str = \"cw20_addr\";\n    const MOCK_OFFER_CW20_AMOUNT: u128 = 1000000000;\n    const MOCK_OFFER_CW20_AMOUNT_MINIMUM: u128 = 1;\n    const MOCK_OFFER_CW20_PRICE: u128 = 10000000;\n\n\n    const MOCK_OFFER_NFT_OFFERER_INSUFFICIENT_BALANCE: \u0026str = \"offerer 2\";\n    const MOCK_OFFER_NFT_OFFERER_INSUFFICIENT_ALLOWANCE: \u0026str = \"offerer 3\";\n\n    fn mock_deps() -\u003e OwnedDeps\u003cMemoryStorage, MockApi, MockQuerier\u003e {\n        let mut deps = mock_dependencies();\n        let msg = InstantiateMsg {\n            name: \"Cafe Token\".to_string(),\n            symbol: \"CAFE\".to_string(),\n            decimals: 6,\n            initial_balances: vec![],\n            mint: Some(MinterResponse {\n                minter: ADMIN.to_string(),\n                cap: Some(Uint128::new(90)),\n            }),\n        };\n\n        // mock querier\n        deps.querier.update_wasm(|query| {\n            match query {\n                WasmQuery::Smart { contract_addr, msg } =\u003e match contract_addr.as_str() {\n                    MOCK_HALO_TOKEN_ADDR =\u003e {\n                        let query_msg = from_binary::\u003ccw20_base::msg::QueryMsg\u003e(msg).unwrap();\n                        match query_msg {\n                            cw20_base::msg::QueryMsg::Balance { address, .. } =\u003e {\n                                if address == MOCK_OFFER_NFT_OFFERER_INSUFFICIENT_BALANCE {\n                                    let result = ContractResult::Ok(\n                                        to_binary(\u0026cw20::BalanceResponse {\n                                            balance: Uint128::from(MOCK_OFFER_CW20_AMOUNT_MINIMUM),\n                                        })\n                                        .unwrap(),\n                                    );\n                                    cosmwasm_std::SystemResult::Ok(result)\n                                } else {\n                                    let result = ContractResult::Ok(\n                                        to_binary(\u0026cw20::BalanceResponse {\n                                            balance: Uint128::from(MOCK_OFFER_CW20_AMOUNT),\n                                        })\n                                        .unwrap(),\n                                    );\n                                    cosmwasm_std::SystemResult::Ok(result)\n                                }\n                            }\n                            cw20_base::msg::QueryMsg::Allowance { owner, spender: _ } =\u003e {\n                                if owner == MOCK_OFFER_NFT_OFFERER_INSUFFICIENT_ALLOWANCE {\n                                    let result = ContractResult::Ok(\n                                        to_binary(\u0026cw20::AllowanceResponse {\n                                            allowance: Uint128::from(\n                                                MOCK_OFFER_CW20_AMOUNT_MINIMUM,\n                                            ),\n                                            expires: Cw20Expiration::Never {},\n                                        })\n                                        .unwrap(),\n                                    );\n                                    cosmwasm_std::SystemResult::Ok(result)\n                                } else {\n                                    let result = ContractResult::Ok(\n                                        to_binary(\u0026cw20::AllowanceResponse {\n                                            allowance: Uint128::from(MOCK_OFFER_CW20_AMOUNT),\n                                            expires: Cw20Expiration::Never {},\n                                        })\n                                        .unwrap(),\n                                    );\n                                    cosmwasm_std::SystemResult::Ok(result)\n                                }\n                            }\n                            _ =\u003e {\n                                let result = ContractResult::Err(\"Not Found\".to_string());\n                                cosmwasm_std::SystemResult::Ok(result)\n                            }\n                        }\n                    }\n                    _ =\u003e {\n                        panic!(\"Unexpected contract address: {}\", contract_addr);\n                    }\n                },\n                _ =\u003e panic!(\"Unexpected query\"),\n            }\n            // mock query royalty info\n        });\n        let res = instantiate_contract(deps.as_mut(), msg).unwrap();\n        assert_eq!(0, res.messages.len());\n        deps\n    }\n\n    // we will instantiate a contract with account \"owner\" but admin is \"owner\"\n    fn instantiate_contract(deps: DepsMut, msg: InstantiateMsg) -\u003e Result\u003cResponse, ContractError\u003e {\n        let info = mock_info(\"owner\", \u0026coins(1000, \"uaura\"));\n        instantiate(deps, mock_env(), info, msg)\n    }\n\n    #[test]\n    fn proper_initialization() {\n        let deps = mock_deps();\n        // query config\n        let res = query(deps.as_ref(), mock_env(), QueryMsg::TokenInfo {}).unwrap();\n        let token_info: TokenInfoResponse = from_binary(\u0026res).unwrap();\n\n        assert_eq!(\"Cafe Token\".to_string(), token_info.name);\n        assert_eq!(\"CAFE\".to_string(), token_info.symbol);\n        assert_eq!(6, token_info.decimals);\n        assert_eq!(Uint128::from(0u128), token_info.total_supply);\n    }\n\n    #[test]\n    fn proper_initialization_with_no_minter_data() {\n        let msg = InstantiateMsg {\n            name: \"Cafe Token\".to_string(),\n            symbol: \"CAFE\".to_string(),\n            decimals: 6,\n            initial_balances: vec![],\n            mint: None, // no minter data\n        };\n        let mut deps = mock_deps();\n\n        let res = instantiate_contract(deps.as_mut(), msg);\n        assert!(res.is_ok());\n    }\n\n\n    mod execute_contract {\n        use super::*;\n        // Checking Minting works\n        fn create_mint_msg(\n            deps: DepsMut,\n            sender: \u0026str,\n            recipient: \u0026str,\n            amount: Uint128,\n        ) -\u003e Result\u003cResponse, ContractError\u003e {\n            let msg = ExecuteMsg::Mint {\n                recipient: recipient.to_string(),\n                amount,\n            };\n            let info = mock_info(sender, \u0026coins(1000, \"uaura\"));\n            execute(deps, mock_env(), info, msg)\n        }\n\n        #[test]\n        fn proper_execute_mint() {\n            let mut deps = mock_deps();\n            let response = create_mint_msg(\n                deps.as_mut(), \n                ADMIN, \n                USER_1,\n                Uint128::from(10u128));\n            \n            println!(\"Response: {:?}\", \u0026response);\n            assert!(response.is_ok());\n\n        }\n    }\n\n}","traces":[],"covered":0,"coverable":0},{"path":["/","Users","haitran","AURA-NETWORK","smart-contracts-halotrade-zone","contracts","halo-token","src","lib.rs"],"content":"pub mod contract;\npub mod env_setup;\npub mod integration_test;","traces":[],"covered":0,"coverable":0},{"path":["/","Users","haitran","AURA-NETWORK","smart-contracts-halotrade-zone","packages","bignumber","src","lib.rs"],"content":"mod math;\n\npub use crate::math::{Decimal256, Uint256};\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","haitran","AURA-NETWORK","smart-contracts-halotrade-zone","packages","bignumber","src","math.rs"],"content":"use schemars::JsonSchema;\nuse serde::{de, ser, Deserialize, Deserializer, Serialize};\nuse std::convert::TryFrom;\nuse std::fmt::{self, Write};\nuse std::ops;\nuse std::str::FromStr;\n\nuse bigint::U256;\nuse cosmwasm_std::{Decimal, StdError, Uint128};\n\n/// A fixed-point decimal value with 18 fractional digits, i.e. Decimal256(1_000_000_000_000_000_000) == 1.0\n/// The greatest possible value that can be represented is 115792089237316195423570985008687907853269984665640564039457.584007913129639935 (which is (2^128 - 1) / 10^18)\n#[derive(Copy, Clone, Default, Debug, PartialEq, Eq, PartialOrd, Ord, JsonSchema)]\npub struct Decimal256(#[schemars(with = \"String\")] pub U256);\n\nimpl Decimal256 {\n    pub const MAX: Decimal256 = Decimal256(U256::MAX);\n    pub const DECIMAL_FRACTIONAL: U256 = U256([1_000_000_000_000_000_000u64, 0, 0, 0]);\n\n    /// Create a 1.0 Decimal256\n    pub const fn one() -\u003e Decimal256 {\n        Decimal256(Decimal256::DECIMAL_FRACTIONAL)\n    }\n\n    /// Create a 0.0 Decimal256\n    pub const fn zero() -\u003e Decimal256 {\n        Decimal256(U256([0, 0, 0, 0]))\n    }\n\n    /// Convert x% into Decimal256\n    pub fn percent(x: u64) -\u003e Decimal256 {\n        Decimal256(U256::from(x) * U256::from(10_000_000_000_000_000u64))\n    }\n\n    /// Convert permille (x/1000) into Decimal256\n    pub fn permille(x: u64) -\u003e Decimal256 {\n        Decimal256(U256::from(x) * U256::from(1_000_000_000_000_000u64))\n    }\n\n    /// Returns the ratio (nominator / denominator) as a Decimal256\n    pub fn from_ratio\u003cA: Into\u003cU256\u003e, B: Into\u003cU256\u003e\u003e(nominator: A, denominator: B) -\u003e Decimal256 {\n        let nominator: U256 = nominator.into();\n        let denominator: U256 = denominator.into();\n        if denominator.is_zero() {\n            panic!(\"Denominator must not be zero\");\n        }\n\n        Decimal256(nominator * Decimal256::DECIMAL_FRACTIONAL / denominator)\n    }\n\n    pub fn from_uint256\u003cA: Into\u003cUint256\u003e\u003e(val: A) -\u003e Decimal256 {\n        let num: Uint256 = val.into();\n        Decimal256(num.0 * Decimal256::DECIMAL_FRACTIONAL)\n    }\n\n    pub fn is_zero(\u0026self) -\u003e bool {\n        self.0.is_zero()\n    }\n}\n\nimpl From\u003cDecimal\u003e for Decimal256 {\n    fn from(val: Decimal) -\u003e Self {\n        Decimal256::from_str(\u0026val.to_string()).unwrap()\n    }\n}\n\nimpl From\u003cDecimal256\u003e for Decimal {\n    fn from(n: Decimal256) -\u003e Self {\n        let U256(ref arr) = n.0;\n        assert!(arr[2] == 0u64);\n        assert!(arr[3] == 0u64);\n        Decimal::from_str(\u0026n.to_string()).unwrap()\n    }\n}\n\nimpl FromStr for Decimal256 {\n    type Err = StdError;\n\n    /// Converts the decimal string to a Decimal256\n    /// Possible inputs: \"1.23\", \"1\", \"000012\", \"1.123000000\"\n    /// Disallowed: \"\", \".23\"\n    ///\n    /// This never performs any kind of rounding.\n    /// More than 18 fractional digits, even zeros, result in an error.\n    fn from_str(input: \u0026str) -\u003e Result\u003cSelf, Self::Err\u003e {\n        let parts: Vec\u003c\u0026str\u003e = input.split('.').collect();\n        match parts.len() {\n            1 =\u003e {\n                let whole = U256::from_dec_str(parts[0])\n                    .map_err(|_| StdError::generic_err(\"Error parsing whole\"))?;\n\n                let whole_as_atomics = whole * Decimal256::DECIMAL_FRACTIONAL;\n                Ok(Decimal256(whole_as_atomics))\n            }\n            2 =\u003e {\n                let whole = U256::from_dec_str(parts[0])\n                    .map_err(|_| StdError::generic_err(\"Error parsing whole\"))?;\n                let fractional = U256::from_dec_str(parts[1])\n                    .map_err(|_| StdError::generic_err(\"Error parsing fractional\"))?;\n                let exp = (18usize.checked_sub(parts[1].len())).ok_or_else(|| {\n                    StdError::generic_err(\"Cannot parse more than 18 fractional digits\")\n                })?;\n                let fractional_factor = U256::from(10).pow(exp.into());\n\n                let whole_as_atomics = whole * Decimal256::DECIMAL_FRACTIONAL;\n                let atomics = whole_as_atomics + fractional * fractional_factor;\n                Ok(Decimal256(atomics))\n            }\n            _ =\u003e Err(StdError::generic_err(\"Unexpected number of dots\")),\n        }\n    }\n}\n\nimpl fmt::Display for Decimal256 {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        let whole = (self.0) / Decimal256::DECIMAL_FRACTIONAL;\n        let fractional = (self.0) % Decimal256::DECIMAL_FRACTIONAL;\n\n        if fractional.is_zero() {\n            write!(f, \"{}\", whole)\n        } else {\n            let fractional_string = fractional.to_string();\n            let fractional_string = \"0\".repeat(18 - fractional_string.len()) + \u0026fractional_string;\n\n            f.write_str(\u0026whole.to_string())?;\n            f.write_char('.')?;\n            f.write_str(fractional_string.trim_end_matches('0'))?;\n\n            Ok(())\n        }\n    }\n}\n\nimpl ops::Add for Decimal256 {\n    type Output = Self;\n\n    fn add(self, rhs: Self) -\u003e Self {\n        Decimal256(self.0 + rhs.0)\n    }\n}\n\nimpl ops::AddAssign for Decimal256 {\n    fn add_assign(\u0026mut self, rhs: Self) {\n        self.0 = self.0 + rhs.0;\n    }\n}\n\nimpl ops::Sub for Decimal256 {\n    type Output = Self;\n\n    fn sub(self, rhs: Self) -\u003e Self {\n        assert!(self.0 \u003e= rhs.0);\n        Decimal256(self.0 - rhs.0)\n    }\n}\n\nimpl ops::Mul for Decimal256 {\n    type Output = Self;\n\n    fn mul(self, rhs: Self) -\u003e Self {\n        Decimal256(self.0 * rhs.0 / Decimal256::DECIMAL_FRACTIONAL)\n    }\n}\n\nimpl ops::Div for Decimal256 {\n    type Output = Self;\n\n    fn div(self, rhs: Self) -\u003e Self {\n        assert!(!rhs.is_zero());\n\n        Decimal256(self.0 * Decimal256::DECIMAL_FRACTIONAL / rhs.0)\n    }\n}\n\n/// Serializes as a decimal string\nimpl Serialize for Decimal256 {\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: ser::Serializer,\n    {\n        serializer.serialize_str(\u0026self.to_string())\n    }\n}\n\n/// Deserializes as a base64 string\nimpl\u003c'de\u003e Deserialize\u003c'de\u003e for Decimal256 {\n    fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cDecimal256, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        deserializer.deserialize_str(Decimal256Visitor)\n    }\n}\n\nstruct Decimal256Visitor;\n\nimpl\u003c'de\u003e de::Visitor\u003c'de\u003e for Decimal256Visitor {\n    type Value = Decimal256;\n\n    fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        formatter.write_str(\"string-encoded decimal\")\n    }\n\n    fn visit_str\u003cE\u003e(self, v: \u0026str) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: de::Error,\n    {\n        match Decimal256::from_str(v) {\n            Ok(d) =\u003e Ok(d),\n            Err(e) =\u003e Err(E::custom(format!(\"Error parsing decimal '{}': {}\", v, e))),\n        }\n    }\n}\n\n//*** Uint256 ***/\n#[derive(Copy, Clone, Default, Debug, PartialEq, Eq, PartialOrd, Ord, JsonSchema)]\npub struct Uint256(#[schemars(with = \"String\")] pub U256);\n\nimpl Uint256 {\n    /// Creates a Uint256(0)\n    pub const fn zero() -\u003e Self {\n        Uint256(U256([0, 0, 0, 0]))\n    }\n\n    /// Create a 1.0 Decimal256\n    pub const fn one() -\u003e Self {\n        Uint256(U256([1, 0, 0, 0]))\n    }\n\n    pub fn is_zero(\u0026self) -\u003e bool {\n        self.0.is_zero()\n    }\n}\n\nimpl From\u003cU256\u003e for Uint256 {\n    fn from(val: U256) -\u003e Self {\n        Uint256(val)\n    }\n}\n\nimpl From\u003cUint256\u003e for U256 {\n    fn from(val: Uint256) -\u003e Self {\n        val.0\n    }\n}\n\n#[inline(always)]\nfn split_u128(a: u128) -\u003e (u64, u64) {\n    ((a \u003e\u003e 64) as _, (a \u0026 0xFFFFFFFFFFFFFFFF) as _)\n}\n\nimpl From\u003cUint128\u003e for Uint256 {\n    fn from(val: Uint128) -\u003e Self {\n        Uint256::from(val.u128())\n    }\n}\n\nimpl From\u003cu128\u003e for Uint256 {\n    fn from(val: u128) -\u003e Self {\n        let (hi, low) = split_u128(val);\n        Uint256(U256([low, hi, 0, 0]))\n    }\n}\n\nimpl From\u003cu64\u003e for Uint256 {\n    fn from(val: u64) -\u003e Self {\n        Uint256(val.into())\n    }\n}\n\nimpl TryFrom\u003c\u0026str\u003e for Uint256 {\n    type Error = StdError;\n\n    fn try_from(val: \u0026str) -\u003e Result\u003cSelf, Self::Error\u003e {\n        match U256::from_dec_str(val) {\n            Ok(u) =\u003e Ok(Uint256(u)),\n            Err(_e) =\u003e Err(StdError::generic_err(format!(\"invalid Uint256 '{}'\", val))),\n        }\n    }\n}\n\nimpl FromStr for Uint256 {\n    type Err = StdError;\n\n    fn from_str(input: \u0026str) -\u003e Result\u003cSelf, Self::Err\u003e {\n        let number =\n            U256::from_dec_str(input).map_err(|_| StdError::generic_err(\"Error parsing number\"))?;\n        Ok(Uint256(number))\n    }\n}\n\nimpl From\u003cUint256\u003e for String {\n    fn from(n: Uint256) -\u003e Self {\n        n.0.to_string()\n    }\n}\n\nimpl From\u003cUint256\u003e for u128 {\n    fn from(n: Uint256) -\u003e Self {\n        let U256(ref arr) = n.0;\n        assert!(arr[2] == 0u64);\n        assert!(arr[3] == 0u64);\n\n        let (hi, low) = (arr[1], arr[0]);\n        ((hi as u128) \u003c\u003c 64) + (low as u128)\n    }\n}\n\nimpl From\u003cUint256\u003e for Uint128 {\n    fn from(n: Uint256) -\u003e Self {\n        let num: u128 = n.into();\n        Uint128::from(num)\n    }\n}\n\nimpl fmt::Display for Uint256 {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n\nimpl ops::Add for Uint256 {\n    type Output = Self;\n\n    fn add(self, rhs: Self) -\u003e Self {\n        Uint256(self.0 + rhs.0)\n    }\n}\n\nimpl ops::AddAssign for Uint256 {\n    fn add_assign(\u0026mut self, other: Self) {\n        self.0 = self.0 + other.0;\n    }\n}\n\nimpl ops::Sub for Uint256 {\n    type Output = Self;\n\n    fn sub(self, rhs: Self) -\u003e Self::Output {\n        assert!(self.0 \u003e= rhs.0);\n        Uint256(self.0 - rhs.0)\n    }\n}\n\nimpl ops::Mul\u003cUint256\u003e for Uint256 {\n    type Output = Self;\n\n    #[allow(clippy::suspicious_arithmetic_impl)]\n    fn mul(self, rhs: Uint256) -\u003e Self::Output {\n        // 0*a and b*0 is always 0\n        if self.is_zero() || rhs.is_zero() {\n            return Uint256::zero();\n        }\n\n        Uint256(self.0 * rhs.0)\n    }\n}\n\n/// Both d*u and u*d with d: Decimal256 and u: Uint256 returns an Uint256. There is no\n/// specific reason for this decision other than the initial use cases we have. If you\n/// need a Decimal256 result for the same calculation, use Decimal256(d*u) or Decimal256(u*d).\nimpl ops::Mul\u003cDecimal256\u003e for Uint256 {\n    type Output = Self;\n\n    #[allow(clippy::suspicious_arithmetic_impl)]\n    fn mul(self, rhs: Decimal256) -\u003e Self::Output {\n        // 0*a and b*0 is always 0\n        if self.is_zero() || rhs.is_zero() {\n            return Uint256::zero();\n        }\n\n        self.multiply_ratio(rhs.0, Decimal256::DECIMAL_FRACTIONAL)\n    }\n}\n\nimpl ops::Div\u003cDecimal256\u003e for Uint256 {\n    type Output = Self;\n\n    fn div(self, rhs: Decimal256) -\u003e Self::Output {\n        assert!(!rhs.is_zero());\n\n        if self.is_zero() {\n            return Uint256::zero();\n        }\n\n        self.multiply_ratio(Decimal256::DECIMAL_FRACTIONAL, rhs.0)\n    }\n}\n\nimpl ops::Mul\u003cUint256\u003e for Decimal256 {\n    type Output = Uint256;\n\n    fn mul(self, rhs: Uint256) -\u003e Self::Output {\n        rhs * self\n    }\n}\n\nimpl Uint256 {\n    /// returns self * nom / denom\n    pub fn multiply_ratio\u003cA: Into\u003cU256\u003e, B: Into\u003cU256\u003e\u003e(\u0026self, nom: A, denom: B) -\u003e Uint256 {\n        let nominator: U256 = nom.into();\n        let denominator: U256 = denom.into();\n        if denominator.is_zero() {\n            panic!(\"Denominator must not be zero\");\n        }\n\n        // TODO: minimize rounding that takes place (using gcd algorithm)\n        let val = self.0 * nominator / denominator;\n        Uint256::from(val)\n    }\n}\n\n/// Serializes as a base64 string\nimpl Serialize for Uint256 {\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: ser::Serializer,\n    {\n        serializer.serialize_str(\u0026self.to_string())\n    }\n}\n\n/// Deserializes as a base64 string\nimpl\u003c'de\u003e Deserialize\u003c'de\u003e for Uint256 {\n    fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cUint256, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        deserializer.deserialize_str(Uint256Visitor)\n    }\n}\n\nstruct Uint256Visitor;\n\nimpl\u003c'de\u003e de::Visitor\u003c'de\u003e for Uint256Visitor {\n    type Value = Uint256;\n\n    fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        formatter.write_str(\"string-encoded integer\")\n    }\n\n    fn visit_str\u003cE\u003e(self, v: \u0026str) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: de::Error,\n    {\n        match U256::from_dec_str(v) {\n            Ok(u) =\u003e Ok(Uint256(u)),\n            Err(_e) =\u003e Err(E::custom(format!(\"invalid Uint256 '{}'\", v))),\n        }\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n    use cosmwasm_std::{from_slice, to_vec, StdResult};\n    use std::convert::TryInto;\n\n    #[test]\n    fn decimal_one() {\n        let value = Decimal256::one();\n        assert_eq!(value.0, Decimal256::DECIMAL_FRACTIONAL);\n    }\n\n    #[test]\n    fn decimal_zero() {\n        let value = Decimal256::zero();\n        assert_eq!(value.0, U256::zero());\n    }\n\n    #[test]\n    fn decimal_percent() {\n        let value = Decimal256::percent(50);\n        assert_eq!(value.0, Decimal256::DECIMAL_FRACTIONAL / 2.into());\n    }\n\n    #[test]\n    fn decimal_permille() {\n        let value = Decimal256::permille(125);\n        assert_eq!(value.0, Decimal256::DECIMAL_FRACTIONAL / 8.into());\n    }\n\n    #[test]\n    fn decimal_from_ratio_works() {\n        // 1.0\n        assert_eq!(Decimal256::from_ratio(1, 1), Decimal256::one());\n        assert_eq!(Decimal256::from_ratio(53, 53), Decimal256::one());\n        assert_eq!(Decimal256::from_ratio(125, 125), Decimal256::one());\n\n        // 1.5\n        assert_eq!(Decimal256::from_ratio(3, 2), Decimal256::percent(150));\n        assert_eq!(Decimal256::from_ratio(150, 100), Decimal256::percent(150));\n        assert_eq!(Decimal256::from_ratio(333, 222), Decimal256::percent(150));\n\n        // 0.125\n        assert_eq!(Decimal256::from_ratio(1, 8), Decimal256::permille(125));\n        assert_eq!(Decimal256::from_ratio(125, 1000), Decimal256::permille(125));\n\n        // 1/3 (result floored)\n        assert_eq!(\n            Decimal256::from_ratio(1, 3),\n            Decimal256(333_333_333_333_333_333u64.into())\n        );\n\n        // 2/3 (result floored)\n        assert_eq!(\n            Decimal256::from_ratio(2, 3),\n            Decimal256(666_666_666_666_666_666u64.into())\n        );\n    }\n\n    #[test]\n    #[should_panic(expected = \"Denominator must not be zero\")]\n    fn decimal_from_ratio_panics_for_zero_denominator() {\n        Decimal256::from_ratio(1, 0);\n    }\n\n    #[test]\n    fn decimal_from_str_works() {\n        // Integers\n        assert_eq!(Decimal256::from_str(\"\").unwrap(), Decimal256::percent(0));\n        assert_eq!(Decimal256::from_str(\"0\").unwrap(), Decimal256::percent(0));\n        assert_eq!(Decimal256::from_str(\"1\").unwrap(), Decimal256::percent(100));\n        assert_eq!(Decimal256::from_str(\"5\").unwrap(), Decimal256::percent(500));\n        assert_eq!(\n            Decimal256::from_str(\"42\").unwrap(),\n            Decimal256::percent(4200)\n        );\n        assert_eq!(Decimal256::from_str(\"000\").unwrap(), Decimal256::percent(0));\n        assert_eq!(\n            Decimal256::from_str(\"001\").unwrap(),\n            Decimal256::percent(100)\n        );\n        assert_eq!(\n            Decimal256::from_str(\"005\").unwrap(),\n            Decimal256::percent(500)\n        );\n        assert_eq!(\n            Decimal256::from_str(\"0042\").unwrap(),\n            Decimal256::percent(4200)\n        );\n\n        // Decimal256s\n        assert_eq!(\n            Decimal256::from_str(\"1.\").unwrap(),\n            Decimal256::percent(100)\n        );\n        assert_eq!(\n            Decimal256::from_str(\"1.0\").unwrap(),\n            Decimal256::percent(100)\n        );\n        assert_eq!(\n            Decimal256::from_str(\"1.5\").unwrap(),\n            Decimal256::percent(150)\n        );\n        assert_eq!(\n            Decimal256::from_str(\"0.5\").unwrap(),\n            Decimal256::percent(50)\n        );\n        assert_eq!(\n            Decimal256::from_str(\"0.123\").unwrap(),\n            Decimal256::permille(123)\n        );\n\n        assert_eq!(\n            Decimal256::from_str(\"40.00\").unwrap(),\n            Decimal256::percent(4000)\n        );\n        assert_eq!(\n            Decimal256::from_str(\"04.00\").unwrap(),\n            Decimal256::percent(400)\n        );\n        assert_eq!(\n            Decimal256::from_str(\"00.40\").unwrap(),\n            Decimal256::percent(40)\n        );\n        assert_eq!(\n            Decimal256::from_str(\"00.04\").unwrap(),\n            Decimal256::percent(4)\n        );\n\n        // Can handle 18 fractional digits\n        assert_eq!(\n            Decimal256::from_str(\"7.123456789012345678\").unwrap(),\n            Decimal256(7123456789012345678u64.into())\n        );\n        assert_eq!(\n            Decimal256::from_str(\"7.999999999999999999\").unwrap(),\n            Decimal256(7999999999999999999u64.into())\n        );\n\n        // Works for documented max value\n        assert_eq!(\n            Decimal256::from_str(\n                \"115792089237316195423570985008687907853269984665640564039457.584007913129639935\"\n            )\n            .unwrap(),\n            Decimal256::MAX\n        );\n    }\n\n    #[test]\n    fn decimal_from_str_errors_for_broken_whole_part() {\n        match Decimal256::from_str(\" \").unwrap_err() {\n            StdError::GenericErr { msg, .. } =\u003e assert_eq!(msg, \"Error parsing whole\"),\n            e =\u003e panic!(\"Unexpected error: {:?}\", e),\n        }\n\n        match Decimal256::from_str(\"-1\").unwrap_err() {\n            StdError::GenericErr { msg, .. } =\u003e assert_eq!(msg, \"Error parsing whole\"),\n            e =\u003e panic!(\"Unexpected error: {:?}\", e),\n        }\n    }\n\n    #[test]\n    fn decimal_from_str_errors_for_broken_fractinal_part() {\n        match Decimal256::from_str(\"1. \").unwrap_err() {\n            StdError::GenericErr { msg, .. } =\u003e assert_eq!(msg, \"Error parsing fractional\"),\n            e =\u003e panic!(\"Unexpected error: {:?}\", e),\n        }\n\n        match Decimal256::from_str(\"1.e\").unwrap_err() {\n            StdError::GenericErr { msg, .. } =\u003e assert_eq!(msg, \"Error parsing fractional\"),\n            e =\u003e panic!(\"Unexpected error: {:?}\", e),\n        }\n\n        match Decimal256::from_str(\"1.2e3\").unwrap_err() {\n            StdError::GenericErr { msg, .. } =\u003e assert_eq!(msg, \"Error parsing fractional\"),\n            e =\u003e panic!(\"Unexpected error: {:?}\", e),\n        }\n    }\n\n    #[test]\n    fn decimal_from_str_errors_for_more_than_18_fractional_digits() {\n        match Decimal256::from_str(\"7.1234567890123456789\").unwrap_err() {\n            StdError::GenericErr { msg, .. } =\u003e {\n                assert_eq!(msg, \"Cannot parse more than 18 fractional digits\")\n            }\n            e =\u003e panic!(\"Unexpected error: {:?}\", e),\n        }\n\n        // No special rules for trailing zeros. This could be changed but adds gas cost for the happy path.\n        match Decimal256::from_str(\"7.1230000000000000000\").unwrap_err() {\n            StdError::GenericErr { msg, .. } =\u003e {\n                assert_eq!(msg, \"Cannot parse more than 18 fractional digits\")\n            }\n            e =\u003e panic!(\"Unexpected error: {:?}\", e),\n        }\n    }\n\n    #[test]\n    fn decimal_from_str_errors_for_invalid_number_of_dots() {\n        match Decimal256::from_str(\"1.2.3\").unwrap_err() {\n            StdError::GenericErr { msg, .. } =\u003e assert_eq!(msg, \"Unexpected number of dots\"),\n            e =\u003e panic!(\"Unexpected error: {:?}\", e),\n        }\n\n        match Decimal256::from_str(\"1.2.3.4\").unwrap_err() {\n            StdError::GenericErr { msg, .. } =\u003e assert_eq!(msg, \"Unexpected number of dots\"),\n            e =\u003e panic!(\"Unexpected error: {:?}\", e),\n        }\n    }\n\n    #[test]\n    #[should_panic(expected = \"arithmetic operation overflow\")]\n    fn decimal_from_str_errors_for_more_than_max_value_integer_part() {\n        let _ =\n            Decimal256::from_str(\"115792089237316195423570985008687907853269984665640564039458\");\n    }\n\n    #[test]\n    #[should_panic(expected = \"arithmetic operation overflow\")]\n    fn decimal_from_str_errors_for_more_than_max_value_integer_part_with_decimal() {\n        let _ =\n            Decimal256::from_str(\"115792089237316195423570985008687907853269984665640564039458.0\");\n    }\n    #[test]\n    #[should_panic(expected = \"arithmetic operation overflow\")]\n    fn decimal_from_str_errors_for_more_than_max_value_decimal_part() {\n        let _ = Decimal256::from_str(\n            \"115792089237316195423570985008687907853269984665640564039457.584007913129639936\",\n        );\n    }\n\n    #[test]\n    fn decimal_is_zero_works() {\n        assert!(Decimal256::zero().is_zero());\n        assert!(Decimal256::percent(0).is_zero());\n        assert!(Decimal256::permille(0).is_zero());\n\n        assert!(!Decimal256::one().is_zero());\n        assert!(!Decimal256::percent(123).is_zero());\n        assert!(!Decimal256::permille(1234).is_zero());\n    }\n\n    #[test]\n    fn decimal_add() {\n        let value = Decimal256::one() + Decimal256::percent(50); // 1.5\n        assert_eq!(\n            value.0,\n            Decimal256::DECIMAL_FRACTIONAL * U256::from(3) / U256::from(2)\n        );\n    }\n\n    #[test]\n    fn decimal_sub() {\n        assert_eq!(\n            Decimal256::percent(50),\n            Decimal256::one() - Decimal256::percent(50)\n        );\n    }\n\n    #[test]\n    fn decimal_mul() {\n        assert_eq!(\n            Decimal256::percent(25),\n            Decimal256::percent(50) * Decimal256::percent(50)\n        );\n    }\n\n    #[test]\n    fn decimal_div() {\n        assert_eq!(\n            Decimal256::one() + Decimal256::one(),\n            Decimal256::percent(50) / Decimal256::percent(25)\n        );\n    }\n\n    #[test]\n    fn decimal_to_string() {\n        // Integers\n        assert_eq!(Decimal256::zero().to_string(), \"0\");\n        assert_eq!(Decimal256::one().to_string(), \"1\");\n        assert_eq!(Decimal256::percent(500).to_string(), \"5\");\n\n        // Decimal256s\n        assert_eq!(Decimal256::percent(125).to_string(), \"1.25\");\n        assert_eq!(Decimal256::percent(42638).to_string(), \"426.38\");\n        assert_eq!(Decimal256::percent(1).to_string(), \"0.01\");\n        assert_eq!(Decimal256::permille(987).to_string(), \"0.987\");\n\n        assert_eq!(Decimal256(1u64.into()).to_string(), \"0.000000000000000001\");\n        assert_eq!(Decimal256(10u64.into()).to_string(), \"0.00000000000000001\");\n        assert_eq!(Decimal256(100u64.into()).to_string(), \"0.0000000000000001\");\n        assert_eq!(Decimal256(1000u64.into()).to_string(), \"0.000000000000001\");\n        assert_eq!(Decimal256(10000u64.into()).to_string(), \"0.00000000000001\");\n        assert_eq!(Decimal256(100000u64.into()).to_string(), \"0.0000000000001\");\n        assert_eq!(Decimal256(1000000u64.into()).to_string(), \"0.000000000001\");\n        assert_eq!(Decimal256(10000000u64.into()).to_string(), \"0.00000000001\");\n        assert_eq!(Decimal256(100000000u64.into()).to_string(), \"0.0000000001\");\n        assert_eq!(Decimal256(1000000000u64.into()).to_string(), \"0.000000001\");\n        assert_eq!(Decimal256(10000000000u64.into()).to_string(), \"0.00000001\");\n        assert_eq!(Decimal256(100000000000u64.into()).to_string(), \"0.0000001\");\n        assert_eq!(Decimal256(10000000000000u64.into()).to_string(), \"0.00001\");\n        assert_eq!(Decimal256(100000000000000u64.into()).to_string(), \"0.0001\");\n        assert_eq!(Decimal256(1000000000000000u64.into()).to_string(), \"0.001\");\n        assert_eq!(Decimal256(10000000000000000u64.into()).to_string(), \"0.01\");\n        assert_eq!(Decimal256(100000000000000000u64.into()).to_string(), \"0.1\");\n    }\n\n    #[test]\n    fn decimal_serialize() {\n        assert_eq!(to_vec(\u0026Decimal256::zero()).unwrap(), br#\"\"0\"\"#);\n        assert_eq!(to_vec(\u0026Decimal256::one()).unwrap(), br#\"\"1\"\"#);\n        assert_eq!(to_vec(\u0026Decimal256::percent(8)).unwrap(), br#\"\"0.08\"\"#);\n        assert_eq!(to_vec(\u0026Decimal256::percent(87)).unwrap(), br#\"\"0.87\"\"#);\n        assert_eq!(to_vec(\u0026Decimal256::percent(876)).unwrap(), br#\"\"8.76\"\"#);\n        assert_eq!(to_vec(\u0026Decimal256::percent(8765)).unwrap(), br#\"\"87.65\"\"#);\n    }\n\n    #[test]\n    fn decimal_deserialize() {\n        assert_eq!(\n            from_slice::\u003cDecimal256\u003e(br#\"\"0\"\"#).unwrap(),\n            Decimal256::zero()\n        );\n        assert_eq!(\n            from_slice::\u003cDecimal256\u003e(br#\"\"1\"\"#).unwrap(),\n            Decimal256::one()\n        );\n        assert_eq!(\n            from_slice::\u003cDecimal256\u003e(br#\"\"000\"\"#).unwrap(),\n            Decimal256::zero()\n        );\n        assert_eq!(\n            from_slice::\u003cDecimal256\u003e(br#\"\"001\"\"#).unwrap(),\n            Decimal256::one()\n        );\n\n        assert_eq!(\n            from_slice::\u003cDecimal256\u003e(br#\"\"0.08\"\"#).unwrap(),\n            Decimal256::percent(8)\n        );\n        assert_eq!(\n            from_slice::\u003cDecimal256\u003e(br#\"\"0.87\"\"#).unwrap(),\n            Decimal256::percent(87)\n        );\n        assert_eq!(\n            from_slice::\u003cDecimal256\u003e(br#\"\"8.76\"\"#).unwrap(),\n            Decimal256::percent(876)\n        );\n        assert_eq!(\n            from_slice::\u003cDecimal256\u003e(br#\"\"87.65\"\"#).unwrap(),\n            Decimal256::percent(8765)\n        );\n    }\n\n    #[test]\n    fn to_and_from_uint256() {\n        let a: Uint256 = 12345u64.into();\n        assert_eq!(U256::from(12345), a.0);\n        assert_eq!(\"12345\", a.to_string());\n\n        let a: Uint256 = \"34567\".try_into().unwrap();\n        assert_eq!(U256::from(34567), a.0);\n        assert_eq!(\"34567\", a.to_string());\n\n        let a: StdResult\u003cUint256\u003e = \"1.23\".try_into();\n        assert!(a.is_err());\n    }\n\n    #[test]\n    fn uint256_is_zero_works() {\n        assert!(Uint256::zero().is_zero());\n        assert!(Uint256::from(0u64).is_zero());\n\n        assert!(!Uint256::from(1u64).is_zero());\n        assert!(!Uint256::from(123u64).is_zero());\n    }\n\n    #[test]\n    fn uint256_json() {\n        let orig = Uint256::from(1234567890987654321u64);\n        let serialized = to_vec(\u0026orig).unwrap();\n        assert_eq!(serialized.as_slice(), b\"\\\"1234567890987654321\\\"\");\n        let parsed: Uint256 = from_slice(\u0026serialized).unwrap();\n        assert_eq!(parsed, orig);\n    }\n\n    #[test]\n    fn uint256_compare() {\n        let a = Uint256::from(12345u64);\n        let b = Uint256::from(23456u64);\n\n        assert!(a \u003c b);\n        assert!(b \u003e a);\n        assert_eq!(a, Uint256::from(12345u64));\n    }\n\n    #[test]\n    fn uint256_math() {\n        let a = Uint256::from(12345u64);\n        let b = Uint256::from(23456u64);\n\n        // test + and - for valid values\n        assert_eq!(a + b, Uint256::from(35801u64));\n        assert_eq!(b - a, Uint256::from(11111u64));\n\n        // test +=\n        let mut c = Uint256::from(300000u64);\n        c += b;\n        assert_eq!(c, Uint256::from(323456u64));\n    }\n    #[test]\n    #[should_panic]\n    fn uint256_math_sub_underflow() {\n        let _ = Uint256::from(12345u64) - Uint256::from(23456u64);\n    }\n\n    #[test]\n    #[should_panic]\n    fn uint256_math_overflow_panics() {\n        // almost_max is 2^256 - 10\n        let almost_max = Uint256::from(U256([\n            18446744073709551615,\n            18446744073709551615,\n            18446744073709551615,\n            18446744073709551615,\n        ]));\n        let _ = almost_max + Uint256::from(12u64);\n    }\n\n    #[test]\n    // in this test the Decimal256 is on the right\n    fn uint256_decimal_multiply() {\n        // a*b\n        let left = Uint256::from(300u64);\n        let right = Decimal256::one() + Decimal256::percent(50); // 1.5\n        assert_eq!(left * right, Uint256::from(450u64));\n\n        // a*0\n        let left = Uint256::from(300u64);\n        let right = Decimal256::zero();\n        assert_eq!(left * right, Uint256::from(0u64));\n\n        // 0*a\n        let left = Uint256::zero();\n        let right = Decimal256::one() + Decimal256::percent(50); // 1.5\n        assert_eq!(left * right, Uint256::zero());\n    }\n\n    #[test]\n    fn u256_multiply_ratio_works() {\n        let base = Uint256::from(500u64);\n\n        // factor 1/1\n        assert_eq!(base.multiply_ratio(1, 1), Uint256::from(500u64));\n        assert_eq!(base.multiply_ratio(3, 3), Uint256::from(500u64));\n        assert_eq!(base.multiply_ratio(654321, 654321), Uint256::from(500u64));\n\n        // factor 3/2\n        assert_eq!(base.multiply_ratio(3, 2), Uint256::from(750u64));\n        assert_eq!(base.multiply_ratio(333333, 222222), Uint256::from(750u64));\n\n        // factor 2/3 (integer devision always floors the result)\n        assert_eq!(base.multiply_ratio(2, 3), Uint256::from(333u64));\n        assert_eq!(base.multiply_ratio(222222, 333333), Uint256::from(333u64));\n\n        // factor 5/6 (integer devision always floors the result)\n        assert_eq!(base.multiply_ratio(5, 6), Uint256::from(416u64));\n        assert_eq!(base.multiply_ratio(100, 120), Uint256::from(416u64));\n    }\n\n    #[test]\n    fn u256_from_u128() {\n        assert_eq!(Uint256::from(100u64), Uint256::from(100u128));\n        let num = Uint256::from(1_000_000_000_000_000_000_000_000u128);\n        assert_eq!(num.to_string(), \"1000000000000000000000000\");\n    }\n\n    #[test]\n    #[should_panic(expected = \"Denominator must not be zero\")]\n    fn u256_multiply_ratio_panics_for_zero_denominator() {\n        Uint256::from(500u64).multiply_ratio(1, 0);\n    }\n\n    #[test]\n    fn u256_zero_one() {\n        assert_eq!(Uint256::zero().0, U256::zero());\n        assert_eq!(Uint256::one().0, U256::one());\n    }\n\n    #[test]\n    fn u256_into_u128() {\n        let val: u128 = Uint256::from(1234556700000000000999u128).into();\n        assert_eq!(val, 1234556700000000000999u128);\n    }\n\n    #[test]\n    #[should_panic]\n    fn u256_into_u128_panics_for_overflow() {\n        let _: u128 = Uint256::from_str(\"2134982317498312749832174923184732198471983247\")\n            .unwrap()\n            .into();\n    }\n\n    #[test]\n    // in this test the Decimal256 is on the left\n    fn decimal_uint256_multiply() {\n        // a*b\n        let left = Decimal256::one() + Decimal256::percent(50); // 1.5\n        let right = Uint256::from(300u64);\n        assert_eq!(left * right, Uint256::from(450u64));\n\n        // 0*a\n        let left = Decimal256::zero();\n        let right = Uint256::from(300u64);\n        assert_eq!(left * right, Uint256::from(0u64));\n\n        // a*0\n        let left = Decimal256::one() + Decimal256::percent(50); // 1.5\n        let right = Uint256::from(0u64);\n        assert_eq!(left * right, Uint256::from(0u64));\n    }\n}\n","traces":[{"line":21,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":47},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":47},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":43},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":43},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":43},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":43},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":48},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":84},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":84},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":81},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":90},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":37},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":37},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":37},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":37},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":53},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":53},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":68},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":68},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":70},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":70},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":67},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":67},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":70},"fn_name":null},{"line":260,"address":[],"length":0,"stats":{"Line":70},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":70},"fn_name":null},{"line":266,"address":[],"length":0,"stats":{"Line":39},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":39},"fn_name":null},{"line":274,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":275,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":285,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":286,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":287,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":288,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":293,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":294,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":299,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":300,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":302,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":304,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":305,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":310,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":311,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":312,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":317,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":318,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":325,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":326,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":331,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":332,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":339,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":340,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":341,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":349,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":350,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":351,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":352,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":355,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":366,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":367,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":368,"address":[],"length":0,"stats":{"Line":55},"fn_name":null},{"line":369,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":372,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":379,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":380,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":382,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":383,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":386,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":393,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":394,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":400,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":401,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":402,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":403,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":404,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":407,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":408,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":409,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":415,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":419,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":425,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":429,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":438,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":439,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":442,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":446,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":447,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":448,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":142,"coverable":159},{"path":["/","Users","haitran","AURA-NETWORK","smart-contracts-halotrade-zone","packages","haloswap","examples","schema.rs"],"content":"use std::env::current_dir;\nuse std::fs::create_dir_all;\n\nuse cosmwasm_schema::{export_schema, remove_schemas, schema_for};\n\nuse haloswap::asset::{Asset, AssetInfo, PairInfo};\n\nfn main() {\n    let mut out_dir = current_dir().unwrap();\n    out_dir.push(\"schema\");\n    create_dir_all(\u0026out_dir).unwrap();\n    remove_schemas(\u0026out_dir).unwrap();\n\n    export_schema(\u0026schema_for!(PairInfo), \u0026out_dir);\n    export_schema(\u0026schema_for!(Asset), \u0026out_dir);\n    export_schema(\u0026schema_for!(AssetInfo), \u0026out_dir);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","haitran","AURA-NETWORK","smart-contracts-halotrade-zone","packages","haloswap","src","asset.rs"],"content":"use cosmwasm_schema::cw_serde;\nuse std::fmt;\n\nuse crate::querier::{query_balance, query_native_decimals, query_token_balance, query_token_info};\nuse cosmwasm_std::{\n    to_binary, Addr, Api, BankMsg, CanonicalAddr, Coin, CosmosMsg, MessageInfo, QuerierWrapper,\n    StdError, StdResult, SubMsg, Uint128, WasmMsg,\n};\nuse cw20::Cw20ExecuteMsg;\n\n#[cw_serde]\npub struct Asset {\n    pub info: AssetInfo,\n    pub amount: Uint128,\n}\n\nimpl fmt::Display for Asset {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        write!(f, \"{}{}\", self.amount, self.info)\n    }\n}\n\nimpl Asset {\n    pub fn is_native_token(\u0026self) -\u003e bool {\n        self.info.is_native_token()\n    }\n\n    pub fn into_msg(self, recipient: Addr) -\u003e StdResult\u003cCosmosMsg\u003e {\n        let amount = self.amount;\n\n        match \u0026self.info {\n            AssetInfo::Token { contract_addr } =\u003e Ok(CosmosMsg::Wasm(WasmMsg::Execute {\n                contract_addr: contract_addr.to_string(),\n                msg: to_binary(\u0026Cw20ExecuteMsg::Transfer {\n                    recipient: recipient.to_string(),\n                    amount,\n                })?,\n                funds: vec![],\n            })),\n            AssetInfo::NativeToken { denom } =\u003e Ok(CosmosMsg::Bank(BankMsg::Send {\n                to_address: recipient.to_string(),\n                amount: vec![Coin {\n                    amount: self.amount,\n                    denom: denom.to_string(),\n                }],\n            })),\n        }\n    }\n\n    pub fn into_submsg(self, recipient: Addr) -\u003e StdResult\u003cSubMsg\u003e {\n        Ok(SubMsg::new(self.into_msg(recipient)?))\n    }\n\n    pub fn assert_sent_native_token_balance(\u0026self, message_info: \u0026MessageInfo) -\u003e StdResult\u003c()\u003e {\n        if let AssetInfo::NativeToken { denom } = \u0026self.info {\n            match message_info.funds.iter().find(|x| x.denom == *denom) {\n                Some(coin) =\u003e {\n                    if self.amount == coin.amount {\n                        Ok(())\n                    } else {\n                        Err(StdError::generic_err(\"Native token balance mismatch between the argument and the transferred\"))\n                    }\n                }\n                None =\u003e {\n                    if self.amount.is_zero() {\n                        Ok(())\n                    } else {\n                        Err(StdError::generic_err(\"Native token balance mismatch between the argument and the transferred\"))\n                    }\n                }\n            }\n        } else {\n            Ok(())\n        }\n    }\n\n    pub fn to_raw(\u0026self, api: \u0026dyn Api) -\u003e StdResult\u003cAssetRaw\u003e {\n        Ok(AssetRaw {\n            info: match \u0026self.info {\n                AssetInfo::NativeToken { denom } =\u003e AssetInfoRaw::NativeToken {\n                    denom: denom.to_string(),\n                },\n                AssetInfo::Token { contract_addr } =\u003e AssetInfoRaw::Token {\n                    contract_addr: api.addr_canonicalize(contract_addr.as_str())?,\n                },\n            },\n            amount: self.amount,\n        })\n    }\n}\n\n#[cw_serde]\npub struct CreatePairRequirements {\n    pub whitelist: Vec\u003cAddr\u003e,\n    pub first_asset_minimum: Uint128,\n    pub second_asset_minimum: Uint128,\n}\n\n/// AssetInfo contract_addr is usually passed from the cw20 hook\n/// so we can trust the contract_addr is properly validated.\n#[cw_serde]\npub enum AssetInfo {\n    Token { contract_addr: String },\n    NativeToken { denom: String },\n}\n\nimpl fmt::Display for AssetInfo {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        match self {\n            AssetInfo::NativeToken { denom } =\u003e write!(f, \"{}\", denom),\n            AssetInfo::Token { contract_addr } =\u003e write!(f, \"{}\", contract_addr),\n        }\n    }\n}\n\nimpl AssetInfo {\n    pub fn to_raw(\u0026self, api: \u0026dyn Api) -\u003e StdResult\u003cAssetInfoRaw\u003e {\n        match self {\n            AssetInfo::NativeToken { denom } =\u003e Ok(AssetInfoRaw::NativeToken {\n                denom: denom.to_string(),\n            }),\n            AssetInfo::Token { contract_addr } =\u003e Ok(AssetInfoRaw::Token {\n                contract_addr: api.addr_canonicalize(contract_addr.as_str())?,\n            }),\n        }\n    }\n\n    pub fn is_native_token(\u0026self) -\u003e bool {\n        match self {\n            AssetInfo::NativeToken { .. } =\u003e true,\n            AssetInfo::Token { .. } =\u003e false,\n        }\n    }\n    pub fn query_pool(\n        \u0026self,\n        querier: \u0026QuerierWrapper,\n        api: \u0026dyn Api,\n        pool_addr: Addr,\n    ) -\u003e StdResult\u003cUint128\u003e {\n        match self {\n            AssetInfo::Token { contract_addr, .. } =\u003e query_token_balance(\n                querier,\n                api.addr_validate(contract_addr.as_str())?,\n                pool_addr,\n            ),\n            AssetInfo::NativeToken { denom, .. } =\u003e {\n                query_balance(querier, pool_addr, denom.to_string())\n            }\n        }\n    }\n\n    pub fn equal(\u0026self, asset: \u0026AssetInfo) -\u003e bool {\n        match self {\n            AssetInfo::Token { contract_addr, .. } =\u003e {\n                let self_contract_addr = contract_addr;\n                match asset {\n                    AssetInfo::Token { contract_addr, .. } =\u003e self_contract_addr == contract_addr,\n                    AssetInfo::NativeToken { .. } =\u003e false,\n                }\n            }\n            AssetInfo::NativeToken { denom, .. } =\u003e {\n                let self_denom = denom;\n                match asset {\n                    AssetInfo::Token { .. } =\u003e false,\n                    AssetInfo::NativeToken { denom, .. } =\u003e self_denom == denom,\n                }\n            }\n        }\n    }\n\n    pub fn query_decimals(\u0026self, account_addr: Addr, querier: \u0026QuerierWrapper) -\u003e StdResult\u003cu8\u003e {\n        match self {\n            AssetInfo::NativeToken { denom } =\u003e {\n                query_native_decimals(querier, account_addr, denom.to_string())\n            }\n            AssetInfo::Token { contract_addr } =\u003e {\n                let token_info = query_token_info(querier, Addr::unchecked(contract_addr))?;\n                Ok(token_info.decimals)\n            }\n        }\n    }\n}\n\n#[cw_serde]\npub struct AssetRaw {\n    pub info: AssetInfoRaw,\n    pub amount: Uint128,\n}\n\nimpl AssetRaw {\n    pub fn to_normal(\u0026self, api: \u0026dyn Api) -\u003e StdResult\u003cAsset\u003e {\n        Ok(Asset {\n            info: match \u0026self.info {\n                AssetInfoRaw::NativeToken { denom } =\u003e AssetInfo::NativeToken {\n                    denom: denom.to_string(),\n                },\n                AssetInfoRaw::Token { contract_addr } =\u003e AssetInfo::Token {\n                    contract_addr: api.addr_humanize(contract_addr)?.to_string(),\n                },\n            },\n            amount: self.amount,\n        })\n    }\n}\n\n#[cw_serde]\npub enum AssetInfoRaw {\n    Token { contract_addr: CanonicalAddr },\n    NativeToken { denom: String },\n}\n\nimpl AssetInfoRaw {\n    pub fn to_normal(\u0026self, api: \u0026dyn Api) -\u003e StdResult\u003cAssetInfo\u003e {\n        match self {\n            AssetInfoRaw::NativeToken { denom } =\u003e Ok(AssetInfo::NativeToken {\n                denom: denom.to_string(),\n            }),\n            AssetInfoRaw::Token { contract_addr } =\u003e Ok(AssetInfo::Token {\n                contract_addr: api.addr_humanize(contract_addr)?.to_string(),\n            }),\n        }\n    }\n\n    pub fn as_bytes(\u0026self) -\u003e \u0026[u8] {\n        match self {\n            AssetInfoRaw::NativeToken { denom } =\u003e denom.as_bytes(),\n            AssetInfoRaw::Token { contract_addr } =\u003e contract_addr.as_slice(),\n        }\n    }\n\n    pub fn equal(\u0026self, asset: \u0026AssetInfoRaw) -\u003e bool {\n        match self {\n            AssetInfoRaw::Token { contract_addr, .. } =\u003e {\n                let self_contract_addr = contract_addr;\n                match asset {\n                    AssetInfoRaw::Token { contract_addr, .. } =\u003e {\n                        self_contract_addr == contract_addr\n                    }\n                    AssetInfoRaw::NativeToken { .. } =\u003e false,\n                }\n            }\n            AssetInfoRaw::NativeToken { denom, .. } =\u003e {\n                let self_denom = denom;\n                match asset {\n                    AssetInfoRaw::Token { .. } =\u003e false,\n                    AssetInfoRaw::NativeToken { denom, .. } =\u003e self_denom == denom,\n                }\n            }\n        }\n    }\n}\n\n// We define a custom struct for each query response\n#[cw_serde]\npub struct PairInfo {\n    pub asset_infos: [AssetInfo; 2],\n    pub contract_addr: String,\n    pub liquidity_token: String,\n    pub asset_decimals: [u8; 2],\n    pub requirements: CreatePairRequirements,\n}\n\n#[cw_serde]\npub struct PairInfoRaw {\n    pub asset_infos: [AssetInfoRaw; 2],\n    pub contract_addr: CanonicalAddr,\n    pub liquidity_token: CanonicalAddr,\n    pub asset_decimals: [u8; 2],\n    pub requirements: CreatePairRequirements,\n}\n\nimpl PairInfoRaw {\n    pub fn to_normal(\u0026self, api: \u0026dyn Api) -\u003e StdResult\u003cPairInfo\u003e {\n        Ok(PairInfo {\n            liquidity_token: api.addr_humanize(\u0026self.liquidity_token)?.to_string(),\n            contract_addr: api.addr_humanize(\u0026self.contract_addr)?.to_string(),\n            asset_infos: [\n                self.asset_infos[0].to_normal(api)?,\n                self.asset_infos[1].to_normal(api)?,\n            ],\n            asset_decimals: self.asset_decimals,\n            requirements: self.requirements.clone(),\n        })\n    }\n\n    pub fn query_pools(\n        \u0026self,\n        querier: \u0026QuerierWrapper,\n        api: \u0026dyn Api,\n        contract_addr: Addr,\n    ) -\u003e StdResult\u003c[Asset; 2]\u003e {\n        let info_0: AssetInfo = self.asset_infos[0].to_normal(api)?;\n        let info_1: AssetInfo = self.asset_infos[1].to_normal(api)?;\n        Ok([\n            Asset {\n                amount: info_0.query_pool(querier, api, contract_addr.clone())?,\n                info: info_0,\n            },\n            Asset {\n                amount: info_1.query_pool(querier, api, contract_addr)?,\n                info: info_1,\n            },\n        ])\n    }\n}\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":64},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":64},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":34},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":39},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":39},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":38},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":273,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":274,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":275,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":278,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":279,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":281,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":282,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":286,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":292,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":293,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":296,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":297,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":299,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":300,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":16},"fn_name":null}],"covered":125,"coverable":126},{"path":["/","Users","haitran","AURA-NETWORK","smart-contracts-halotrade-zone","packages","haloswap","src","factory.rs"],"content":"use cosmwasm_schema::{cw_serde, QueryResponses};\n\nuse crate::asset::{AssetInfo, PairInfo, CreatePairRequirements};\n\n#[cw_serde]\npub struct InstantiateMsg {\n    /// Pair contract code ID, which is used to\n    pub pair_code_id: u64,\n    pub token_code_id: u64,\n}\n\n#[cw_serde]\npub enum ExecuteMsg {\n    /// UpdateConfig update relevant code IDs\n    UpdateConfig {\n        owner: Option\u003cString\u003e,\n        token_code_id: Option\u003cu64\u003e,\n        pair_code_id: Option\u003cu64\u003e,\n    },\n    /// CreatePair instantiates pair contract\n    CreatePair {\n        /// Asset infos\n        asset_infos: [AssetInfo; 2],\n        /// The requiments to create a pair\n        requirements: CreatePairRequirements,\n    },\n    AddNativeTokenDecimals {\n        denom: String,\n        decimals: u8,\n    },\n    MigratePair {\n        contract: String,\n        code_id: Option\u003cu64\u003e,\n    },\n}\n\n#[cw_serde]\n#[derive(QueryResponses)]\npub enum QueryMsg {\n    #[returns(ConfigResponse)]\n    Config {},\n    #[returns(PairInfo)]\n    Pair {\n        asset_infos: [AssetInfo; 2],\n    },\n    #[returns(PairsResponse)]\n    Pairs {\n        start_after: Option\u003c[AssetInfo; 2]\u003e,\n        limit: Option\u003cu32\u003e,\n    },\n    #[returns(NativeTokenDecimalsResponse)]\n    NativeTokenDecimals {\n        denom: String,\n    },\n}\n\n// We define a custom struct for each query response\n#[cw_serde]\npub struct ConfigResponse {\n    pub owner: String,\n    pub pair_code_id: u64,\n    pub token_code_id: u64,\n}\n\n/// We currently take no arguments for migrations\n#[cw_serde]\npub struct MigrateMsg {}\n\n// We define a custom struct for each query response\n#[cw_serde]\npub struct PairsResponse {\n    pub pairs: Vec\u003cPairInfo\u003e,\n}\n\n#[cw_serde]\npub struct NativeTokenDecimalsResponse {\n    pub decimals: u8,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","haitran","AURA-NETWORK","smart-contracts-halotrade-zone","packages","haloswap","src","lib.rs"],"content":"pub mod asset;\npub mod factory;\npub mod pair;\npub mod querier;\npub mod router;\npub mod token;\n\n#[cfg(not(target_arch = \"wasm32\"))]\npub mod mock_querier;\n\n#[cfg(test)]\nmod testing;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","haitran","AURA-NETWORK","smart-contracts-halotrade-zone","packages","haloswap","src","mock_querier.rs"],"content":"use cosmwasm_std::testing::{MockApi, MockQuerier, MockStorage, MOCK_CONTRACT_ADDR};\nuse cosmwasm_std::{\n    from_binary, from_slice, to_binary, Coin, ContractResult, Empty, OwnedDeps, Querier,\n    QuerierResult, QueryRequest, SystemError, SystemResult, Uint128, WasmQuery, Addr,\n};\nuse std::collections::HashMap;\nuse std::marker::PhantomData;\nuse std::panic;\n\nuse crate::asset::{AssetInfo, PairInfo, CreatePairRequirements};\nuse crate::factory::{NativeTokenDecimalsResponse, QueryMsg as FactoryQueryMsg};\nuse crate::pair::QueryMsg as PairQueryMsg;\nuse crate::pair::{ReverseSimulationResponse, SimulationResponse};\nuse cw20::{BalanceResponse as Cw20BalanceResponse, Cw20QueryMsg, TokenInfoResponse};\n\nuse std::iter::FromIterator;\n\n/// mock_dependencies is a drop-in replacement for cosmwasm_std::testing::mock_dependencies\n/// this uses our CustomQuerier.\npub fn mock_dependencies(\n    contract_balance: \u0026[Coin],\n) -\u003e OwnedDeps\u003cMockStorage, MockApi, WasmMockQuerier\u003e {\n    let custom_querier: WasmMockQuerier =\n        WasmMockQuerier::new(MockQuerier::new(\u0026[(MOCK_CONTRACT_ADDR, contract_balance)]));\n\n    OwnedDeps {\n        storage: MockStorage::default(),\n        api: MockApi::default(),\n        querier: custom_querier,\n        custom_query_type: PhantomData,\n    }\n}\n\npub struct WasmMockQuerier {\n    base: MockQuerier,\n    token_querier: TokenQuerier,\n    halo_factory_querier: HaloFactoryQuerier,\n}\n\n#[derive(Clone, Default)]\npub struct TokenQuerier {\n    // this lets us iterate over all pairs that match the first string\n    balances: HashMap\u003cString, HashMap\u003cString, Uint128\u003e\u003e,\n}\n\nimpl TokenQuerier {\n    pub fn new(balances: \u0026[(\u0026String, \u0026[(\u0026String, \u0026Uint128)])]) -\u003e Self {\n        TokenQuerier {\n            balances: balances_to_map(balances),\n        }\n    }\n}\n\npub(crate) fn balances_to_map(\n    balances: \u0026[(\u0026String, \u0026[(\u0026String, \u0026Uint128)])],\n) -\u003e HashMap\u003cString, HashMap\u003cString, Uint128\u003e\u003e {\n    let mut balances_map: HashMap\u003cString, HashMap\u003cString, Uint128\u003e\u003e = HashMap::new();\n    for (contract_addr, balances) in balances.iter() {\n        let mut contract_balances_map: HashMap\u003cString, Uint128\u003e = HashMap::new();\n        for (addr, balance) in balances.iter() {\n            contract_balances_map.insert(addr.to_string(), **balance);\n        }\n\n        balances_map.insert(contract_addr.to_string(), contract_balances_map);\n    }\n    balances_map\n}\n\n#[derive(Clone, Default)]\npub struct HaloFactoryQuerier {\n    pairs: HashMap\u003cString, PairInfo\u003e,\n    native_token_decimals: HashMap\u003cString, u8\u003e,\n}\n\nimpl HaloFactoryQuerier {\n    pub fn new(pairs: \u0026[(\u0026String, \u0026PairInfo)], native_token_decimals: \u0026[(String, u8)]) -\u003e Self {\n        HaloFactoryQuerier {\n            pairs: pairs_to_map(pairs),\n            native_token_decimals: native_token_decimals_to_map(native_token_decimals),\n        }\n    }\n}\n\npub(crate) fn pairs_to_map(pairs: \u0026[(\u0026String, \u0026PairInfo)]) -\u003e HashMap\u003cString, PairInfo\u003e {\n    let mut pairs_map: HashMap\u003cString, PairInfo\u003e = HashMap::new();\n    for (key, pair) in pairs.iter() {\n        let mut sort_key: Vec\u003cchar\u003e = key.chars().collect();\n        sort_key.sort_by(|a, b| b.cmp(a));\n        pairs_map.insert(String::from_iter(sort_key.iter()), (**pair).clone());\n    }\n    pairs_map\n}\n\npub(crate) fn native_token_decimals_to_map(\n    native_token_decimals: \u0026[(String, u8)],\n) -\u003e HashMap\u003cString, u8\u003e {\n    let mut native_token_decimals_map: HashMap\u003cString, u8\u003e = HashMap::new();\n\n    for (denom, decimals) in native_token_decimals.iter() {\n        native_token_decimals_map.insert(denom.to_string(), *decimals);\n    }\n    native_token_decimals_map\n}\n\nimpl Querier for WasmMockQuerier {\n    fn raw_query(\u0026self, bin_request: \u0026[u8]) -\u003e QuerierResult {\n        // MockQuerier doesn't support Custom, so we ignore it completely here\n        let request: QueryRequest\u003cEmpty\u003e = match from_slice(bin_request) {\n            Ok(v) =\u003e v,\n            Err(e) =\u003e {\n                return SystemResult::Err(SystemError::InvalidRequest {\n                    error: format!(\"Parsing query request: {}\", e),\n                    request: bin_request.into(),\n                })\n            }\n        };\n        self.handle_query(\u0026request)\n    }\n}\n\nimpl WasmMockQuerier {\n    pub fn handle_query(\u0026self, request: \u0026QueryRequest\u003cEmpty\u003e) -\u003e QuerierResult {\n        match \u0026request {\n            QueryRequest::Wasm(WasmQuery::Smart { contract_addr, msg }) =\u003e match from_binary(msg) {\n                Ok(FactoryQueryMsg::Pair { asset_infos }) =\u003e {\n                    let key = [asset_infos[0].to_string(), asset_infos[1].to_string()].join(\"\");\n                    let mut sort_key: Vec\u003cchar\u003e = key.chars().collect();\n                    sort_key.sort_by(|a, b| b.cmp(a));\n                    match self\n                        .halo_factory_querier\n                        .pairs\n                        .get(\u0026String::from_iter(sort_key.iter()))\n                    {\n                        Some(v) =\u003e SystemResult::Ok(ContractResult::Ok(to_binary(v).unwrap())),\n                        None =\u003e SystemResult::Err(SystemError::InvalidRequest {\n                            error: \"No pair info exists\".to_string(),\n                            request: msg.as_slice().into(),\n                        }),\n                    }\n                }\n                Ok(FactoryQueryMsg::NativeTokenDecimals { denom }) =\u003e {\n                    match self\n                        .halo_factory_querier\n                        .native_token_decimals\n                        .get(\u0026denom)\n                    {\n                        Some(decimals) =\u003e SystemResult::Ok(ContractResult::Ok(\n                            to_binary(\u0026NativeTokenDecimalsResponse {\n                                decimals: *decimals,\n                            })\n                            .unwrap(),\n                        )),\n                        None =\u003e SystemResult::Err(SystemError::InvalidRequest {\n                            error: \"No decimal info exist\".to_string(),\n                            request: msg.as_slice().into(),\n                        }),\n                    }\n                }\n                _ =\u003e match from_binary(msg) {\n                    Ok(PairQueryMsg::Pair {}) =\u003e {\n                        SystemResult::Ok(ContractResult::from(to_binary(\u0026PairInfo {\n                            asset_infos: [\n                                AssetInfo::NativeToken {\n                                    denom: \"uluna\".to_string(),\n                                },\n                                AssetInfo::NativeToken {\n                                    denom: \"uluna\".to_string(),\n                                },\n                            ],\n                            asset_decimals: [6u8, 6u8],\n                            contract_addr: \"pair0000\".to_string(),\n                            liquidity_token: \"liquidity0000\".to_string(),\n                            requirements: CreatePairRequirements {\n                                whitelist: vec![Addr::unchecked(\"deployer\")],\n                                first_asset_minimum: Uint128::zero(),\n                                second_asset_minimum: Uint128::zero(),\n                            },\n                        })))\n                    }\n                    Ok(PairQueryMsg::Simulation { offer_asset }) =\u003e {\n                        SystemResult::Ok(ContractResult::from(to_binary(\u0026SimulationResponse {\n                            return_amount: offer_asset.amount,\n                            commission_amount: Uint128::zero(),\n                            spread_amount: Uint128::zero(),\n                        })))\n                    }\n                    Ok(PairQueryMsg::ReverseSimulation { ask_asset }) =\u003e SystemResult::Ok(\n                        ContractResult::from(to_binary(\u0026ReverseSimulationResponse {\n                            offer_amount: ask_asset.amount,\n                            commission_amount: Uint128::zero(),\n                            spread_amount: Uint128::zero(),\n                        })),\n                    ),\n                    _ =\u003e match from_binary(msg).unwrap() {\n                        Cw20QueryMsg::TokenInfo {} =\u003e {\n                            let balances: \u0026HashMap\u003cString, Uint128\u003e =\n                                match self.token_querier.balances.get(contract_addr) {\n                                    Some(balances) =\u003e balances,\n                                    None =\u003e {\n                                        return SystemResult::Err(SystemError::InvalidRequest {\n                                            error: format!(\n                                                \"No balance info exists for the contract {}\",\n                                                contract_addr\n                                            ),\n                                            request: msg.as_slice().into(),\n                                        })\n                                    }\n                                };\n\n                            let mut total_supply = Uint128::zero();\n\n                            for balance in balances {\n                                total_supply += *balance.1;\n                            }\n\n                            SystemResult::Ok(ContractResult::Ok(\n                                to_binary(\u0026TokenInfoResponse {\n                                    name: \"mAAPL\".to_string(),\n                                    symbol: \"mAAPL\".to_string(),\n                                    decimals: 8,\n                                    total_supply,\n                                })\n                                .unwrap(),\n                            ))\n                        }\n                        Cw20QueryMsg::Balance { address } =\u003e {\n                            let balances: \u0026HashMap\u003cString, Uint128\u003e =\n                                match self.token_querier.balances.get(contract_addr) {\n                                    Some(balances) =\u003e balances,\n                                    None =\u003e {\n                                        return SystemResult::Err(SystemError::InvalidRequest {\n                                            error: format!(\n                                                \"No balance info exists for the contract {}\",\n                                                contract_addr\n                                            ),\n                                            request: msg.as_slice().into(),\n                                        })\n                                    }\n                                };\n\n                            let balance = match balances.get(\u0026address) {\n                                Some(v) =\u003e *v,\n                                None =\u003e {\n                                    return SystemResult::Ok(ContractResult::Ok(\n                                        to_binary(\u0026Cw20BalanceResponse {\n                                            balance: Uint128::zero(),\n                                        })\n                                        .unwrap(),\n                                    ));\n                                }\n                            };\n\n                            SystemResult::Ok(ContractResult::Ok(\n                                to_binary(\u0026Cw20BalanceResponse { balance }).unwrap(),\n                            ))\n                        }\n\n                        _ =\u003e panic!(\"DO NOT ENTER HERE\"),\n                    },\n                },\n            },\n            _ =\u003e self.base.handle_query(request),\n        }\n    }\n}\n\nimpl WasmMockQuerier {\n    pub fn new(base: MockQuerier) -\u003e Self {\n        WasmMockQuerier {\n            base,\n            token_querier: TokenQuerier::default(),\n            halo_factory_querier: HaloFactoryQuerier::default(),\n        }\n    }\n\n    // configure the mint whitelist mock querier\n    pub fn with_token_balances(\u0026mut self, balances: \u0026[(\u0026String, \u0026[(\u0026String, \u0026Uint128)])]) {\n        self.token_querier = TokenQuerier::new(balances);\n    }\n\n    // configure the halo pair\n    pub fn with_halo_factory(\n        \u0026mut self,\n        pairs: \u0026[(\u0026String, \u0026PairInfo)],\n        native_token_decimals: \u0026[(String, u8)],\n    ) {\n        self.halo_factory_querier = HaloFactoryQuerier::new(pairs, native_token_decimals);\n    }\n\n    pub fn with_balance(\u0026mut self, balances: \u0026[(\u0026String, Vec\u003cCoin\u003e)]) {\n        for (addr, balance) in balances {\n            self.base.update_balance(addr.to_string(), balance.clone());\n        }\n    }\n}\n\n#[cfg(test)]\nmod mock_exception {\n    use cosmwasm_std::Binary;\n\n    use super::*;\n\n    #[test]\n    fn raw_query_err() {\n        let deps = mock_dependencies(\u0026[]);\n        assert_eq!(\n            deps.querier.raw_query(\u0026[]),\n            SystemResult::Err(SystemError::InvalidRequest {\n                error: \"Parsing query request: Error parsing into type cosmwasm_std::query::QueryRequest\u003ccosmwasm_std::results::empty::Empty\u003e: EOF while parsing a JSON value.\".to_string(),\n                request: Binary(vec![])\n            })\n        );\n    }\n\n    #[test]\n    fn none_factory_pair_will_err() {\n        let deps = mock_dependencies(\u0026[]);\n\n        let msg = to_binary(\u0026FactoryQueryMsg::Pair {\n            asset_infos: [\n                AssetInfo::NativeToken {\n                    denom: \"uluna\".to_string(),\n                },\n                AssetInfo::NativeToken {\n                    denom: \"ulunc\".to_string(),\n                },\n            ],\n        })\n        .unwrap();\n        assert_eq!(\n            deps.querier\n                .handle_query(\u0026QueryRequest::Wasm(WasmQuery::Smart {\n                    contract_addr: \"contract0000\".to_string(),\n                    msg: msg.clone()\n                })),\n            SystemResult::Err(SystemError::InvalidRequest {\n                error: \"No pair info exists\".to_string(),\n                request: msg\n            })\n        )\n    }\n\n    #[test]\n    fn none_tokens_info_will_err() {\n        let deps = mock_dependencies(\u0026[]);\n\n        let msg = to_binary(\u0026Cw20QueryMsg::TokenInfo {}).unwrap();\n\n        assert_eq!(\n            deps.querier\n                .handle_query(\u0026QueryRequest::Wasm(WasmQuery::Smart {\n                    contract_addr: \"token0000\".to_string(),\n                    msg: msg.clone()\n                })),\n            SystemResult::Err(SystemError::InvalidRequest {\n                error: \"No balance info exists for the contract token0000\".to_string(),\n                request: msg\n            })\n        )\n    }\n\n    #[test]\n    fn none_tokens_balance_will_err() {\n        let deps = mock_dependencies(\u0026[]);\n\n        let msg = to_binary(\u0026Cw20QueryMsg::Balance {\n            address: \"address0000\".to_string(),\n        })\n        .unwrap();\n\n        assert_eq!(\n            deps.querier\n                .handle_query(\u0026QueryRequest::Wasm(WasmQuery::Smart {\n                    contract_addr: \"token0000\".to_string(),\n                    msg: msg.clone()\n                })),\n            SystemResult::Err(SystemError::InvalidRequest {\n                error: \"No balance info exists for the contract token0000\".to_string(),\n                request: msg\n            })\n        )\n    }\n\n    #[test]\n    #[should_panic]\n    fn none_tokens_minter_will_panic() {\n        let deps = mock_dependencies(\u0026[]);\n\n        let msg = to_binary(\u0026Cw20QueryMsg::Minter {}).unwrap();\n\n        deps.querier\n            .handle_query(\u0026QueryRequest::Wasm(WasmQuery::Smart {\n                contract_addr: \"token0000\".to_string(),\n                msg,\n            }));\n    }\n}\n","traces":[{"line":20,"address":[],"length":0,"stats":{"Line":47},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":47},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":47},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":47},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":47},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":31},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":31},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":31},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":31},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":71},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":40},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":138},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":49},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":40},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":31},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":373},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":81},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":161},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":80},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":80},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":84},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":56},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":56},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":408},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":39},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":34},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":44},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":258,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":28},"fn_name":null},{"line":268,"address":[],"length":0,"stats":{"Line":47},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":47},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":47},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":31},"fn_name":null},{"line":278,"address":[],"length":0,"stats":{"Line":31},"fn_name":null},{"line":282,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":287,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":290,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":291,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":292,"address":[],"length":0,"stats":{"Line":9},"fn_name":null}],"covered":136,"coverable":136},{"path":["/","Users","haitran","AURA-NETWORK","smart-contracts-halotrade-zone","packages","haloswap","src","pair.rs"],"content":"use cosmwasm_schema::{cw_serde, QueryResponses};\n\nuse crate::asset::{Asset, AssetInfo, PairInfo, CreatePairRequirements};\n\nuse cosmwasm_std::{Decimal, Uint128};\nuse cw20::Cw20ReceiveMsg;\n\n#[cw_serde]\npub struct InstantiateMsg {\n    /// Asset infos\n    pub asset_infos: [AssetInfo; 2],\n    /// Token contract code id for initialization\n    pub token_code_id: u64,\n    pub asset_decimals: [u8; 2],\n    /// The requiments to the first time provide liquidity\n    pub requirements: CreatePairRequirements,\n}\n\n#[cw_serde]\npub enum ExecuteMsg {\n    Receive(Cw20ReceiveMsg),\n    /// ProvideLiquidity a user provides pool liquidity\n    ProvideLiquidity {\n        assets: [Asset; 2],\n        slippage_tolerance: Option\u003cDecimal\u003e,\n        receiver: Option\u003cString\u003e,\n    },\n    /// Swap an offer asset to the other\n    Swap {\n        offer_asset: Asset,\n        belief_price: Option\u003cDecimal\u003e,\n        max_spread: Option\u003cDecimal\u003e,\n        to: Option\u003cString\u003e,\n    },\n}\n\n#[cw_serde]\n// #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n// #[serde(rename_all = \"snake_case\")]\npub enum Cw20HookMsg {\n    /// Sell a given amount of asset\n    Swap {\n        belief_price: Option\u003cDecimal\u003e,\n        max_spread: Option\u003cDecimal\u003e,\n        to: Option\u003cString\u003e,\n    },\n    WithdrawLiquidity {},\n}\n\n#[cw_serde]\n#[derive(QueryResponses)]\npub enum QueryMsg {\n    #[returns(PairInfo)]\n    Pair {},\n    #[returns(PoolResponse)]\n    Pool {},\n    #[returns(SimulationResponse)]\n    Simulation { offer_asset: Asset },\n    #[returns(ReverseSimulationResponse)]\n    ReverseSimulation { ask_asset: Asset },\n}\n\n// We define a custom struct for each query response\n#[cw_serde]\npub struct PoolResponse {\n    pub assets: [Asset; 2],\n    pub total_share: Uint128,\n}\n\n/// SimulationResponse returns swap simulation response\n#[cw_serde]\npub struct SimulationResponse {\n    pub return_amount: Uint128,\n    pub spread_amount: Uint128,\n    pub commission_amount: Uint128,\n}\n\n/// ReverseSimulationResponse returns reverse swap simulation response\n#[cw_serde]\npub struct ReverseSimulationResponse {\n    pub offer_amount: Uint128,\n    pub spread_amount: Uint128,\n    pub commission_amount: Uint128,\n}\n\n/// We currently take no arguments for migrations\n#[cw_serde]\npub struct MigrateMsg {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","haitran","AURA-NETWORK","smart-contracts-halotrade-zone","packages","haloswap","src","querier.rs"],"content":"use crate::asset::{Asset, AssetInfo, PairInfo};\nuse crate::factory::{NativeTokenDecimalsResponse, QueryMsg as FactoryQueryMsg};\nuse crate::pair::{QueryMsg as PairQueryMsg, ReverseSimulationResponse, SimulationResponse};\n\nuse cosmwasm_std::{\n    to_binary, Addr, AllBalanceResponse, BalanceResponse, BankQuery, Coin, QuerierWrapper,\n    QueryRequest, StdResult, Uint128, WasmQuery,\n};\n\nuse cw20::{BalanceResponse as Cw20BalanceResponse, Cw20QueryMsg, TokenInfoResponse};\n\npub fn query_balance(\n    querier: \u0026QuerierWrapper,\n    account_addr: Addr,\n    denom: String,\n) -\u003e StdResult\u003cUint128\u003e {\n    // load price form the oracle\n    let balance: BalanceResponse = querier.query(\u0026QueryRequest::Bank(BankQuery::Balance {\n        address: account_addr.to_string(),\n        denom,\n    }))?;\n    Ok(balance.amount.amount)\n}\n\npub fn query_all_balances(querier: \u0026QuerierWrapper, account_addr: Addr) -\u003e StdResult\u003cVec\u003cCoin\u003e\u003e {\n    // load price form the oracle\n    let all_balances: AllBalanceResponse =\n        querier.query(\u0026QueryRequest::Bank(BankQuery::AllBalances {\n            address: account_addr.to_string(),\n        }))?;\n    Ok(all_balances.amount)\n}\n\npub fn query_token_balance(\n    querier: \u0026QuerierWrapper,\n    contract_addr: Addr,\n    account_addr: Addr,\n) -\u003e StdResult\u003cUint128\u003e {\n    let res: Cw20BalanceResponse = querier.query(\u0026QueryRequest::Wasm(WasmQuery::Smart {\n        contract_addr: contract_addr.to_string(),\n        msg: to_binary(\u0026Cw20QueryMsg::Balance {\n            address: account_addr.to_string(),\n        })?,\n    }))?;\n\n    // load balance form the token contract\n    Ok(res.balance)\n}\n\npub fn query_token_info(\n    querier: \u0026QuerierWrapper,\n    contract_addr: Addr,\n) -\u003e StdResult\u003cTokenInfoResponse\u003e {\n    let token_info: TokenInfoResponse = querier.query(\u0026QueryRequest::Wasm(WasmQuery::Smart {\n        contract_addr: contract_addr.to_string(),\n        msg: to_binary(\u0026Cw20QueryMsg::TokenInfo {})?,\n    }))?;\n\n    Ok(token_info)\n}\n\npub fn query_native_decimals(\n    querier: \u0026QuerierWrapper,\n    factory_contract: Addr,\n    denom: String,\n) -\u003e StdResult\u003cu8\u003e {\n    let res: NativeTokenDecimalsResponse =\n        querier.query(\u0026QueryRequest::Wasm(WasmQuery::Smart {\n            contract_addr: factory_contract.to_string(),\n            msg: to_binary(\u0026FactoryQueryMsg::NativeTokenDecimals { denom })?,\n        }))?;\n    Ok(res.decimals)\n}\n\npub fn query_pair_info(\n    querier: \u0026QuerierWrapper,\n    factory_contract: Addr,\n    asset_infos: \u0026[AssetInfo; 2],\n) -\u003e StdResult\u003cPairInfo\u003e {\n    querier.query(\u0026QueryRequest::Wasm(WasmQuery::Smart {\n        contract_addr: factory_contract.to_string(),\n        msg: to_binary(\u0026FactoryQueryMsg::Pair {\n            asset_infos: asset_infos.clone(),\n        })?,\n    }))\n}\n\npub fn simulate(\n    querier: \u0026QuerierWrapper,\n    pair_contract: Addr,\n    offer_asset: \u0026Asset,\n) -\u003e StdResult\u003cSimulationResponse\u003e {\n    querier.query(\u0026QueryRequest::Wasm(WasmQuery::Smart {\n        contract_addr: pair_contract.to_string(),\n        msg: to_binary(\u0026PairQueryMsg::Simulation {\n            offer_asset: offer_asset.clone(),\n        })?,\n    }))\n}\n\npub fn reverse_simulate(\n    querier: \u0026QuerierWrapper,\n    pair_contract: Addr,\n    ask_asset: \u0026Asset,\n) -\u003e StdResult\u003cReverseSimulationResponse\u003e {\n    querier.query(\u0026QueryRequest::Wasm(WasmQuery::Smart {\n        contract_addr: pair_contract.to_string(),\n        msg: to_binary(\u0026PairQueryMsg::ReverseSimulation {\n            ask_asset: ask_asset.clone(),\n        })?,\n    }))\n}\n\npub fn query_pair_info_from_pair(\n    querier: \u0026QuerierWrapper,\n    pair_contract: Addr,\n) -\u003e StdResult\u003cPairInfo\u003e {\n    let pair_info: PairInfo = querier.query(\u0026QueryRequest::Wasm(WasmQuery::Smart {\n        contract_addr: pair_contract.to_string(),\n        msg: to_binary(\u0026PairQueryMsg::Pair {})?,\n    }))?;\n\n    Ok(pair_info)\n}\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":54},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":40,"coverable":40},{"path":["/","Users","haitran","AURA-NETWORK","smart-contracts-halotrade-zone","packages","haloswap","src","router.rs"],"content":"use cosmwasm_schema::{cw_serde, QueryResponses};\nuse cosmwasm_std::Uint128;\nuse cw20::Cw20ReceiveMsg;\n\nuse crate::asset::AssetInfo;\n\n#[cw_serde]\npub struct InstantiateMsg {\n    pub halo_factory: String,\n}\n\n#[cw_serde]\npub enum SwapOperation {\n    HaloSwap {\n        offer_asset_info: AssetInfo,\n        ask_asset_info: AssetInfo,\n    },\n}\n\nimpl SwapOperation {\n    pub fn get_target_asset_info(\u0026self) -\u003e AssetInfo {\n        match self {\n            SwapOperation::HaloSwap { ask_asset_info, .. } =\u003e ask_asset_info.clone(),\n        }\n    }\n}\n\n#[cw_serde]\npub enum ExecuteMsg {\n    Receive(Cw20ReceiveMsg),\n    /// Execute multiple BuyOperation\n    ExecuteSwapOperations {\n        operations: Vec\u003cSwapOperation\u003e,\n        minimum_receive: Option\u003cUint128\u003e,\n        to: Option\u003cString\u003e,\n    },\n\n    /// Internal use\n    /// Swap all offer tokens to ask token\n    ExecuteSwapOperation {\n        operation: SwapOperation,\n        to: Option\u003cString\u003e,\n    },\n    /// Internal use\n    /// Check the swap amount is exceed minimum_receive\n    AssertMinimumReceive {\n        asset_info: AssetInfo,\n        prev_balance: Uint128,\n        minimum_receive: Uint128,\n        receiver: String,\n    },\n}\n\n#[cw_serde]\npub enum Cw20HookMsg {\n    ExecuteSwapOperations {\n        operations: Vec\u003cSwapOperation\u003e,\n        minimum_receive: Option\u003cUint128\u003e,\n        to: Option\u003cString\u003e,\n    },\n}\n\n#[cw_serde]\n#[derive(QueryResponses)]\npub enum QueryMsg {\n    #[returns(ConfigResponse)]\n    Config {},\n    #[returns(SimulateSwapOperationsResponse)]\n    SimulateSwapOperations {\n        offer_amount: Uint128,\n        operations: Vec\u003cSwapOperation\u003e,\n    },\n    #[returns(SimulateSwapOperationsResponse)]\n    ReverseSimulateSwapOperations {\n        ask_amount: Uint128,\n        operations: Vec\u003cSwapOperation\u003e,\n    },\n}\n\n// We define a custom struct for each query response\n#[cw_serde]\npub struct ConfigResponse {\n    pub halo_factory: String,\n}\n\n// We define a custom struct for each query response\n#[cw_serde]\npub struct SimulateSwapOperationsResponse {\n    pub amount: Uint128,\n}\n\n/// We currently take no arguments for migrations\n#[cw_serde]\npub struct MigrateMsg {}\n","traces":[{"line":21,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":3},"fn_name":null}],"covered":3,"coverable":3},{"path":["/","Users","haitran","AURA-NETWORK","smart-contracts-halotrade-zone","packages","haloswap","src","testing.rs"],"content":"use crate::asset::{Asset, AssetInfo, AssetInfoRaw, AssetRaw, PairInfo, CreatePairRequirements};\nuse crate::mock_querier::mock_dependencies;\nuse crate::querier::{\n    query_all_balances, query_balance, query_pair_info, query_token_balance, query_token_info,\n};\n\nuse cosmwasm_std::testing::MOCK_CONTRACT_ADDR;\nuse cosmwasm_std::{\n    coin, to_binary, Addr, Api, BankMsg, Coin, CosmosMsg, MessageInfo, StdError, SubMsg, Uint128,\n    WasmMsg,\n};\nuse cw20::Cw20ExecuteMsg;\n\n#[test]\nfn token_balance_querier() {\n    let mut deps = mock_dependencies(\u0026[]);\n\n    deps.querier.with_token_balances(\u0026[(\n        \u0026\"liquidity0000\".to_string(),\n        \u0026[(\u0026MOCK_CONTRACT_ADDR.to_string(), \u0026Uint128::from(123u128))],\n    )]);\n\n    assert_eq!(\n        Uint128::from(123u128),\n        query_token_balance(\n            \u0026deps.as_ref().querier,\n            Addr::unchecked(\"liquidity0000\"),\n            Addr::unchecked(MOCK_CONTRACT_ADDR),\n        )\n        .unwrap()\n    );\n}\n\n#[test]\nfn balance_querier() {\n    let deps = mock_dependencies(\u0026[Coin {\n        denom: \"uusd\".to_string(),\n        amount: Uint128::from(200u128),\n    }]);\n\n    assert_eq!(\n        query_balance(\n            \u0026deps.as_ref().querier,\n            Addr::unchecked(MOCK_CONTRACT_ADDR),\n            \"uusd\".to_string()\n        )\n        .unwrap(),\n        Uint128::from(200u128)\n    );\n}\n\n#[test]\nfn all_balances_querier() {\n    let deps = mock_dependencies(\u0026[\n        Coin {\n            denom: \"uusd\".to_string(),\n            amount: Uint128::from(200u128),\n        },\n        Coin {\n            denom: \"ukrw\".to_string(),\n            amount: Uint128::from(300u128),\n        },\n    ]);\n\n    assert_eq!(\n        query_all_balances(\u0026deps.as_ref().querier, Addr::unchecked(MOCK_CONTRACT_ADDR),).unwrap(),\n        vec![\n            Coin {\n                denom: \"uusd\".to_string(),\n                amount: Uint128::from(200u128),\n            },\n            Coin {\n                denom: \"ukrw\".to_string(),\n                amount: Uint128::from(300u128),\n            }\n        ]\n    );\n}\n\n#[test]\nfn supply_querier() {\n    let mut deps = mock_dependencies(\u0026[]);\n\n    deps.querier.with_token_balances(\u0026[(\n        \u0026\"liquidity0000\".to_string(),\n        \u0026[\n            (\u0026MOCK_CONTRACT_ADDR.to_string(), \u0026Uint128::from(123u128)),\n            (\u0026\"addr00000\".to_string(), \u0026Uint128::from(123u128)),\n            (\u0026\"addr00001\".to_string(), \u0026Uint128::from(123u128)),\n            (\u0026\"addr00002\".to_string(), \u0026Uint128::from(123u128)),\n        ],\n    )]);\n\n    assert_eq!(\n        query_token_info(\u0026deps.as_ref().querier, Addr::unchecked(\"liquidity0000\"))\n            .unwrap()\n            .total_supply,\n        Uint128::from(492u128)\n    )\n}\n\n#[test]\nfn test_asset_info() {\n    let token_info: AssetInfo = AssetInfo::Token {\n        contract_addr: \"asset0000\".to_string(),\n    };\n    let native_token_info: AssetInfo = AssetInfo::NativeToken {\n        denom: \"uusd\".to_string(),\n    };\n\n    assert!(!token_info.equal(\u0026native_token_info));\n\n    assert!(!token_info.equal(\u0026AssetInfo::Token {\n        contract_addr: \"asset0001\".to_string(),\n    }));\n\n    assert!(token_info.equal(\u0026AssetInfo::Token {\n        contract_addr: \"asset0000\".to_string(),\n    }));\n\n    assert!(native_token_info.is_native_token());\n    assert!(!token_info.is_native_token());\n\n    let mut deps = mock_dependencies(\u0026[Coin {\n        denom: \"uusd\".to_string(),\n        amount: Uint128::from(123u128),\n    }]);\n    deps.querier.with_token_balances(\u0026[(\n        \u0026\"asset0000\".to_string(),\n        \u0026[\n            (\u0026MOCK_CONTRACT_ADDR.to_string(), \u0026Uint128::from(123u128)),\n            (\u0026\"addr00000\".to_string(), \u0026Uint128::from(123u128)),\n            (\u0026\"addr00001\".to_string(), \u0026Uint128::from(123u128)),\n            (\u0026\"addr00002\".to_string(), \u0026Uint128::from(123u128)),\n        ],\n    )]);\n\n    assert_eq!(\n        token_info\n            .query_pool(\n                \u0026deps.as_ref().querier,\n                deps.as_ref().api,\n                Addr::unchecked(MOCK_CONTRACT_ADDR)\n            )\n            .unwrap(),\n        Uint128::from(123u128)\n    );\n    assert_eq!(\n        native_token_info\n            .query_pool(\n                \u0026deps.as_ref().querier,\n                deps.as_ref().api,\n                Addr::unchecked(MOCK_CONTRACT_ADDR)\n            )\n            .unwrap(),\n        Uint128::from(123u128)\n    );\n}\n\n#[test]\nfn test_asset() {\n    let mut deps = mock_dependencies(\u0026[Coin {\n        denom: \"uusd\".to_string(),\n        amount: Uint128::from(123u128),\n    }]);\n\n    deps.querier.with_token_balances(\u0026[(\n        \u0026\"asset0000\".to_string(),\n        \u0026[\n            (\u0026MOCK_CONTRACT_ADDR.to_string(), \u0026Uint128::from(123u128)),\n            (\u0026\"addr00000\".to_string(), \u0026Uint128::from(123u128)),\n            (\u0026\"addr00001\".to_string(), \u0026Uint128::from(123u128)),\n            (\u0026\"addr00002\".to_string(), \u0026Uint128::from(123u128)),\n        ],\n    )]);\n\n    let token_asset = Asset {\n        amount: Uint128::from(123123u128),\n        info: AssetInfo::Token {\n            contract_addr: \"asset0000\".to_string(),\n        },\n    };\n\n    let native_token_asset = Asset {\n        amount: Uint128::from(123123u128),\n        info: AssetInfo::NativeToken {\n            denom: \"uusd\".to_string(),\n        },\n    };\n\n    assert_eq!(\n        token_asset\n            .clone()\n            .into_msg(Addr::unchecked(\"addr0000\"))\n            .unwrap(),\n        CosmosMsg::Wasm(WasmMsg::Execute {\n            contract_addr: \"asset0000\".to_string(),\n            msg: to_binary(\u0026Cw20ExecuteMsg::Transfer {\n                recipient: \"addr0000\".to_string(),\n                amount: Uint128::from(123123u128),\n            })\n            .unwrap(),\n            funds: vec![],\n        })\n    );\n\n    assert_eq!(\n        token_asset\n            .into_submsg(Addr::unchecked(\"addr0000\"))\n            .unwrap(),\n        SubMsg::new(CosmosMsg::Wasm(WasmMsg::Execute {\n            contract_addr: \"asset0000\".to_string(),\n            msg: to_binary(\u0026Cw20ExecuteMsg::Transfer {\n                recipient: \"addr0000\".to_string(),\n                amount: Uint128::from(123123u128),\n            })\n            .unwrap(),\n            funds: vec![],\n        }))\n    );\n\n    assert_eq!(\n        native_token_asset\n            .into_msg(Addr::unchecked(\"addr0000\"))\n            .unwrap(),\n        CosmosMsg::Bank(BankMsg::Send {\n            to_address: \"addr0000\".to_string(),\n            amount: vec![Coin {\n                denom: \"uusd\".to_string(),\n                amount: Uint128::from(123123u128),\n            }]\n        })\n    );\n}\n\n#[test]\nfn test_assert_sent_native_token_balance() {\n    // zero asset\n    let message_info = MessageInfo {\n        funds: vec![],\n        sender: Addr::unchecked(\"addr0000\"),\n    };\n\n    let zero_asset = Asset {\n        amount: Uint128::zero(),\n        info: AssetInfo::NativeToken {\n            denom: \"uluna\".to_string(),\n        },\n    };\n\n    assert_eq!(\n        zero_asset.assert_sent_native_token_balance(\u0026message_info),\n        Ok(())\n    );\n\n    // invalid message_info\n    let message_info = MessageInfo {\n        funds: vec![coin(123, \"uluna\")],\n        sender: Addr::unchecked(\"addr0000\"),\n    };\n\n    let invalid_amount_asset = Asset {\n        amount: Uint128::from(1u8),\n        info: AssetInfo::NativeToken {\n            denom: \"uluna\".to_string(),\n        },\n    };\n\n    assert_eq!(\n        invalid_amount_asset.assert_sent_native_token_balance(\u0026message_info),\n        Err(StdError::generic_err(\n            \"Native token balance mismatch between the argument and the transferred\"\n        ))\n    );\n\n    let invalid_amount_asset = Asset {\n        amount: Uint128::from(1u8),\n        info: AssetInfo::NativeToken {\n            denom: \"ulunc\".to_string(),\n        },\n    };\n\n    assert_eq!(\n        invalid_amount_asset.assert_sent_native_token_balance(\u0026message_info),\n        Err(StdError::generic_err(\n            \"Native token balance mismatch between the argument and the transferred\"\n        ))\n    )\n}\n\n#[test]\nfn test_asset_to_raw() {\n    let deps = mock_dependencies(\u0026[]);\n    let native_asset = Asset {\n        amount: Uint128::from(1u128),\n        info: AssetInfo::NativeToken {\n            denom: \"uluna\".to_string(),\n        },\n    };\n\n    let native_asset_to_raw = native_asset.to_raw(\u0026deps.api).unwrap();\n\n    assert_eq!(\n        native_asset_to_raw,\n        AssetRaw {\n            amount: Uint128::from(1u128),\n            info: AssetInfoRaw::NativeToken {\n                denom: \"uluna\".to_string()\n            }\n        }\n    );\n\n    assert_eq!(\n        native_asset_to_raw.to_normal(\u0026deps.api).unwrap(),\n        native_asset\n    );\n\n    let token_asset = Asset {\n        amount: Uint128::from(1u128),\n        info: AssetInfo::Token {\n            contract_addr: \"contract0000\".to_string(),\n        },\n    };\n\n    let token_asset_to_raw = token_asset.to_raw(\u0026deps.api).unwrap();\n\n    assert_eq!(\n        token_asset_to_raw,\n        AssetRaw {\n            amount: Uint128::from(1u128),\n            info: AssetInfoRaw::Token {\n                contract_addr: deps.api.addr_canonicalize(\"contract0000\").unwrap()\n            }\n        }\n    );\n\n    assert_eq!(\n        token_asset_to_raw.to_normal(\u0026deps.api).unwrap(),\n        token_asset\n    )\n}\n\n#[test]\nfn test_asset_info_raw_equal() {\n    let native_asset_info_raw = AssetInfoRaw::NativeToken {\n        denom: \"uluna\".to_string(),\n    };\n\n    assert!(native_asset_info_raw.equal(\u0026AssetInfoRaw::NativeToken {\n        denom: \"uluna\".to_string()\n    }));\n\n    assert!(!native_asset_info_raw.equal(\u0026AssetInfoRaw::NativeToken {\n        denom: \"ulunc\".to_string()\n    }));\n\n    let deps = mock_dependencies(\u0026[]);\n    assert!(!native_asset_info_raw.equal(\u0026AssetInfoRaw::Token {\n        contract_addr: deps.api.addr_canonicalize(\"contract0000\").unwrap()\n    }));\n\n    let token_asset_info_raw = AssetInfoRaw::Token {\n        contract_addr: deps.api.addr_canonicalize(\"contract0000\").unwrap(),\n    };\n    assert!(token_asset_info_raw.equal(\u0026AssetInfoRaw::Token {\n        contract_addr: deps.api.addr_canonicalize(\"contract0000\").unwrap()\n    }));\n\n    assert!(!token_asset_info_raw.equal(\u0026AssetInfoRaw::Token {\n        contract_addr: deps.api.addr_canonicalize(\"contract000\").unwrap()\n    }));\n\n    assert!(!token_asset_info_raw.equal(\u0026AssetInfoRaw::NativeToken {\n        denom: \"uluna\".to_string()\n    }));\n}\n\n#[test]\nfn query_halo_pair_contract() {\n    let mut deps = mock_dependencies(\u0026[]);\n\n    deps.querier.with_halo_factory(\n        \u0026[(\n            \u0026\"asset0000uusd\".to_string(),\n            \u0026PairInfo {\n                asset_infos: [\n                    AssetInfo::Token {\n                        contract_addr: \"asset0000\".to_string(),\n                    },\n                    AssetInfo::NativeToken {\n                        denom: \"uusd\".to_string(),\n                    },\n                ],\n                contract_addr: \"pair0000\".to_string(),\n                liquidity_token: \"liquidity0000\".to_string(),\n                asset_decimals: [6u8, 6u8],\n                requirements: CreatePairRequirements {\n                    whitelist: vec![Addr::unchecked(\"deployer\")],\n                    first_asset_minimum: Uint128::zero(),\n                    second_asset_minimum: Uint128::zero(),\n                },\n            },\n        )],\n        \u0026[(\"uusd\".to_string(), 6u8)],\n    );\n\n    let pair_info: PairInfo = query_pair_info(\n        \u0026deps.as_ref().querier,\n        Addr::unchecked(MOCK_CONTRACT_ADDR),\n        \u0026[\n            AssetInfo::Token {\n                contract_addr: \"asset0000\".to_string(),\n            },\n            AssetInfo::NativeToken {\n                denom: \"uusd\".to_string(),\n            },\n        ],\n    )\n    .unwrap();\n\n    assert_eq!(pair_info.contract_addr, Addr::unchecked(\"pair0000\"),);\n    assert_eq!(pair_info.liquidity_token, Addr::unchecked(\"liquidity0000\"),);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","haitran","AURA-NETWORK","smart-contracts-halotrade-zone","packages","haloswap","src","token.rs"],"content":"use cosmwasm_schema::cw_serde;\n\nuse cosmwasm_std::{StdError, StdResult, Uint128};\nuse cw20::{Cw20Coin, MinterResponse};\n\n/// TokenContract InstantiateMsg\n#[cw_serde]\npub struct InstantiateMsg {\n    pub name: String,\n    pub symbol: String,\n    pub decimals: u8,\n    pub initial_balances: Vec\u003cCw20Coin\u003e,\n    pub mint: Option\u003cMinterResponse\u003e,\n}\n\nimpl InstantiateMsg {\n    pub fn get_cap(\u0026self) -\u003e Option\u003cUint128\u003e {\n        self.mint.as_ref().and_then(|v| v.cap)\n    }\n\n    pub fn validate(\u0026self) -\u003e StdResult\u003c()\u003e {\n        // Check name, symbol, decimals\n        if !is_valid_name(\u0026self.name) {\n            return Err(StdError::generic_err(\n                \"Name is not in the expected format (3-50 UTF-8 bytes)\",\n            ));\n        }\n        if !is_valid_symbol(\u0026self.symbol) {\n            return Err(StdError::generic_err(\n                \"Ticker symbol is not in expected format [a-zA-Z\\\\-]{3,12}\",\n            ));\n        }\n        if self.decimals \u003e 18 {\n            return Err(StdError::generic_err(\"Decimals must not exceed 18\"));\n        }\n        Ok(())\n    }\n}\n\nfn is_valid_name(name: \u0026str) -\u003e bool {\n    let bytes = name.as_bytes();\n    if bytes.len() \u003c 3 || bytes.len() \u003e 50 {\n        return false;\n    }\n    true\n}\n\nfn is_valid_symbol(symbol: \u0026str) -\u003e bool {\n    let bytes = symbol.as_bytes();\n    if bytes.len() \u003c 3 || bytes.len() \u003e 12 {\n        return false;\n    }\n    for byte in bytes.iter() {\n        if (*byte != 45) \u0026\u0026 (*byte \u003c 65 || *byte \u003e 90) \u0026\u0026 (*byte \u003c 97 || *byte \u003e 122) {\n            return false;\n        }\n    }\n    true\n}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n\n    #[test]\n    fn get_cap() {\n        let msg = InstantiateMsg {\n            decimals: 6u8,\n            initial_balances: vec![],\n            mint: Some(MinterResponse {\n                cap: Some(Uint128::from(1u128)),\n                minter: \"minter0000\".to_string(),\n            }),\n            name: \"test_token\".to_string(),\n            symbol: \"TNT\".to_string(),\n        };\n\n        assert_eq!(msg.get_cap(), Some(Uint128::from(1u128)))\n    }\n\n    #[test]\n    fn validate() {\n        let valid_msg = InstantiateMsg {\n            decimals: 6u8,\n            initial_balances: vec![],\n            mint: Some(MinterResponse {\n                cap: Some(Uint128::from(1u128)),\n                minter: \"minter0000\".to_string(),\n            }),\n            name: \"test_token\".to_string(),\n            symbol: \"TNT\".to_string(),\n        };\n\n        assert_eq!(valid_msg.validate(), Ok(()));\n\n        let name_invalid_msg = InstantiateMsg {\n            decimals: 6u8,\n            initial_balances: vec![],\n            mint: Some(MinterResponse {\n                cap: Some(Uint128::from(1u128)),\n                minter: \"minter0000\".to_string(),\n            }),\n            name: \"a\".to_string(),\n            symbol: \"TNT\".to_string(),\n        };\n\n        assert_eq!(\n            name_invalid_msg.validate(),\n            Err(StdError::generic_err(\n                \"Name is not in the expected format (3-50 UTF-8 bytes)\",\n            ))\n        );\n\n        let symbol_invalid_msg = InstantiateMsg {\n            decimals: 6u8,\n            initial_balances: vec![],\n            mint: Some(MinterResponse {\n                cap: Some(Uint128::from(1u128)),\n                minter: \"minter0000\".to_string(),\n            }),\n            name: \"test_token\".to_string(),\n            symbol: \"TN\".to_string(),\n        };\n\n        assert_eq!(\n            symbol_invalid_msg.validate(),\n            Err(StdError::generic_err(\n                \"Ticker symbol is not in expected format [a-zA-Z\\\\-]{3,12}\",\n            ))\n        );\n\n        let decimal_invalid_msg = InstantiateMsg {\n            decimals: 20u8,\n            initial_balances: vec![],\n            mint: Some(MinterResponse {\n                cap: Some(Uint128::from(1u128)),\n                minter: \"minter0000\".to_string(),\n            }),\n            name: \"test_token\".to_string(),\n            symbol: \"TNT\".to_string(),\n        };\n\n        assert_eq!(\n            decimal_invalid_msg.validate(),\n            Err(StdError::generic_err(\"Decimals must not exceed 18\"))\n        );\n    }\n}\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":38},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":90},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":8},"fn_name":null}],"covered":25,"coverable":26}]};
        var previousData = {"files":[{"path":["/","Users","haitran","AURA-NETWORK","smart-contracts-halotrade-zone","contracts","halo-factory","src","bin","schema.rs"],"content":"use cosmwasm_schema::write_api;\nuse haloswap::factory::{ExecuteMsg, InstantiateMsg, QueryMsg};\n// use std::env::current_dir;\n// use std::fs::create_dir_all;\n\n// use cosmwasm_schema::{export_schema, remove_schemas, schema_for};\n\n// use haloswap::asset::PairInfo;\n// use haloswap::factory::{ConfigResponse, ExecuteMsg, InstantiateMsg, PairsResponse, QueryMsg};\n\nfn main() {\n    write_api! {\n        instantiate: InstantiateMsg,\n        execute: ExecuteMsg,\n        query: QueryMsg,\n    }\n    // let mut out_dir = current_dir().unwrap();\n    // out_dir.push(\"schema\");\n    // create_dir_all(\u0026out_dir).unwrap();\n    // remove_schemas(\u0026out_dir).unwrap();\n\n    // export_schema(\u0026schema_for!(InstantiateMsg), \u0026out_dir);\n    // export_schema(\u0026schema_for!(ExecuteMsg), \u0026out_dir);\n    // export_schema(\u0026schema_for!(QueryMsg), \u0026out_dir);\n    // export_schema(\u0026schema_for!(PairInfo), \u0026out_dir);\n    // export_schema(\u0026schema_for!(PairsResponse), \u0026out_dir);\n    // export_schema(\u0026schema_for!(ConfigResponse), \u0026out_dir);\n}\n","traces":[{"line":11,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":13,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":15},{"path":["/","Users","haitran","AURA-NETWORK","smart-contracts-halotrade-zone","contracts","halo-factory","src","contract.rs"],"content":"#[cfg(not(feature = \"library\"))]\nuse cosmwasm_std::entry_point;\nuse cosmwasm_std::{\n    to_binary, Addr, Binary, CosmosMsg, Deps, DepsMut, Env, MessageInfo, Reply, ReplyOn, Response,\n    StdError, StdResult, SubMsg, WasmMsg,\n};\nuse cw2::set_contract_version;\nuse haloswap::querier::{query_balance, query_pair_info_from_pair};\n\nuse crate::state::{\n    add_allow_native_token, pair_key, read_pairs, Config, TmpPairInfo, ALLOW_NATIVE_TOKENS, CONFIG,\n    PAIRS, TMP_PAIR_INFO,\n};\n\nuse cw_utils::parse_reply_instantiate_data;\nuse haloswap::asset::{AssetInfo, PairInfo, PairInfoRaw, CreatePairRequirements};\nuse haloswap::factory::{\n    ConfigResponse, ExecuteMsg, InstantiateMsg, MigrateMsg, NativeTokenDecimalsResponse,\n    PairsResponse, QueryMsg,\n};\nuse haloswap::pair::{InstantiateMsg as PairInstantiateMsg, MigrateMsg as PairMigrateMsg};\n\n// version info for migration info\nconst CONTRACT_NAME: \u0026str = \"crates.io:halo-factory\";\nconst CONTRACT_VERSION: \u0026str = env!(\"CARGO_PKG_VERSION\");\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn instantiate(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    msg: InstantiateMsg,\n) -\u003e StdResult\u003cResponse\u003e {\n    set_contract_version(deps.storage, CONTRACT_NAME, CONTRACT_VERSION)?;\n\n    let config = Config {\n        owner: deps.api.addr_canonicalize(info.sender.as_str())?,\n        token_code_id: msg.token_code_id,\n        pair_code_id: msg.pair_code_id,\n    };\n\n    CONFIG.save(deps.storage, \u0026config)?;\n\n    Ok(Response::new())\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn execute(deps: DepsMut, env: Env, info: MessageInfo, msg: ExecuteMsg) -\u003e StdResult\u003cResponse\u003e {\n    match msg {\n        ExecuteMsg::UpdateConfig {\n            owner,\n            token_code_id,\n            pair_code_id,\n        } =\u003e execute_update_config(deps, env, info, owner, token_code_id, pair_code_id),\n        ExecuteMsg::CreatePair { asset_infos, requirements } =\u003e execute_create_pair(deps, env, info, asset_infos, requirements),\n        ExecuteMsg::AddNativeTokenDecimals { denom, decimals } =\u003e {\n            execute_add_native_token_decimals(deps, env, info, denom, decimals)\n        }\n        ExecuteMsg::MigratePair { contract, code_id } =\u003e {\n            execute_migrate_pair(deps, env, info, contract, code_id)\n        }\n    }\n}\n\n// Only owner can execute it\npub fn execute_update_config(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    owner: Option\u003cString\u003e,\n    token_code_id: Option\u003cu64\u003e,\n    pair_code_id: Option\u003cu64\u003e,\n) -\u003e StdResult\u003cResponse\u003e {\n    let mut config: Config = CONFIG.load(deps.storage)?;\n\n    // permission check\n    if deps.api.addr_canonicalize(info.sender.as_str())? != config.owner {\n        return Err(StdError::generic_err(\"unauthorized\"));\n    }\n\n    if let Some(owner) = owner {\n        // validate address format\n        let _ = deps.api.addr_validate(\u0026owner)?;\n\n        config.owner = deps.api.addr_canonicalize(\u0026owner)?;\n    }\n\n    if let Some(token_code_id) = token_code_id {\n        config.token_code_id = token_code_id;\n    }\n\n    if let Some(pair_code_id) = pair_code_id {\n        config.pair_code_id = pair_code_id;\n    }\n\n    CONFIG.save(deps.storage, \u0026config)?;\n\n    Ok(Response::new().add_attribute(\"action\", \"update_config\"))\n}\n\n// Anyone can execute it to create swap pair\npub fn execute_create_pair(\n    deps: DepsMut,\n    env: Env,\n    _info: MessageInfo,\n    asset_infos: [AssetInfo; 2],\n    requirements: CreatePairRequirements,\n) -\u003e StdResult\u003cResponse\u003e {\n    let config: Config = CONFIG.load(deps.storage)?;\n\n    // don't allow to create pair with same token\n    if asset_infos[0] == asset_infos[1] {\n        return Err(StdError::generic_err(\"same asset\"));\n    }\n\n    let asset_1_decimal =\n        match asset_infos[0].query_decimals(env.contract.address.clone(), \u0026deps.querier) {\n            Ok(decimal) =\u003e decimal,\n            Err(_) =\u003e return Err(StdError::generic_err(\"asset1 is invalid\")),\n        };\n\n    let asset_2_decimal =\n        match asset_infos[1].query_decimals(env.contract.address.clone(), \u0026deps.querier) {\n            Ok(decimal) =\u003e decimal,\n            Err(_) =\u003e return Err(StdError::generic_err(\"asset2 is invalid\")),\n        };\n\n    let raw_infos = [\n        asset_infos[0].to_raw(deps.api)?,\n        asset_infos[1].to_raw(deps.api)?,\n    ];\n\n    let asset_decimals = [asset_1_decimal, asset_2_decimal];\n\n    let pair_key = pair_key(\u0026raw_infos);\n    if let Ok(Some(_)) = PAIRS.may_load(deps.storage, \u0026pair_key) {\n        return Err(StdError::generic_err(\"Pair already exists\"));\n    }\n\n    TMP_PAIR_INFO.save(\n        deps.storage,\n        \u0026TmpPairInfo {\n            pair_key,\n            asset_infos: raw_infos,\n            asset_decimals,\n        },\n    )?;\n\n    Ok(Response::new()\n        .add_attributes(vec![\n            (\"action\", \"create_pair\"),\n            (\"pair\", \u0026format!(\"{}-{}\", asset_infos[0], asset_infos[1])),\n        ])\n        .add_submessage(SubMsg {\n            id: 1,\n            gas_limit: None,\n            msg: CosmosMsg::Wasm(WasmMsg::Instantiate {\n                code_id: config.pair_code_id,\n                funds: vec![],\n                admin: Some(env.contract.address.to_string()),\n                label: \"pair\".to_string(),\n                msg: to_binary(\u0026PairInstantiateMsg {\n                    asset_infos,\n                    token_code_id: config.token_code_id,\n                    asset_decimals,\n                    requirements,\n                })?,\n            }),\n            reply_on: ReplyOn::Success,\n        }))\n}\n\npub fn execute_add_native_token_decimals(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    denom: String,\n    decimals: u8,\n) -\u003e StdResult\u003cResponse\u003e {\n    let config: Config = CONFIG.load(deps.storage)?;\n\n    // permission check\n    if deps.api.addr_canonicalize(info.sender.as_str())? != config.owner {\n        return Err(StdError::generic_err(\"unauthorized\"));\n    }\n\n    let balance = query_balance(\u0026deps.querier, env.contract.address, denom.to_string())?;\n    if balance.is_zero() {\n        return Err(StdError::generic_err(\n            \"a balance greater than zero is required by the factory for verification\",\n        ));\n    }\n\n    add_allow_native_token(deps.storage, denom.to_string(), decimals)?;\n\n    Ok(Response::new().add_attributes(vec![\n        (\"action\", \"add_allow_native_token\"),\n        (\"denom\", \u0026denom),\n        (\"decimals\", \u0026decimals.to_string()),\n    ]))\n}\n\npub fn execute_migrate_pair(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    contract: String,\n    code_id: Option\u003cu64\u003e,\n) -\u003e StdResult\u003cResponse\u003e {\n    let config: Config = CONFIG.load(deps.storage)?;\n\n    // permission check\n    if deps.api.addr_canonicalize(info.sender.as_str())? != config.owner {\n        return Err(StdError::generic_err(\"unauthorized\"));\n    }\n\n    let code_id = code_id.unwrap_or(config.pair_code_id);\n\n    Ok(\n        Response::new().add_message(CosmosMsg::Wasm(WasmMsg::Migrate {\n            contract_addr: contract,\n            new_code_id: code_id,\n            msg: to_binary(\u0026PairMigrateMsg {})?,\n        })),\n    )\n}\n\n/// This just stores the result for future query\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn reply(deps: DepsMut, _env: Env, msg: Reply) -\u003e StdResult\u003cResponse\u003e {\n    let tmp_pair_info = TMP_PAIR_INFO.load(deps.storage)?;\n\n    let reply = parse_reply_instantiate_data(msg).unwrap();\n\n    // let res: MsgInstantiateContractResponse =\n    //     Message::parse_from_bytes(msg.result.unwrap().data.unwrap().as_slice()).map_err(|_| {\n    //         StdError::parse_err(\"MsgInstantiateContractResponse\", \"failed to parse data\")\n    //     })?;\n\n    let pair_contract = \u0026reply.contract_address;\n    let pair_info = query_pair_info_from_pair(\u0026deps.querier, Addr::unchecked(pair_contract))?;\n\n    PAIRS.save(\n        deps.storage,\n        \u0026tmp_pair_info.pair_key,\n        \u0026PairInfoRaw {\n            liquidity_token: deps.api.addr_canonicalize(\u0026pair_info.liquidity_token)?,\n            contract_addr: deps.api.addr_canonicalize(\u0026pair_contract)?,\n            asset_infos: tmp_pair_info.asset_infos,\n            asset_decimals: tmp_pair_info.asset_decimals,\n            requirements: pair_info.requirements,\n        },\n    )?;\n\n    Ok(Response::new().add_attributes(vec![\n        (\"pair_contract_addr\", pair_contract),\n        (\"liquidity_token_addr\", \u0026pair_info.liquidity_token.to_string()),\n    ]))\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn query(deps: Deps, _env: Env, msg: QueryMsg) -\u003e StdResult\u003cBinary\u003e {\n    match msg {\n        QueryMsg::Config {} =\u003e to_binary(\u0026query_config(deps)?),\n        QueryMsg::Pair { asset_infos } =\u003e to_binary(\u0026query_pair(deps, asset_infos)?),\n        QueryMsg::Pairs { start_after, limit } =\u003e {\n            to_binary(\u0026query_pairs(deps, start_after, limit)?)\n        }\n        QueryMsg::NativeTokenDecimals { denom } =\u003e {\n            to_binary(\u0026query_native_token_decimal(deps, denom)?)\n        }\n    }\n}\n\npub fn query_config(deps: Deps) -\u003e StdResult\u003cConfigResponse\u003e {\n    let state: Config = CONFIG.load(deps.storage)?;\n    let resp = ConfigResponse {\n        owner: deps.api.addr_humanize(\u0026state.owner)?.to_string(),\n        token_code_id: state.token_code_id,\n        pair_code_id: state.pair_code_id,\n    };\n\n    Ok(resp)\n}\n\npub fn query_pair(deps: Deps, asset_infos: [AssetInfo; 2]) -\u003e StdResult\u003cPairInfo\u003e {\n    let pair_key = pair_key(\u0026[\n        asset_infos[0].to_raw(deps.api)?,\n        asset_infos[1].to_raw(deps.api)?,\n    ]);\n    let pair_info: PairInfoRaw = PAIRS.load(deps.storage, \u0026pair_key)?;\n    pair_info.to_normal(deps.api)\n}\n\npub fn query_pairs(\n    deps: Deps,\n    start_after: Option\u003c[AssetInfo; 2]\u003e,\n    limit: Option\u003cu32\u003e,\n) -\u003e StdResult\u003cPairsResponse\u003e {\n    let start_after = if let Some(start_after) = start_after {\n        Some([\n            start_after[0].to_raw(deps.api)?,\n            start_after[1].to_raw(deps.api)?,\n        ])\n    } else {\n        None\n    };\n\n    let pairs: Vec\u003cPairInfo\u003e = read_pairs(deps.storage, deps.api, start_after, limit)?;\n    let resp = PairsResponse { pairs };\n\n    Ok(resp)\n}\n\npub fn query_native_token_decimal(\n    deps: Deps,\n    denom: String,\n) -\u003e StdResult\u003cNativeTokenDecimalsResponse\u003e {\n    let decimals = ALLOW_NATIVE_TOKENS.load(deps.storage, denom.as_bytes())?;\n\n    Ok(NativeTokenDecimalsResponse { decimals })\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn migrate(deps: DepsMut, _env: Env, _msg: MigrateMsg) -\u003e StdResult\u003cResponse\u003e {\n    set_contract_version(deps.storage, CONTRACT_NAME, CONTRACT_VERSION)?;\n\n    Ok(Response::default())\n}\n","traces":[{"line":34,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":250,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":264,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":265,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":266,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":269,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":275,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":278,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":279,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":280,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":283,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":286,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":287,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":288,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":289,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":291,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":292,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":295,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":300,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":302,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":303,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":306,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":309,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":310,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":312,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":315,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":319,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":321,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":326,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":328,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":133,"coverable":147},{"path":["/","Users","haitran","AURA-NETWORK","smart-contracts-halotrade-zone","contracts","halo-factory","src","lib.rs"],"content":"pub mod contract;\npub mod state;\n\n#[cfg(test)]\nmod testing;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","haitran","AURA-NETWORK","smart-contracts-halotrade-zone","contracts","halo-factory","src","state.rs"],"content":"use schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\n\nuse cosmwasm_std::{Api, CanonicalAddr, Order, StdResult, Storage};\nuse cw_storage_plus::{Bound, Item, Map};\nuse haloswap::asset::{AssetInfoRaw, PairInfo, PairInfoRaw};\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\npub struct Config {\n    pub owner: CanonicalAddr,\n    pub pair_code_id: u64,\n    pub token_code_id: u64,\n}\n\npub const CONFIG: Item\u003cConfig\u003e = Item::new(\"config\");\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\npub struct TmpPairInfo {\n    pub pair_key: Vec\u003cu8\u003e,\n    pub asset_infos: [AssetInfoRaw; 2],\n    pub asset_decimals: [u8; 2],\n}\n\npub const TMP_PAIR_INFO: Item\u003cTmpPairInfo\u003e = Item::new(\"tmp_pair_info\");\npub const PAIRS: Map\u003c\u0026[u8], PairInfoRaw\u003e = Map::new(\"pair_info\");\n\npub fn pair_key(asset_infos: \u0026[AssetInfoRaw; 2]) -\u003e Vec\u003cu8\u003e {\n    let mut asset_infos = asset_infos.to_vec();\n    asset_infos.sort_by(|a, b| a.as_bytes().cmp(b.as_bytes()));\n\n    [asset_infos[0].as_bytes(), asset_infos[1].as_bytes()].concat()\n}\n\n// settings for pagination\nconst MAX_LIMIT: u32 = 30;\nconst DEFAULT_LIMIT: u32 = 10;\npub fn read_pairs(\n    storage: \u0026dyn Storage,\n    api: \u0026dyn Api,\n    start_after: Option\u003c[AssetInfoRaw; 2]\u003e,\n    limit: Option\u003cu32\u003e,\n) -\u003e StdResult\u003cVec\u003cPairInfo\u003e\u003e {\n    let limit = limit.unwrap_or(DEFAULT_LIMIT).min(MAX_LIMIT) as usize;\n    let start = calc_range_start(start_after).map(Bound::ExclusiveRaw);\n\n    PAIRS\n        .range(storage, start, None, Order::Ascending)\n        .take(limit)\n        .map(|item| {\n            let (_, v) = item?;\n            v.to_normal(api)\n        })\n        .collect::\u003cStdResult\u003cVec\u003cPairInfo\u003e\u003e\u003e()\n}\n\n// this will set the first key after the provided key, by appending a 1 byte\nfn calc_range_start(start_after: Option\u003c[AssetInfoRaw; 2]\u003e) -\u003e Option\u003cVec\u003cu8\u003e\u003e {\n    start_after.map(|asset_infos| {\n        let mut asset_infos = asset_infos.to_vec();\n        asset_infos.sort_by(|a, b| a.as_bytes().cmp(b.as_bytes()));\n\n        let mut v = [asset_infos[0].as_bytes(), asset_infos[1].as_bytes()]\n            .concat()\n            .as_slice()\n            .to_vec();\n        v.push(1);\n        v\n    })\n}\n\n// key : asset info / value: decimals\npub const ALLOW_NATIVE_TOKENS: Map\u003c\u0026[u8], u8\u003e = Map::new(\"allow_native_token\");\npub fn add_allow_native_token(\n    storage: \u0026mut dyn Storage,\n    denom: String,\n    decimals: u8,\n) -\u003e StdResult\u003c()\u003e {\n    ALLOW_NATIVE_TOKENS.save(storage, denom.as_bytes(), \u0026decimals)\n}\n\n#[cfg(test)]\nmod allow_native_token {\n\n    use haloswap::mock_querier::mock_dependencies;\n\n    use super::*;\n\n    #[test]\n    fn normal() {\n        let mut deps = mock_dependencies(\u0026[]);\n        let denom = \"uluna\".to_string();\n        let decimals = 6u8;\n\n        add_allow_native_token(deps.as_mut().storage, denom.to_string(), decimals).unwrap();\n\n        assert_eq!(\n            decimals,\n            ALLOW_NATIVE_TOKENS\n                .load(deps.as_ref().storage, denom.as_bytes())\n                .unwrap()\n        )\n    }\n\n    #[test]\n    fn duplicate_register_will_append() {\n        let mut deps = mock_dependencies(\u0026[]);\n        let denom = \"uluna\".to_string();\n\n        add_allow_native_token(deps.as_mut().storage, denom.to_string(), 6u8).unwrap();\n\n        assert_eq!(\n            ALLOW_NATIVE_TOKENS\n                .load(deps.as_ref().storage, denom.as_bytes())\n                .unwrap(),\n            6u8\n        );\n\n        add_allow_native_token(deps.as_mut().storage, denom.to_string(), 7u8).unwrap();\n        assert_eq!(\n            ALLOW_NATIVE_TOKENS\n                .load(deps.as_ref().storage, denom.as_bytes())\n                .unwrap(),\n            7u8\n        );\n    }\n}\n","traces":[{"line":27,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":6},"fn_name":null}],"covered":6,"coverable":25},{"path":["/","Users","haitran","AURA-NETWORK","smart-contracts-halotrade-zone","contracts","halo-factory","src","testing.rs"],"content":"use crate::contract::{execute, instantiate, query, reply};\nuse haloswap::mock_querier::{mock_dependencies, WasmMockQuerier};\n\nuse crate::state::{pair_key, TmpPairInfo, TMP_PAIR_INFO};\n\nuse cosmwasm_std::testing::{\n    mock_dependencies_with_balance, mock_env, mock_info, MockApi, MockStorage, MOCK_CONTRACT_ADDR,\n};\nuse cosmwasm_std::{\n    attr, coin, from_binary, to_binary, CosmosMsg, OwnedDeps, Reply, ReplyOn, Response, StdError,\n    SubMsg, SubMsgResponse, SubMsgResult, Uint128, WasmMsg, Addr,\n};\nuse haloswap::asset::{AssetInfo, PairInfo, CreatePairRequirements};\nuse haloswap::factory::{\n    ConfigResponse, ExecuteMsg, InstantiateMsg, NativeTokenDecimalsResponse, QueryMsg,\n};\nuse haloswap::pair::{InstantiateMsg as PairInstantiateMsg, MigrateMsg as PairMigrateMsg};\n\n#[test]\nfn proper_initialization() {\n    let mut deps = mock_dependencies(\u0026[]);\n\n    let msg = InstantiateMsg {\n        pair_code_id: 321u64,\n        token_code_id: 123u64,\n    };\n\n    let info = mock_info(\"addr0000\", \u0026[]);\n\n    // we can just call .unwrap() to assert this was a success\n    let _res = instantiate(deps.as_mut(), mock_env(), info, msg).unwrap();\n\n    let query_res = query(deps.as_ref(), mock_env(), QueryMsg::Config {}).unwrap();\n    let config_res: ConfigResponse = from_binary(\u0026query_res).unwrap();\n    assert_eq!(123u64, config_res.token_code_id);\n    assert_eq!(321u64, config_res.pair_code_id);\n    assert_eq!(\"addr0000\".to_string(), config_res.owner);\n}\n\n#[test]\nfn update_config() {\n    let mut deps = mock_dependencies(\u0026[]);\n\n    let msg = InstantiateMsg {\n        pair_code_id: 321u64,\n        token_code_id: 123u64,\n    };\n\n    let info = mock_info(\"addr0000\", \u0026[]);\n\n    // we can just call .unwrap() to assert this was a success\n    let _res = instantiate(deps.as_mut(), mock_env(), info, msg).unwrap();\n\n    // update owner\n    let info = mock_info(\"addr0000\", \u0026[]);\n    let msg = ExecuteMsg::UpdateConfig {\n        owner: Some(\"addr0001\".to_string()),\n        pair_code_id: None,\n        token_code_id: None,\n    };\n\n    let res = execute(deps.as_mut(), mock_env(), info, msg).unwrap();\n    assert_eq!(0, res.messages.len());\n\n    // it worked, let's query the state\n    let query_res = query(deps.as_ref(), mock_env(), QueryMsg::Config {}).unwrap();\n    let config_res: ConfigResponse = from_binary(\u0026query_res).unwrap();\n    assert_eq!(123u64, config_res.token_code_id);\n    assert_eq!(321u64, config_res.pair_code_id);\n    assert_eq!(\"addr0001\".to_string(), config_res.owner);\n\n    // update left items\n    let env = mock_env();\n    let info = mock_info(\"addr0001\", \u0026[]);\n    let msg = ExecuteMsg::UpdateConfig {\n        owner: None,\n        pair_code_id: Some(100u64),\n        token_code_id: Some(200u64),\n    };\n\n    let res = execute(deps.as_mut(), env, info, msg).unwrap();\n    assert_eq!(0, res.messages.len());\n\n    // it worked, let's query the state\n    let query_res = query(deps.as_ref(), mock_env(), QueryMsg::Config {}).unwrap();\n    let config_res: ConfigResponse = from_binary(\u0026query_res).unwrap();\n    assert_eq!(200u64, config_res.token_code_id);\n    assert_eq!(100u64, config_res.pair_code_id);\n    assert_eq!(\"addr0001\".to_string(), config_res.owner);\n\n    // Unauthorized err\n    let env = mock_env();\n    let info = mock_info(\"addr0000\", \u0026[]);\n    let msg = ExecuteMsg::UpdateConfig {\n        owner: None,\n        pair_code_id: None,\n        token_code_id: None,\n    };\n\n    let res = execute(deps.as_mut(), env, info, msg);\n    match res {\n        Err(StdError::GenericErr { msg, .. }) =\u003e assert_eq!(msg, \"unauthorized\"),\n        _ =\u003e panic!(\"Must return unauthorized error\"),\n    }\n}\n\nfn init(\n    mut deps: OwnedDeps\u003cMockStorage, MockApi, WasmMockQuerier\u003e,\n) -\u003e OwnedDeps\u003cMockStorage, MockApi, WasmMockQuerier\u003e {\n    let msg = InstantiateMsg {\n        pair_code_id: 321u64,\n        token_code_id: 123u64,\n    };\n\n    let env = mock_env();\n    let info = mock_info(\"addr0000\", \u0026[]);\n\n    deps.querier.with_token_balances(\u0026[(\n        \u0026\"asset0001\".to_string(),\n        \u0026[(\u0026\"addr0000\".to_string(), \u0026Uint128::zero())],\n    )]);\n    // we can just call .unwrap() to assert this was a success\n    let _res = instantiate(deps.as_mut(), env, info, msg).unwrap();\n\n    deps\n}\n\n#[test]\nfn create_pair() {\n    let mut deps = mock_dependencies(\u0026[coin(10u128, \"uusd\".to_string())]);\n    deps = init(deps);\n    deps.querier\n        .with_halo_factory(\u0026[], \u0026[(\"uusd\".to_string(), 6u8)]);\n    let asset_infos = [\n        AssetInfo::NativeToken {\n            denom: \"uusd\".to_string(),\n        },\n        AssetInfo::Token {\n            contract_addr: \"asset0001\".to_string(),\n        },\n    ];\n\n    let msg = ExecuteMsg::CreatePair {\n        asset_infos: asset_infos.clone(),\n        requirements: CreatePairRequirements {\n            whitelist: vec![Addr::unchecked(\"deployer\")],\n            first_asset_minimum: Uint128::zero(),\n            second_asset_minimum: Uint128::zero(),\n        },\n    };\n\n    let env = mock_env();\n    let info = mock_info(\"addr0000\", \u0026[]);\n    let res = execute(deps.as_mut(), env, info, msg).unwrap();\n    assert_eq!(\n        res.attributes,\n        vec![\n            attr(\"action\", \"create_pair\"),\n            attr(\"pair\", \"uusd-asset0001\")\n        ]\n    );\n    assert_eq!(\n        res.messages,\n        vec![SubMsg {\n            id: 1,\n            gas_limit: None,\n            reply_on: ReplyOn::Success,\n            msg: WasmMsg::Instantiate {\n                msg: to_binary(\u0026PairInstantiateMsg {\n                    asset_infos: asset_infos.clone(),\n                    token_code_id: 123u64,\n                    asset_decimals: [6u8, 8u8],\n                    requirements: CreatePairRequirements {\n                        whitelist: vec![Addr::unchecked(\"deployer\")],\n                        first_asset_minimum: Uint128::zero(),\n                        second_asset_minimum: Uint128::zero(),\n                    },\n                })\n                .unwrap(),\n                code_id: 321u64,\n                funds: vec![],\n                label: \"pair\".to_string(),\n                admin: Some(MOCK_CONTRACT_ADDR.to_string()),\n            }\n            .into()\n        },]\n    );\n\n    let raw_infos = [\n        asset_infos[0].to_raw(deps.as_ref().api).unwrap(),\n        asset_infos[1].to_raw(deps.as_ref().api).unwrap(),\n    ];\n\n    assert_eq!(\n        TMP_PAIR_INFO.load(\u0026deps.storage).unwrap(),\n        TmpPairInfo {\n            asset_infos: raw_infos.clone(),\n            pair_key: pair_key(\u0026raw_infos),\n            asset_decimals: [6u8, 8u8]\n        }\n    );\n}\n\n#[test]\nfn create_pair_native_token_and_ibc_token() {\n    let mut deps = mock_dependencies(\u0026[\n        coin(10u128, \"uusd\".to_string()),\n        coin(10u128, \"ibc/HASH\".to_string()),\n    ]);\n    deps = init(deps);\n    deps.querier.with_halo_factory(\n        \u0026[],\n        \u0026[(\"uusd\".to_string(), 6u8), (\"ibc/HASH\".to_string(), 6u8)],\n    );\n\n    let asset_infos = [\n        AssetInfo::NativeToken {\n            denom: \"uusd\".to_string(),\n        },\n        AssetInfo::NativeToken {\n            denom: \"ibc/HASH\".to_string(),\n        },\n    ];\n\n    let msg = ExecuteMsg::CreatePair {\n        asset_infos: asset_infos.clone(),\n        requirements: CreatePairRequirements {\n            whitelist: vec![Addr::unchecked(\"deployer\")],\n            first_asset_minimum: Uint128::zero(),\n            second_asset_minimum: Uint128::zero(),\n        },\n    };\n\n    let env = mock_env();\n    let info = mock_info(\"addr0000\", \u0026[]);\n    let res = execute(deps.as_mut(), env, info, msg).unwrap();\n    assert_eq!(\n        res.attributes,\n        vec![attr(\"action\", \"create_pair\"), attr(\"pair\", \"uusd-ibc/HASH\")]\n    );\n    assert_eq!(\n        res.messages,\n        vec![SubMsg {\n            id: 1,\n            gas_limit: None,\n            reply_on: ReplyOn::Success,\n            msg: WasmMsg::Instantiate {\n                msg: to_binary(\u0026PairInstantiateMsg {\n                    asset_infos: asset_infos.clone(),\n                    token_code_id: 123u64,\n                    asset_decimals: [6u8, 6u8],\n                    requirements: CreatePairRequirements {\n                        whitelist: vec![Addr::unchecked(\"deployer\")],\n                        first_asset_minimum: Uint128::zero(),\n                        second_asset_minimum: Uint128::zero(),\n                    },\n                })\n                .unwrap(),\n                code_id: 321u64,\n                funds: vec![],\n                label: \"pair\".to_string(),\n                admin: Some(MOCK_CONTRACT_ADDR.to_string()),\n            }\n            .into()\n        },]\n    );\n\n    let raw_infos = [\n        asset_infos[0].to_raw(deps.as_ref().api).unwrap(),\n        asset_infos[1].to_raw(deps.as_ref().api).unwrap(),\n    ];\n\n    assert_eq!(\n        TMP_PAIR_INFO.load(\u0026deps.storage).unwrap(),\n        TmpPairInfo {\n            asset_infos: raw_infos.clone(),\n            pair_key: pair_key(\u0026raw_infos),\n            asset_decimals: [6u8, 6u8]\n        }\n    );\n}\n\n#[test]\nfn fail_to_create_same_pair() {\n    let mut deps = mock_dependencies(\u0026[coin(10u128, \"uusd\".to_string())]);\n    deps = init(deps);\n\n    let asset_infos = [\n        AssetInfo::NativeToken {\n            denom: \"uusd\".to_string(),\n        },\n        AssetInfo::NativeToken {\n            denom: \"uusd\".to_string(),\n        },\n    ];\n\n    let requirements = CreatePairRequirements {\n        whitelist: vec![Addr::unchecked(\"deployer\")],\n        first_asset_minimum: Uint128::zero(),\n        second_asset_minimum: Uint128::zero(),\n    };\n\n    let msg = ExecuteMsg::CreatePair { asset_infos, requirements };\n\n    let env = mock_env();\n    let info = mock_info(\"addr0000\", \u0026[]);\n    execute(deps.as_mut(), env, info, msg).unwrap_err();\n}\n\n#[test]\nfn fail_to_create_pair_with_unactive_denoms() {\n    let mut deps = mock_dependencies(\u0026[coin(10u128, \"uusd\".to_string())]);\n    deps = init(deps);\n\n    let asset_infos = [\n        AssetInfo::NativeToken {\n            denom: \"uusd\".to_string(),\n        },\n        AssetInfo::NativeToken {\n            denom: \"uxxx\".to_string(),\n        },\n    ];\n\n    let requirements = CreatePairRequirements {\n        whitelist: vec![Addr::unchecked(\"deployer\")],\n        first_asset_minimum: Uint128::zero(),\n        second_asset_minimum: Uint128::zero(),\n    };\n\n    let msg = ExecuteMsg::CreatePair { asset_infos, requirements };\n\n    let env = mock_env();\n    let info = mock_info(\"addr0000\", \u0026[]);\n    execute(deps.as_mut(), env, info, msg).unwrap_err();\n}\n\n#[test]\nfn fail_to_create_pair_with_invalid_denom() {\n    let mut deps = mock_dependencies(\u0026[coin(10u128, \"uluna\".to_string())]);\n    deps = init(deps);\n\n    let asset_infos = [\n        AssetInfo::NativeToken {\n            denom: \"uluna\".to_string(),\n        },\n        AssetInfo::NativeToken {\n            denom: \"xxx\".to_string(),\n        },\n    ];\n\n    let requirements = CreatePairRequirements {\n        whitelist: vec![Addr::unchecked(\"deployer\")],\n        first_asset_minimum: Uint128::zero(),\n        second_asset_minimum: Uint128::zero(),\n    };\n\n    let msg = ExecuteMsg::CreatePair { asset_infos, requirements };\n\n    let env = mock_env();\n    let info = mock_info(\"addr0000\", \u0026[]);\n    execute(deps.as_mut(), env, info, msg).unwrap_err();\n}\n\n#[test]\nfn fail_to_create_pair_with_unknown_token() {\n    let mut deps = mock_dependencies(\u0026[coin(10u128, \"uusd\".to_string())]);\n\n    let msg = InstantiateMsg {\n        pair_code_id: 321u64,\n        token_code_id: 123u64,\n    };\n\n    let env = mock_env();\n    let info = mock_info(\"addr0000\", \u0026[]);\n\n    // we can just call .unwrap() to assert this was a success\n    let _res = instantiate(deps.as_mut(), env, info, msg).unwrap();\n\n    let asset_infos = [\n        AssetInfo::NativeToken {\n            denom: \"uluna\".to_string(),\n        },\n        AssetInfo::Token {\n            contract_addr: \"xxx\".to_string(),\n        },\n    ];\n\n    let requirements = CreatePairRequirements {\n        whitelist: vec![Addr::unchecked(\"deployer\")],\n        first_asset_minimum: Uint128::zero(),\n        second_asset_minimum: Uint128::zero(),\n    };\n\n    let msg = ExecuteMsg::CreatePair { asset_infos, requirements };\n\n    let env = mock_env();\n    let info = mock_info(\"addr0000\", \u0026[]);\n    execute(deps.as_mut(), env, info, msg).unwrap_err();\n}\n\n#[test]\nfn fail_to_create_pair_with_unknown_ibc_token() {\n    let mut deps = mock_dependencies_with_balance(\u0026[coin(10u128, \"uusd\".to_string())]);\n\n    let msg = InstantiateMsg {\n        pair_code_id: 321u64,\n        token_code_id: 123u64,\n    };\n\n    let env = mock_env();\n    let info = mock_info(\"addr0000\", \u0026[]);\n\n    // we can just call .unwrap() to assert this was a success\n    let _res = instantiate(deps.as_mut(), env, info, msg).unwrap();\n\n    let asset_infos = [\n        AssetInfo::NativeToken {\n            denom: \"uluna\".to_string(),\n        },\n        AssetInfo::NativeToken {\n            denom: \"ibc/HA\".to_string(),\n        },\n    ];\n\n    let requirements = CreatePairRequirements {\n        whitelist: vec![Addr::unchecked(\"deployer\")],\n        first_asset_minimum: Uint128::zero(),\n        second_asset_minimum: Uint128::zero(),\n    };\n\n    let msg = ExecuteMsg::CreatePair { asset_infos, requirements };\n\n    let env = mock_env();\n    let info = mock_info(\"addr0000\", \u0026[]);\n    execute(deps.as_mut(), env, info, msg).unwrap_err();\n}\n\n#[test]\nfn reply_test() {\n    let mut deps = mock_dependencies(\u0026[]);\n\n    deps.querier.with_token_balances(\u0026[(\n        \u0026MOCK_CONTRACT_ADDR.to_string(),\n        \u0026[\n            (\u0026\"asset0000\".to_string(), \u0026Uint128::from(100u128)),\n            (\u0026\"asset0001\".to_string(), \u0026Uint128::from(100u128)),\n        ],\n    )]);\n\n    let asset_infos = [\n        AssetInfo::Token {\n            contract_addr: \"asset0000\".to_string(),\n        },\n        AssetInfo::Token {\n            contract_addr: \"asset0001\".to_string(),\n        },\n    ];\n\n    let raw_infos = [\n        asset_infos[0].to_raw(deps.as_ref().api).unwrap(),\n        asset_infos[1].to_raw(deps.as_ref().api).unwrap(),\n    ];\n\n    let pair_key = pair_key(\u0026raw_infos);\n    TMP_PAIR_INFO\n        .save(\n            \u0026mut deps.storage,\n            \u0026TmpPairInfo {\n                asset_infos: raw_infos,\n                pair_key,\n                asset_decimals: [8u8, 8u8],\n            },\n        )\n        .unwrap();\n\n    let reply_msg = Reply {\n        id: 1,\n        result: SubMsgResult::Ok(SubMsgResponse {\n            events: vec![],\n            data: Some(vec![10, 4, 48, 48, 48, 48].into()),\n        }),\n    };\n\n    // register halo pair querier\n    deps.querier.with_halo_factory(\n        \u0026[(\n            \u0026\"0000\".to_string(),\n            \u0026PairInfo {\n                asset_infos: [\n                    AssetInfo::Token {\n                        contract_addr: \"asset0000\".to_string(),\n                    },\n                    AssetInfo::Token {\n                        contract_addr: \"asset0001\".to_string(),\n                    },\n                ],\n                contract_addr: \"0000\".to_string(),\n                liquidity_token: \"liquidity0000\".to_string(),\n                asset_decimals: [8u8, 8u8],\n                requirements: CreatePairRequirements {\n                    whitelist: vec![Addr::unchecked(\"deployer\")],\n                    first_asset_minimum: Uint128::zero(),\n                    second_asset_minimum: Uint128::zero(),\n                },\n            },\n        )],\n        \u0026[],\n    );\n\n    let _res = reply(deps.as_mut(), mock_env(), reply_msg).unwrap();\n\n    let query_res = query(\n        deps.as_ref(),\n        mock_env(),\n        QueryMsg::Pair {\n            asset_infos: asset_infos.clone(),\n        },\n    )\n    .unwrap();\n\n    let pair_res: PairInfo = from_binary(\u0026query_res).unwrap();\n    assert_eq!(\n        pair_res,\n        PairInfo {\n            liquidity_token: \"liquidity0000\".to_string(),\n            contract_addr: \"0000\".to_string(),\n            asset_infos,\n            asset_decimals: [8u8, 8u8],\n            requirements: CreatePairRequirements {\n                whitelist: vec![Addr::unchecked(\"deployer\")],\n                first_asset_minimum: Uint128::zero(),\n                second_asset_minimum: Uint128::zero(),\n            },\n        }\n    );\n}\n\n#[test]\nfn normal_add_allow_native_token() {\n    let mut deps = mock_dependencies(\u0026[coin(1u128, \"uluna\".to_string())]);\n    deps = init(deps);\n\n    let msg = ExecuteMsg::AddNativeTokenDecimals {\n        denom: \"uluna\".to_string(),\n        decimals: 6u8,\n    };\n\n    let info = mock_info(\"addr0000\", \u0026[]);\n\n    assert_eq!(\n        execute(deps.as_mut(), mock_env(), info, msg).unwrap(),\n        Response::new().add_attributes(vec![\n            (\"action\", \"add_allow_native_token\"),\n            (\"denom\", \"uluna\"),\n            (\"decimals\", \"6\"),\n        ])\n    );\n\n    let res = query(\n        deps.as_ref(),\n        mock_env(),\n        QueryMsg::NativeTokenDecimals {\n            denom: \"uluna\".to_string(),\n        },\n    )\n    .unwrap();\n    let res: NativeTokenDecimalsResponse = from_binary(\u0026res).unwrap();\n    assert_eq!(6u8, res.decimals)\n}\n\n#[test]\nfn failed_add_allow_native_token_with_non_admin() {\n    let mut deps = mock_dependencies(\u0026[coin(1u128, \"uluna\".to_string())]);\n    deps = init(deps);\n\n    let msg = ExecuteMsg::AddNativeTokenDecimals {\n        denom: \"uluna\".to_string(),\n        decimals: 6u8,\n    };\n\n    let info = mock_info(\"noadmin\", \u0026[]);\n\n    assert_eq!(\n        execute(deps.as_mut(), mock_env(), info, msg),\n        Err(StdError::generic_err(\"unauthorized\"))\n    );\n}\n\n#[test]\nfn failed_add_allow_native_token_with_zero_factory_balance() {\n    let mut deps = mock_dependencies(\u0026[coin(0u128, \"uluna\".to_string())]);\n    deps = init(deps);\n\n    let msg = ExecuteMsg::AddNativeTokenDecimals {\n        denom: \"uluna\".to_string(),\n        decimals: 6u8,\n    };\n\n    let info = mock_info(\"addr0000\", \u0026[]);\n\n    assert_eq!(\n        execute(deps.as_mut(), mock_env(), info, msg),\n        Err(StdError::generic_err(\n            \"a balance greater than zero is required by the factory for verification\",\n        ))\n    );\n}\n\n#[test]\nfn append_add_allow_native_token_with_already_exist_token() {\n    let mut deps = mock_dependencies(\u0026[coin(1u128, \"uluna\".to_string())]);\n    deps = init(deps);\n\n    let msg = ExecuteMsg::AddNativeTokenDecimals {\n        denom: \"uluna\".to_string(),\n\n        decimals: 6u8,\n    };\n\n    let info = mock_info(\"addr0000\", \u0026[]);\n\n    execute(deps.as_mut(), mock_env(), info.clone(), msg).unwrap();\n\n    let res = query(\n        deps.as_ref(),\n        mock_env(),\n        QueryMsg::NativeTokenDecimals {\n            denom: \"uluna\".to_string(),\n        },\n    )\n    .unwrap();\n    let res: NativeTokenDecimalsResponse = from_binary(\u0026res).unwrap();\n    assert_eq!(6u8, res.decimals);\n\n    let msg = ExecuteMsg::AddNativeTokenDecimals {\n        denom: \"uluna\".to_string(),\n        decimals: 7u8,\n    };\n\n    execute(deps.as_mut(), mock_env(), info, msg).unwrap();\n\n    let res = query(\n        deps.as_ref(),\n        mock_env(),\n        QueryMsg::NativeTokenDecimals {\n            denom: \"uluna\".to_string(),\n        },\n    )\n    .unwrap();\n    let res: NativeTokenDecimalsResponse = from_binary(\u0026res).unwrap();\n    assert_eq!(7u8, res.decimals)\n}\n\n#[test]\nfn normal_migrate_pair() {\n    let mut deps = mock_dependencies(\u0026[coin(1u128, \"uluna\".to_string())]);\n    deps = init(deps);\n\n    let msg = ExecuteMsg::MigratePair {\n        code_id: Some(123u64),\n        contract: \"contract0000\".to_string(),\n    };\n\n    let info = mock_info(\"addr0000\", \u0026[]);\n\n    assert_eq!(\n        execute(deps.as_mut(), mock_env(), info, msg).unwrap(),\n        Response::new().add_message(CosmosMsg::Wasm(WasmMsg::Migrate {\n            contract_addr: \"contract0000\".to_string(),\n            new_code_id: 123u64,\n            msg: to_binary(\u0026PairMigrateMsg {}).unwrap(),\n        })),\n    );\n}\n\n#[test]\nfn normal_migrate_pair_with_none_code_id_will_config_code_id() {\n    let mut deps = mock_dependencies(\u0026[coin(1u128, \"uluna\".to_string())]);\n    deps = init(deps);\n\n    let msg = ExecuteMsg::MigratePair {\n        code_id: None,\n        contract: \"contract0000\".to_string(),\n    };\n\n    let info = mock_info(\"addr0000\", \u0026[]);\n\n    assert_eq!(\n        execute(deps.as_mut(), mock_env(), info, msg).unwrap(),\n        Response::new().add_message(CosmosMsg::Wasm(WasmMsg::Migrate {\n            contract_addr: \"contract0000\".to_string(),\n            new_code_id: 321u64,\n            msg: to_binary(\u0026PairMigrateMsg {}).unwrap(),\n        })),\n    );\n}\n\n#[test]\nfn failed_migrate_pair_with_no_admin() {\n    let mut deps = mock_dependencies(\u0026[coin(1u128, \"uluna\".to_string())]);\n    deps = init(deps);\n\n    let msg = ExecuteMsg::MigratePair {\n        code_id: None,\n        contract: \"contract0000\".to_string(),\n    };\n\n    let info = mock_info(\"noadmin\", \u0026[]);\n\n    assert_eq!(\n        execute(deps.as_mut(), mock_env(), info, msg),\n        Err(StdError::generic_err(\"unauthorized\")),\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","haitran","AURA-NETWORK","smart-contracts-halotrade-zone","contracts","halo-pair","src","contract.rs"],"content":"use crate::error::ContractError;\nuse crate::state::PAIR_INFO;\n\n#[cfg(not(feature = \"library\"))]\nuse cosmwasm_std::entry_point;\n\nuse cosmwasm_std::{\n    from_binary, to_binary, Addr, Binary, CanonicalAddr, Coin, CosmosMsg, Decimal, Deps, DepsMut,\n    Env, MessageInfo, Reply, ReplyOn, Response, StdError, StdResult, SubMsg, Uint128, WasmMsg,\n};\n\nuse bignumber::{Decimal256, Uint256};\nuse cw2::set_contract_version;\nuse cw20::{Cw20ExecuteMsg, Cw20ReceiveMsg, MinterResponse};\nuse cw_utils::parse_reply_instantiate_data;\nuse integer_sqrt::IntegerSquareRoot;\nuse std::cmp::Ordering;\nuse std::str::FromStr;\nuse haloswap::asset::{Asset, AssetInfo, PairInfo, PairInfoRaw};\nuse haloswap::pair::{\n    Cw20HookMsg, ExecuteMsg, InstantiateMsg, MigrateMsg, PoolResponse, QueryMsg,\n    ReverseSimulationResponse, SimulationResponse,\n};\nuse haloswap::querier::query_token_info;\nuse haloswap::token::InstantiateMsg as TokenInstantiateMsg;\n\n// version info for migration info\nconst CONTRACT_NAME: \u0026str = \"crates.io:halo-pair\";\nconst CONTRACT_VERSION: \u0026str = env!(\"CARGO_PKG_VERSION\");\n\nconst INSTANTIATE_REPLY_ID: u64 = 1;\n\n/// Commission rate == 0.3%\nconst COMMISSION_RATE: \u0026str = \"0.003\";\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn instantiate(\n    deps: DepsMut,\n    env: Env,\n    _info: MessageInfo,\n    msg: InstantiateMsg,\n) -\u003e StdResult\u003cResponse\u003e {\n    set_contract_version(deps.storage, CONTRACT_NAME, CONTRACT_VERSION)?;\n\n    let pair_info: \u0026PairInfoRaw = \u0026PairInfoRaw {\n        contract_addr: deps.api.addr_canonicalize(env.contract.address.as_str())?,\n        liquidity_token: CanonicalAddr::from(vec![]),\n        asset_infos: [\n            msg.asset_infos[0].to_raw(deps.api)?,\n            msg.asset_infos[1].to_raw(deps.api)?,\n        ],\n        asset_decimals: msg.asset_decimals,\n        requirements: msg.requirements,\n    };\n\n    PAIR_INFO.save(deps.storage, pair_info)?;\n\n    Ok(Response::new().add_submessage(SubMsg {\n        // Create LP token\n        msg: WasmMsg::Instantiate {\n            admin: None,\n            code_id: msg.token_code_id,\n            msg: to_binary(\u0026TokenInstantiateMsg {\n                name: \"halo liquidity token\".to_string(),\n                symbol: \"uLP\".to_string(),\n                decimals: 6,\n                initial_balances: vec![],\n                mint: Some(MinterResponse {\n                    minter: env.contract.address.to_string(),\n                    cap: None,\n                }),\n            })?,\n            funds: vec![],\n            label: \"lp\".to_string(),\n        }\n        .into(),\n        gas_limit: None,\n        id: INSTANTIATE_REPLY_ID,\n        reply_on: ReplyOn::Success,\n    }))\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn execute(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    msg: ExecuteMsg,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    match msg {\n        ExecuteMsg::Receive(msg) =\u003e receive_cw20(deps, env, info, msg),\n        ExecuteMsg::ProvideLiquidity {\n            assets,\n            slippage_tolerance,\n            receiver,\n        } =\u003e provide_liquidity(deps, env, info, assets, slippage_tolerance, receiver),\n        ExecuteMsg::Swap {\n            offer_asset,\n            belief_price,\n            max_spread,\n            to,\n        } =\u003e {\n            if !offer_asset.is_native_token() {\n                return Err(ContractError::Unauthorized {});\n            }\n\n            let to_addr = if let Some(to_addr) = to {\n                Some(deps.api.addr_validate(\u0026to_addr)?)\n            } else {\n                None\n            };\n\n            swap(\n                deps,\n                env,\n                info.clone(),\n                info.sender,\n                offer_asset,\n                belief_price,\n                max_spread,\n                to_addr,\n            )\n        }\n    }\n}\n\npub fn receive_cw20(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    cw20_msg: Cw20ReceiveMsg,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let contract_addr = info.sender.clone();\n\n    match from_binary(\u0026cw20_msg.msg) {\n        Ok(Cw20HookMsg::Swap {\n            belief_price,\n            max_spread,\n            to,\n        }) =\u003e {\n            // only asset contract can execute this message\n            let mut authorized: bool = false;\n            let config: PairInfoRaw = PAIR_INFO.load(deps.storage)?;\n            let pools: [Asset; 2] =\n                config.query_pools(\u0026deps.querier, deps.api, env.contract.address.clone())?;\n            for pool in pools.iter() {\n                if let AssetInfo::Token { contract_addr, .. } = \u0026pool.info {\n                    if contract_addr == \u0026info.sender {\n                        authorized = true;\n                    }\n                }\n            }\n\n            if !authorized {\n                return Err(ContractError::Unauthorized {});\n            }\n\n            let to_addr = if let Some(to_addr) = to {\n                Some(deps.api.addr_validate(to_addr.as_str())?)\n            } else {\n                None\n            };\n\n            swap(\n                deps,\n                env,\n                info,\n                Addr::unchecked(cw20_msg.sender),\n                Asset {\n                    info: AssetInfo::Token {\n                        contract_addr: contract_addr.to_string(),\n                    },\n                    amount: cw20_msg.amount,\n                },\n                belief_price,\n                max_spread,\n                to_addr,\n            )\n        }\n        Ok(Cw20HookMsg::WithdrawLiquidity {}) =\u003e {\n            let config: PairInfoRaw = PAIR_INFO.load(deps.storage)?;\n            if deps.api.addr_canonicalize(info.sender.as_str())? != config.liquidity_token {\n                return Err(ContractError::Unauthorized {});\n            }\n\n            let sender_addr = deps.api.addr_validate(cw20_msg.sender.as_str())?;\n            withdraw_liquidity(deps, env, info, sender_addr, cw20_msg.amount)\n        }\n        Err(err) =\u003e Err(ContractError::Std(err)),\n    }\n}\n\n/// This just stores the result for future query\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn reply(deps: DepsMut, _env: Env, msg: Reply) -\u003e StdResult\u003cResponse\u003e {\n    let res = parse_reply_instantiate_data(msg).unwrap();\n    let liquidity_token = res.contract_address;\n\n    let api = deps.api;\n    PAIR_INFO.update(deps.storage, |mut meta| -\u003e StdResult\u003c_\u003e {\n        meta.liquidity_token = api.addr_canonicalize(\u0026liquidity_token)?;\n        Ok(meta)\n    })?;\n\n    Ok(Response::new().add_attribute(\"liquidity_token_addr\", liquidity_token))\n}\n\n/// CONTRACT - should approve contract to use the amount of token\npub fn provide_liquidity(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    assets: [Asset; 2],\n    slippage_tolerance: Option\u003cDecimal\u003e,\n    receiver: Option\u003cString\u003e,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    for asset in assets.iter() {\n        // check the balance of native token is sent with the message\n        asset.assert_sent_native_token_balance(\u0026info)?;\n    }\n\n    // get information of the pair\n    let pair_info: PairInfoRaw = PAIR_INFO.load(deps.storage)?;\n\n    // query the information of the pair of assets\n    let mut pools: [Asset; 2] = pair_info.query_pools(\u0026deps.querier, deps.api, env.contract.address.clone())?;\n\n    // get the amount of assets that user deposited after checking the assets is same as the assets in pair\n    let deposits: [Uint128; 2] = [\n        assets\n            .iter()\n            .find(|a| a.info.equal(\u0026pools[0].info))\n            .map(|a| a.amount)\n            .expect(\"Wrong asset info is given\"),\n        assets\n            .iter()\n            .find(|a| a.info.equal(\u0026pools[1].info))\n            .map(|a| a.amount)\n            .expect(\"Wrong asset info is given\"),\n    ];\n\n    // If the asset is a token, the value of pools[i] is correct. But we must take the token from the user.\n    // If the asset is a native token, the amount of native token is already sent with the message to the pool.\n    // So we must subtract that ammount of native token from the pools[i].\n    // pools[] will be used to calculate the amount of LP token to mint after.\n    let mut messages: Vec\u003cCosmosMsg\u003e = vec![];\n    for (i, pool) in pools.iter_mut().enumerate() {\n        // If the asset 'pool' is a token, then we need to execute TransferFrom msg to receive funds\n        // User must approve the pool contract to transfer the token before calling this function\n        if let AssetInfo::Token { contract_addr, .. } = \u0026pool.info {\n            messages.push(CosmosMsg::Wasm(WasmMsg::Execute {\n                contract_addr: contract_addr.to_string(),\n                msg: to_binary(\u0026Cw20ExecuteMsg::TransferFrom {\n                    owner: info.sender.to_string(),\n                    recipient: env.contract.address.to_string(),\n                    amount: deposits[i],\n                })?,\n                funds: vec![],\n            }));\n        } else {\n            // If the asset 'pool' is native token, balance is already increased\n            // To calculated properly we should subtract user deposit from the pool\n            pool.amount = pool.amount.checked_sub(deposits[i])?;\n        }\n    }\n\n    // if the user provides the slippage tolerance, we should check it\n    assert_slippage_tolerance(\u0026slippage_tolerance, \u0026deposits, \u0026pools)?;\n\n    // get the address of the LP token\n    let liquidity_token = deps.api.addr_humanize(\u0026pair_info.liquidity_token)?;\n\n    // get total supply of the LP token\n    let total_share = query_token_info(\u0026deps.querier, liquidity_token)?.total_supply;\n\n    // calculate the amount of LP token is minted to the user\n    let share = if total_share == Uint128::zero() {\n        // when pool is empty\n        // if the sender is not in whitelist of requirements, then return error\n        if !pair_info.requirements.whitelist.contains(\u0026info.sender) {\n            return Err(ContractError::Std(StdError::generic_err(\"the sender is not in whitelist\")));\n        }\n\n        // if the minimum amount of deposit is not satisfied, then return error\n        if  deposits[0] \u003c pair_info.requirements.first_asset_minimum || \n            deposits[1] \u003c pair_info.requirements.second_asset_minimum {\n            return Err(ContractError::Std(StdError::generic_err(\"the minimum deposit is not satisfied\")));\n        }\n\n        // if the total supply of the LP token is zero, Initial share = collateral amount\n        // hoanm: EQUATION - LP = \\sqrt{A * B}\n        Uint128::from((deposits[0].u128() * deposits[1].u128()).integer_sqrt())\n    } else {\n        // hoanm: update these equations by using the formula of Uniswap V2\n        // min(1, 2)\n        // 1. sqrt(deposit_0 * exchange_rate_0_to_1 * deposit_0) * (total_share / sqrt(pool_0 * pool_1))\n        // == deposit_0 * total_share / pool_0\n        // 2. sqrt(deposit_1 * exchange_rate_1_to_0 * deposit_1) * (total_share / sqrt(pool_1 * pool_1))\n        // == deposit_1 * total_share / pool_1\n        std::cmp::min(\n            deposits[0].multiply_ratio(total_share, pools[0].amount),\n            deposits[1].multiply_ratio(total_share, pools[1].amount),\n        )\n    };\n\n    // prevent providing free token (hoanm: is this necessary?)\n    if share.is_zero() {\n        return Err(ContractError::InvalidZeroAmount {});\n    }\n\n    // mint LP token to sender\n    // if the user provides the receiver, mint LP token to the receiver else mint to the sender\n    let receiver = receiver.unwrap_or_else(|| info.sender.to_string());\n\n    // mint amount of 'share' LP token to the receiver\n    messages.push(CosmosMsg::Wasm(WasmMsg::Execute {\n        contract_addr: deps\n            .api\n            .addr_humanize(\u0026pair_info.liquidity_token)?\n            .to_string(),\n        msg: to_binary(\u0026Cw20ExecuteMsg::Mint {\n            recipient: receiver.to_string(),\n            amount: share,\n        })?,\n        funds: vec![],\n    }));\n\n    Ok(Response::new().add_messages(messages).add_attributes(vec![\n        (\"action\", \"provide_liquidity\"),\n        (\"sender\", info.sender.as_str()),\n        (\"receiver\", receiver.as_str()),\n        (\"assets\", \u0026format!(\"{}, {}\", assets[0], assets[1])),\n        (\"share\", \u0026share.to_string()),\n    ]))\n}\n\npub fn withdraw_liquidity(\n    deps: DepsMut,\n    env: Env,\n    _info: MessageInfo,\n    sender: Addr,\n    amount: Uint128,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let pair_info: PairInfoRaw = PAIR_INFO.load(deps.storage)?;\n    let liquidity_addr: Addr = deps.api.addr_humanize(\u0026pair_info.liquidity_token)?;\n\n    let pools: [Asset; 2] = pair_info.query_pools(\u0026deps.querier, deps.api, env.contract.address)?;\n    let total_share: Uint128 = query_token_info(\u0026deps.querier, liquidity_addr)?.total_supply;\n\n    let share_ratio: Decimal = Decimal::from_ratio(amount, total_share);\n    let refund_assets: Vec\u003cAsset\u003e = pools\n        .iter()\n        .map(|a| Asset {\n            info: a.info.clone(),\n            amount: a.amount * share_ratio,\n        })\n        .collect();\n\n    // update pool info\n    Ok(Response::new()\n        .add_messages(vec![\n            refund_assets[0].clone().into_msg(sender.clone())?,\n            refund_assets[1].clone().into_msg(sender.clone())?,\n            // burn liquidity token\n            CosmosMsg::Wasm(WasmMsg::Execute {\n                contract_addr: deps\n                    .api\n                    .addr_humanize(\u0026pair_info.liquidity_token)?\n                    .to_string(),\n                msg: to_binary(\u0026Cw20ExecuteMsg::Burn { amount })?,\n                funds: vec![],\n            }),\n        ])\n        .add_attributes(vec![\n            (\"action\", \"withdraw_liquidity\"),\n            (\"sender\", sender.as_str()),\n            (\"withdrawn_share\", \u0026amount.to_string()),\n            (\n                \"refund_assets\",\n                \u0026format!(\"{}, {}\", refund_assets[0], refund_assets[1]),\n            ),\n        ]))\n}\n\n// CONTRACT - a user must do token approval\n#[allow(clippy::too_many_arguments)]\npub fn swap(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    sender: Addr,\n    offer_asset: Asset,\n    belief_price: Option\u003cDecimal\u003e,\n    max_spread: Option\u003cDecimal\u003e,\n    to: Option\u003cAddr\u003e,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    offer_asset.assert_sent_native_token_balance(\u0026info)?;\n\n    let pair_info: PairInfoRaw = PAIR_INFO.load(deps.storage)?;\n\n    let pools: [Asset; 2] = pair_info.query_pools(\u0026deps.querier, deps.api, env.contract.address)?;\n\n    let offer_pool: Asset;\n    let ask_pool: Asset;\n\n    let offer_decimal: u8;\n    let ask_decimal: u8;\n    // If the asset balance is already increased\n    // To calculated properly we should subtract user deposit from the pool\n    if offer_asset.info.equal(\u0026pools[0].info) {\n        offer_pool = Asset {\n            amount: pools[0].amount.checked_sub(offer_asset.amount)?,\n            info: pools[0].info.clone(),\n        };\n        ask_pool = pools[1].clone();\n\n        offer_decimal = pair_info.asset_decimals[0];\n        ask_decimal = pair_info.asset_decimals[1];\n    } else if offer_asset.info.equal(\u0026pools[1].info) {\n        offer_pool = Asset {\n            amount: pools[1].amount.checked_sub(offer_asset.amount)?,\n            info: pools[1].info.clone(),\n        };\n        ask_pool = pools[0].clone();\n\n        offer_decimal = pair_info.asset_decimals[1];\n        ask_decimal = pair_info.asset_decimals[0];\n    } else {\n        return Err(ContractError::AssetMismatch {});\n    }\n\n    let offer_amount = offer_asset.amount;\n    let (return_amount, spread_amount, commission_amount) =\n        compute_swap(offer_pool.amount, ask_pool.amount, offer_amount);\n\n    let return_asset = Asset {\n        info: ask_pool.info.clone(),\n        amount: return_amount,\n    };\n\n    // check max spread limit if exist\n    assert_max_spread(\n        belief_price,\n        max_spread,\n        offer_asset.clone(),\n        return_asset.clone(),\n        spread_amount,\n        offer_decimal,\n        ask_decimal,\n    )?;\n\n    let receiver = to.unwrap_or_else(|| sender.clone());\n\n    let mut messages: Vec\u003cCosmosMsg\u003e = vec![];\n    if !return_amount.is_zero() {\n        messages.push(return_asset.into_msg(receiver.clone())?);\n    }\n\n    // 1. send collateral token from the contract to a user\n    // 2. send inactive commission to collector\n    Ok(Response::new().add_messages(messages).add_attributes(vec![\n        (\"action\", \"swap\"),\n        (\"sender\", sender.as_str()),\n        (\"receiver\", receiver.as_str()),\n        (\"offer_asset\", \u0026offer_asset.info.to_string()),\n        (\"ask_asset\", \u0026ask_pool.info.to_string()),\n        (\"offer_amount\", \u0026offer_amount.to_string()),\n        (\"return_amount\", \u0026return_amount.to_string()),\n        (\"spread_amount\", \u0026spread_amount.to_string()),\n        (\"commission_amount\", \u0026commission_amount.to_string()),\n    ]))\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn query(deps: Deps, _env: Env, msg: QueryMsg) -\u003e Result\u003cBinary, ContractError\u003e {\n    match msg {\n        QueryMsg::Pair {} =\u003e Ok(to_binary(\u0026query_pair_info(deps)?)?),\n        QueryMsg::Pool {} =\u003e Ok(to_binary(\u0026query_pool(deps)?)?),\n        QueryMsg::Simulation { offer_asset } =\u003e {\n            Ok(to_binary(\u0026query_simulation(deps, offer_asset)?)?)\n        }\n        QueryMsg::ReverseSimulation { ask_asset } =\u003e {\n            Ok(to_binary(\u0026query_reverse_simulation(deps, ask_asset)?)?)\n        }\n    }\n}\n\npub fn query_pair_info(deps: Deps) -\u003e Result\u003cPairInfo, ContractError\u003e {\n    let pair_info: PairInfoRaw = PAIR_INFO.load(deps.storage)?;\n    let pair_info = pair_info.to_normal(deps.api)?;\n\n    Ok(pair_info)\n}\n\npub fn query_pool(deps: Deps) -\u003e Result\u003cPoolResponse, ContractError\u003e {\n    let pair_info: PairInfoRaw = PAIR_INFO.load(deps.storage)?;\n    let contract_addr = deps.api.addr_humanize(\u0026pair_info.contract_addr)?;\n    let assets: [Asset; 2] = pair_info.query_pools(\u0026deps.querier, deps.api, contract_addr)?;\n    let total_share: Uint128 = query_token_info(\n        \u0026deps.querier,\n        deps.api.addr_humanize(\u0026pair_info.liquidity_token)?,\n    )?\n    .total_supply;\n\n    let resp = PoolResponse {\n        assets,\n        total_share,\n    };\n\n    Ok(resp)\n}\n\npub fn query_simulation(\n    deps: Deps,\n    offer_asset: Asset,\n) -\u003e Result\u003cSimulationResponse, ContractError\u003e {\n    let pair_info: PairInfoRaw = PAIR_INFO.load(deps.storage)?;\n\n    let contract_addr = deps.api.addr_humanize(\u0026pair_info.contract_addr)?;\n    let pools: [Asset; 2] = pair_info.query_pools(\u0026deps.querier, deps.api, contract_addr)?;\n\n    let offer_pool: Asset;\n    let ask_pool: Asset;\n    if offer_asset.info.equal(\u0026pools[0].info) {\n        offer_pool = pools[0].clone();\n        ask_pool = pools[1].clone();\n    } else if offer_asset.info.equal(\u0026pools[1].info) {\n        offer_pool = pools[1].clone();\n        ask_pool = pools[0].clone();\n    } else {\n        return Err(ContractError::AssetMismatch {});\n    }\n\n    let (return_amount, spread_amount, commission_amount) =\n        compute_swap(offer_pool.amount, ask_pool.amount, offer_asset.amount);\n\n    Ok(SimulationResponse {\n        return_amount,\n        spread_amount,\n        commission_amount,\n    })\n}\n\npub fn query_reverse_simulation(\n    deps: Deps,\n    ask_asset: Asset,\n) -\u003e Result\u003cReverseSimulationResponse, ContractError\u003e {\n    // get pair info\n    let pair_info: PairInfoRaw = PAIR_INFO.load(deps.storage)?;\n\n    // get address of the pair contract\n    let contract_addr = deps.api.addr_humanize(\u0026pair_info.contract_addr)?;\n    \n    // get pool info of the pair contract\n    let pools: [Asset; 2] = pair_info.query_pools(\u0026deps.querier, deps.api, contract_addr)?;\n\n    let offer_pool: Asset;\n    let ask_pool: Asset;\n    if ask_asset.info.equal(\u0026pools[0].info) {\n        ask_pool = pools[0].clone();\n        offer_pool = pools[1].clone();\n    } else if ask_asset.info.equal(\u0026pools[1].info) {\n        ask_pool = pools[1].clone();\n        offer_pool = pools[0].clone();\n    } else {\n        return Err(ContractError::AssetMismatch {});\n    }\n\n    // compute offer amount, spread amount, commission amount when user provide ask amount\n    let (offer_amount, spread_amount, commission_amount) =\n        compute_offer_amount(offer_pool.amount, ask_pool.amount, ask_asset.amount);\n\n    Ok(ReverseSimulationResponse {\n        offer_amount,\n        spread_amount,\n        commission_amount,\n    })\n}\n\npub fn amount_of(coins: \u0026[Coin], denom: String) -\u003e Uint128 {\n    match coins.iter().find(|x| x.denom == denom) {\n        Some(coin) =\u003e coin.amount,\n        None =\u003e Uint128::zero(),\n    }\n}\n\n// User want to swap from 'offer' to 'ask'\n// Calculate the expected return_amount, spread_amount and commission_amount based on the formula\n// return_amount = offer_amount * (1 - spread) * ask_pool / (offer_pool + offer_amount)\nfn  compute_swap(\n    offer_pool: Uint128,\n    ask_pool: Uint128,\n    offer_amount: Uint128,\n) -\u003e (Uint128, Uint128, Uint128) {\n    let offer_pool: Uint256 = Uint256::from(offer_pool);\n    let ask_pool: Uint256 = ask_pool.into();\n    let offer_amount: Uint256 = offer_amount.into();\n\n    // Commission rate OR Fee amount for framework\n    let commission_rate = Decimal256::from_str(COMMISSION_RATE).unwrap();\n\n    // offer =\u003e ask\n    // hoanm: EQUATION - B = (R_B - \\frac{K}{R_A + A}) * (1 - F)\n    // ask_amount = (ask_pool - cp / (offer_pool + offer_amount)) * (1 - commission_rate)\n\n    // cp (constant product) is K  in the EQUATION\n    let cp: Uint256 = offer_pool * ask_pool;\n\n    // calculate the ask_amount without commission\n    let return_amount: Uint256 = (Decimal256::from_uint256(ask_pool)\n        - Decimal256::from_ratio(cp, offer_pool + offer_amount))\n        * Uint256::one();\n\n    // calculate the spread_amount\n    // hoanm: EQUATION - SPREAD = (A * \\frac{R_B}{R_A}) - B\n    let spread_amount: Uint256 =\n        (offer_amount * Decimal256::from_ratio(ask_pool, offer_pool)) - return_amount;\n\n    // calculate the commission_amount\n    let commission_amount: Uint256 = return_amount * commission_rate;\n\n    // commission will be absorbed to pool and the currency will be the same as the ask currency\n    let return_amount: Uint256 = return_amount - commission_amount;\n    (\n        return_amount.into(),\n        spread_amount.into(),\n        commission_amount.into(),\n    )\n}\n\n#[test]\nfn test_compute_swap_with_huge_pool_variance() {\n    let offer_pool = Uint128::from(395451850234u128);\n    let ask_pool = Uint128::from(317u128);\n\n    assert_eq!(\n        compute_swap(offer_pool, ask_pool, Uint128::from(1u128)).0,\n        Uint128::zero()\n    );\n}\n\n// The function to get the offer_amount when user provide ask_amount\nfn compute_offer_amount(\n    offer_pool: Uint128,\n    ask_pool: Uint128,\n    ask_amount: Uint128,\n) -\u003e (Uint128, Uint128, Uint128) {\n    let offer_pool: Uint256 = offer_pool.into();\n    let ask_pool: Uint256 = ask_pool.into();\n    let ask_amount: Uint256 = ask_amount.into();\n\n    let commission_rate = Decimal256::from_str(COMMISSION_RATE).unwrap();\n\n    // EQUATION: A = \\frac{K}{R_B - (B * (1-P))} - R_A\n    // ask =\u003e offer\n    // offer_amount = cp / (ask_pool - ask_amount / (1 - commission_rate)) - offer_pool\n    let cp: Uint256 = offer_pool * ask_pool;\n\n    let one_minus_commission = Decimal256::one() - commission_rate;\n    let inv_one_minus_commission = Decimal256::one() / one_minus_commission;\n\n    let offer_amount: Uint256 = Uint256::one()\n        .multiply_ratio(cp, ask_pool - ask_amount * inv_one_minus_commission)\n        - offer_pool;\n\n    let before_commission_deduction: Uint256 = ask_amount * inv_one_minus_commission;\n    let before_spread_deduction: Uint256 =\n        offer_amount * Decimal256::from_ratio(ask_pool, offer_pool);\n\n    let spread_amount = if before_spread_deduction \u003e before_commission_deduction {\n        before_spread_deduction - before_commission_deduction\n    } else {\n        Uint256::zero()\n    };\n\n    let commission_amount = before_commission_deduction * commission_rate;\n\n    (\n        offer_amount.into(),\n        spread_amount.into(),\n        commission_amount.into(),\n    )\n}\n\n/// If `belief_price` and `max_spread` both are given,\n/// we compute new spread else we just use halo\n/// spread to check `max_spread`\npub fn assert_max_spread(\n    belief_price: Option\u003cDecimal\u003e,\n    max_spread: Option\u003cDecimal\u003e,\n    offer_asset: Asset,\n    return_asset: Asset,\n    spread_amount: Uint128,\n    offer_decimal: u8,\n    return_decimal: u8,\n) -\u003e Result\u003c(), ContractError\u003e {\n    let (offer_amount, return_amount, spread_amount): (Uint256, Uint256, Uint256) =\n        match offer_decimal.cmp(\u0026return_decimal) {\n            Ordering::Greater =\u003e {\n                let diff_decimal = 10u64.pow((offer_decimal - return_decimal).into());\n\n                (\n                    offer_asset.amount.into(),\n                    return_asset\n                        .amount\n                        .checked_mul(Uint128::from(diff_decimal))?\n                        .into(),\n                    spread_amount\n                        .checked_mul(Uint128::from(diff_decimal))?\n                        .into(),\n                )\n            }\n            Ordering::Less =\u003e {\n                let diff_decimal = 10u64.pow((return_decimal - offer_decimal).into());\n\n                (\n                    offer_asset\n                        .amount\n                        .checked_mul(Uint128::from(diff_decimal))?\n                        .into(),\n                    return_asset.amount.into(),\n                    spread_amount.into(),\n                )\n            }\n            Ordering::Equal =\u003e (\n                offer_asset.amount.into(),\n                return_asset.amount.into(),\n                spread_amount.into(),\n            ),\n        };\n\n    if let (Some(max_spread), Some(belief_price)) = (max_spread, belief_price) {\n        let belief_price: Decimal256 = belief_price.into();\n        let max_spread: Decimal256 = max_spread.into();\n\n        let expected_return = offer_amount / belief_price;\n        let spread_amount = if expected_return \u003e return_amount {\n            expected_return - return_amount\n        } else {\n            Uint256::zero()\n        };\n\n        if return_amount \u003c expected_return\n            \u0026\u0026 Decimal256::from_ratio(spread_amount, expected_return) \u003e max_spread\n        {\n            return Err(ContractError::MaxSpreadAssertion {});\n        }\n    } else if let Some(max_spread) = max_spread {\n        let max_spread: Decimal256 = max_spread.into();\n        if Decimal256::from_ratio(spread_amount, return_amount + spread_amount) \u003e max_spread {\n            return Err(ContractError::MaxSpreadAssertion {});\n        }\n    }\n\n    Ok(())\n}\n\nfn assert_slippage_tolerance(\n    slippage_tolerance: \u0026Option\u003cDecimal\u003e,\n    deposits: \u0026[Uint128; 2],\n    pools: \u0026[Asset; 2],\n) -\u003e Result\u003c(), ContractError\u003e {\n    if let Some(slippage_tolerance) = *slippage_tolerance {\n        let slippage_tolerance: Decimal256 = slippage_tolerance.into();\n        // the slippage tolerance cannot be greater than 100%\n        if slippage_tolerance \u003e Decimal256::one() {\n            return Err(StdError::generic_err(\"slippage_tolerance cannot bigger than 1\").into());\n        }\n\n        let one_minus_slippage_tolerance = Decimal256::one() - slippage_tolerance;\n        let deposits: [Uint256; 2] = [deposits[0].into(), deposits[1].into()];\n        let pools: [Uint256; 2] = [pools[0].amount.into(), pools[1].amount.into()];\n\n        // Ensure each prices are not dropped as much as slippage tolerance rate\n        // hoanm: EQUATION - \\frac{A}{B} * (1-ST) \u003e \\frac{R_A}{R_B} \\parallel \\frac{B}{A} * (1-ST) \u003e \\frac{R_B}{R_A}\n        if Decimal256::from_ratio(deposits[0], deposits[1]) * one_minus_slippage_tolerance\n            \u003e Decimal256::from_ratio(pools[0], pools[1])\n            || Decimal256::from_ratio(deposits[1], deposits[0]) * one_minus_slippage_tolerance\n                \u003e Decimal256::from_ratio(pools[1], pools[0])\n        {\n            return Err(ContractError::MaxSlippageAssertion {});\n        }\n    }\n\n    Ok(())\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn migrate(deps: DepsMut, _env: Env, _msg: MigrateMsg) -\u003e Result\u003cResponse, ContractError\u003e {\n    set_contract_version(deps.storage, CONTRACT_NAME, CONTRACT_VERSION)?;\n\n    Ok(Response::default())\n}\n","traces":[{"line":42,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":252,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":273,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":279,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":280,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":283,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":284,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":285,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":286,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":289,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":290,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":291,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":300,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":306,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":307,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":310,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":311,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":312,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":314,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":315,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":316,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":317,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":318,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":319,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":320,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":321,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":322,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":324,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":327,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":328,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":329,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":330,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":331,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":332,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":336,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":343,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":344,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":346,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":347,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":349,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":350,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":352,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":353,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":354,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":358,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":359,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":360,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":361,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":362,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":365,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":366,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":367,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":368,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":369,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":370,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":373,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":374,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":375,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":376,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":378,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":379,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":396,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":398,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":400,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":409,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":411,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":412,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":414,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":416,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":417,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":418,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":420,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":421,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":423,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":425,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":426,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":428,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":431,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":432,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":433,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":436,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":440,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":442,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":443,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":444,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":445,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":446,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":447,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":448,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":451,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":453,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":454,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":455,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":460,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":461,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":462,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":463,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":464,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":465,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":466,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":467,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":468,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":469,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":474,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":475,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":476,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":477,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":478,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":479,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":481,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":482,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":487,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":488,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":489,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":491,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":494,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":495,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":496,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":497,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":498,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":499,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":500,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":509,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":512,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":516,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":518,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":519,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":523,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":524,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":525,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":526,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":527,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":528,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":530,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":533,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":534,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":536,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":537,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":538,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":539,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":543,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":548,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":551,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":554,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":558,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":559,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":560,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":561,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":562,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":563,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":565,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":569,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":570,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":572,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":573,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":574,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":575,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":579,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":580,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":581,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":582,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":589,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":594,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":595,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":596,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":598,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":599,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":601,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":602,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":603,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":605,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":606,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":608,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":609,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":610,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":611,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":613,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":614,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":615,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":616,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":618,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":619,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":621,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":622,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":624,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":625,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":626,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":642,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":647,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":648,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":649,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":651,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":653,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":654,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":655,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":656,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":658,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":659,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":661,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":662,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":663,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":665,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":666,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":667,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":669,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":670,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":672,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":675,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":678,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":679,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":680,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":687,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":696,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":697,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":699,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":702,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":703,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":704,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":705,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":706,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":707,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":708,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":709,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":713,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":716,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":717,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":718,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":719,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":720,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":721,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":724,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":725,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":726,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":727,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":731,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":732,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":733,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":735,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":736,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":737,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":739,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":742,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":743,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":745,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":747,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":748,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":749,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":750,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":754,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":762,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":763,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":764,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":765,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":766,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":769,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":770,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":771,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":773,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":774,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":775,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":776,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":777,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":778,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":780,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":784,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":789,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":791,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":373,"coverable":399},{"path":["/","Users","haitran","AURA-NETWORK","smart-contracts-halotrade-zone","contracts","halo-pair","src","error.rs"],"content":"use cosmwasm_std::{OverflowError, StdError};\nuse thiserror::Error;\n\n#[derive(Error, Debug, PartialEq)]\npub enum ContractError {\n    #[error(\"{0}\")]\n    Std(#[from] StdError),\n\n    #[error(\"{0}\")]\n    OverflowError(#[from] OverflowError),\n\n    #[error(\"Unauthorized\")]\n    Unauthorized {},\n\n    #[error(\"Invalid zero amount\")]\n    InvalidZeroAmount {},\n\n    #[error(\"Max spread assertion\")]\n    MaxSpreadAssertion {},\n\n    #[error(\"Max slippage assertion\")]\n    MaxSlippageAssertion {},\n\n    #[error(\"Asset mismatch\")]\n    AssetMismatch {},\n\n    #[error(\"Too small offer amount\")]\n    TooSmallOfferAmount {},\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","haitran","AURA-NETWORK","smart-contracts-halotrade-zone","contracts","halo-pair","src","lib.rs"],"content":"pub mod contract;\npub mod state;\n\nmod error;\n\n#[cfg(test)]\nmod testing;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","haitran","AURA-NETWORK","smart-contracts-halotrade-zone","contracts","halo-pair","src","state.rs"],"content":"use cw_storage_plus::Item;\nuse haloswap::asset::PairInfoRaw;\n\npub const PAIR_INFO: Item\u003cPairInfoRaw\u003e = Item::new(\"pair_info\");\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","haitran","AURA-NETWORK","smart-contracts-halotrade-zone","contracts","halo-pair","src","testing.rs"],"content":"use crate::contract::{\n    assert_max_spread, execute, instantiate, query_pair_info, query_pool, query_reverse_simulation,\n    query_simulation, reply,\n};\nuse crate::error::ContractError;\nuse haloswap::mock_querier::mock_dependencies;\n\nuse cosmwasm_std::testing::{mock_env, mock_info, MOCK_CONTRACT_ADDR};\nuse cosmwasm_std::{\n    attr, to_binary, BankMsg, Coin, CosmosMsg, Decimal, Reply, ReplyOn, Response, StdError, SubMsg,\n    SubMsgResponse, SubMsgResult, Uint128, WasmMsg, Addr,\n};\nuse cw20::{Cw20ExecuteMsg, Cw20ReceiveMsg, MinterResponse};\nuse haloswap::asset::{Asset, AssetInfo, PairInfo, CreatePairRequirements};\nuse haloswap::pair::{\n    Cw20HookMsg, ExecuteMsg, InstantiateMsg, PoolResponse, ReverseSimulationResponse,\n    SimulationResponse,\n};\nuse haloswap::token::InstantiateMsg as TokenInstantiateMsg;\n\n#[test]\nfn proper_initialization() {\n    let mut deps = mock_dependencies(\u0026[]);\n\n    let msg = InstantiateMsg {\n        asset_infos: [\n            AssetInfo::NativeToken {\n                denom: \"uusd\".to_string(),\n            },\n            AssetInfo::Token {\n                contract_addr: \"asset0000\".to_string(),\n            },\n        ],\n        token_code_id: 10u64,\n        asset_decimals: [6u8, 8u8],\n        requirements: CreatePairRequirements {\n            whitelist: vec![Addr::unchecked(\"addr0000\")],\n            first_asset_minimum: Uint128::zero(),\n            second_asset_minimum: Uint128::zero(),\n        },\n    };\n\n    // we can just call .unwrap() to assert this was a success\n    let env = mock_env();\n    let info = mock_info(\"addr0000\", \u0026[]);\n    let res = instantiate(deps.as_mut(), env, info, msg).unwrap();\n    assert_eq!(\n        res.messages,\n        vec![SubMsg {\n            msg: WasmMsg::Instantiate {\n                code_id: 10u64,\n                msg: to_binary(\u0026TokenInstantiateMsg {\n                    name: \"halo liquidity token\".to_string(),\n                    symbol: \"uLP\".to_string(),\n                    decimals: 6,\n                    initial_balances: vec![],\n                    mint: Some(MinterResponse {\n                        minter: MOCK_CONTRACT_ADDR.to_string(),\n                        cap: None,\n                    }),\n                })\n                .unwrap(),\n                funds: vec![],\n                label: \"lp\".to_string(),\n                admin: None,\n            }\n            .into(),\n            gas_limit: None,\n            id: 1,\n            reply_on: ReplyOn::Success,\n        }]\n    );\n\n    // store liquidity token\n    let reply_msg = Reply {\n        id: 1,\n        result: SubMsgResult::Ok(SubMsgResponse {\n            events: vec![],\n            data: Some(\n                vec![\n                    10, 13, 108, 105, 113, 117, 105, 100, 105, 116, 121, 48, 48, 48, 48,\n                ]\n                .into(),\n            ),\n        }),\n    };\n\n    let _res = reply(deps.as_mut(), mock_env(), reply_msg).unwrap();\n\n    // it worked, let's query the state\n    let pair_info: PairInfo = query_pair_info(deps.as_ref()).unwrap();\n    assert_eq!(\"liquidity0000\", pair_info.liquidity_token.as_str());\n    assert_eq!(\n        pair_info.asset_infos,\n        [\n            AssetInfo::NativeToken {\n                denom: \"uusd\".to_string(),\n            },\n            AssetInfo::Token {\n                contract_addr: \"asset0000\".to_string()\n            }\n        ]\n    );\n}\n\n#[test]\nfn provide_liquidity() {\n    let mut deps = mock_dependencies(\u0026[Coin {\n        denom: \"uusd\".to_string(),\n        amount: Uint128::from(200u128),\n    }]);\n\n    deps.querier.with_token_balances(\u0026[\n        (\n            \u0026\"liquidity0000\".to_string(),\n            \u0026[(\u0026MOCK_CONTRACT_ADDR.to_string(), \u0026Uint128::zero())],\n        ),\n        (\u0026\"asset0000\".to_string(), \u0026[]),\n    ]);\n\n    let msg = InstantiateMsg {\n        asset_infos: [\n            AssetInfo::NativeToken {\n                denom: \"uusd\".to_string(),\n            },\n            AssetInfo::Token {\n                contract_addr: \"asset0000\".to_string(),\n            },\n        ],\n        token_code_id: 10u64,\n        asset_decimals: [6u8, 8u8],\n        requirements: CreatePairRequirements {\n            whitelist: vec![Addr::unchecked(\"addr0000\")],\n            first_asset_minimum: Uint128::zero(),\n            second_asset_minimum: Uint128::zero(),\n        },\n    };\n\n    let env = mock_env();\n    let info = mock_info(\"addr0000\", \u0026[]);\n    // we can just call .unwrap() to assert this was a success\n    let _res = instantiate(deps.as_mut(), env, info, msg).unwrap();\n\n    // store liquidity token\n    let reply_msg = Reply {\n        id: 1,\n        result: SubMsgResult::Ok(SubMsgResponse {\n            events: vec![],\n            data: Some(\n                vec![\n                    10, 13, 108, 105, 113, 117, 105, 100, 105, 116, 121, 48, 48, 48, 48,\n                ]\n                .into(),\n            ),\n        }),\n    };\n\n    let _res = reply(deps.as_mut(), mock_env(), reply_msg).unwrap();\n\n    // successfully provide liquidity for the exist pool\n    let msg = ExecuteMsg::ProvideLiquidity {\n        assets: [\n            Asset {\n                info: AssetInfo::Token {\n                    contract_addr: \"asset0000\".to_string(),\n                },\n                amount: Uint128::from(100u128),\n            },\n            Asset {\n                info: AssetInfo::NativeToken {\n                    denom: \"uusd\".to_string(),\n                },\n                amount: Uint128::from(100u128),\n            },\n        ],\n        slippage_tolerance: None,\n        receiver: None,\n    };\n\n    let env = mock_env();\n    let info = mock_info(\n        \"addr0000\",\n        \u0026[Coin {\n            denom: \"uusd\".to_string(),\n            amount: Uint128::from(100u128),\n        }],\n    );\n    let res = execute(deps.as_mut(), env, info, msg).unwrap();\n    let transfer_from_msg = res.messages.get(0).expect(\"no message\");\n    let mint_msg = res.messages.get(1).expect(\"no message\");\n    assert_eq!(\n        transfer_from_msg,\n        \u0026SubMsg::new(CosmosMsg::Wasm(WasmMsg::Execute {\n            contract_addr: \"asset0000\".to_string(),\n            msg: to_binary(\u0026Cw20ExecuteMsg::TransferFrom {\n                owner: \"addr0000\".to_string(),\n                recipient: MOCK_CONTRACT_ADDR.to_string(),\n                amount: Uint128::from(100u128),\n            })\n            .unwrap(),\n            funds: vec![],\n        }))\n    );\n    assert_eq!(\n        mint_msg,\n        \u0026SubMsg::new(CosmosMsg::Wasm(WasmMsg::Execute {\n            contract_addr: \"liquidity0000\".to_string(),\n            msg: to_binary(\u0026Cw20ExecuteMsg::Mint {\n                recipient: \"addr0000\".to_string(),\n                amount: Uint128::from(100u128),\n            })\n            .unwrap(),\n            funds: vec![],\n        }))\n    );\n\n    // provide more liquidity 1:2, which is not proportional to 1:1,\n    // then it must accept 1:1 and treat left amount as donation\n    deps.querier.with_balance(\u0026[(\n        \u0026MOCK_CONTRACT_ADDR.to_string(),\n        vec![Coin {\n            denom: \"uusd\".to_string(),\n            amount: Uint128::from(\n                200u128 + 200u128, /* user deposit must be pre-applied */\n            ),\n        }],\n    )]);\n\n    deps.querier.with_token_balances(\u0026[\n        (\n            \u0026\"liquidity0000\".to_string(),\n            \u0026[(\u0026MOCK_CONTRACT_ADDR.to_string(), \u0026Uint128::from(100u128))],\n        ),\n        (\n            \u0026\"asset0000\".to_string(),\n            \u0026[(\u0026MOCK_CONTRACT_ADDR.to_string(), \u0026Uint128::from(200u128))],\n        ),\n    ]);\n\n    let msg = ExecuteMsg::ProvideLiquidity {\n        assets: [\n            Asset {\n                info: AssetInfo::Token {\n                    contract_addr: \"asset0000\".to_string(),\n                },\n                amount: Uint128::from(100u128),\n            },\n            Asset {\n                info: AssetInfo::NativeToken {\n                    denom: \"uusd\".to_string(),\n                },\n                amount: Uint128::from(200u128),\n            },\n        ],\n        slippage_tolerance: None,\n        receiver: Some(\"staking0000\".to_string()), // try changing receiver\n    };\n\n    let env = mock_env();\n    let info = mock_info(\n        \"addr0000\",\n        \u0026[Coin {\n            denom: \"uusd\".to_string(),\n            amount: Uint128::from(200u128),\n        }],\n    );\n\n    // only accept 100, then 50 share will be generated with 100 * (100 / 200)\n    let res: Response = execute(deps.as_mut(), env, info, msg).unwrap();\n    let transfer_from_msg = res.messages.get(0).expect(\"no message\");\n    let mint_msg = res.messages.get(1).expect(\"no message\");\n    assert_eq!(\n        transfer_from_msg,\n        \u0026SubMsg::new(CosmosMsg::Wasm(WasmMsg::Execute {\n            contract_addr: \"asset0000\".to_string(),\n            msg: to_binary(\u0026Cw20ExecuteMsg::TransferFrom {\n                owner: \"addr0000\".to_string(),\n                recipient: MOCK_CONTRACT_ADDR.to_string(),\n                amount: Uint128::from(100u128),\n            })\n            .unwrap(),\n            funds: vec![],\n        }))\n    );\n    assert_eq!(\n        mint_msg,\n        \u0026SubMsg::new(CosmosMsg::Wasm(WasmMsg::Execute {\n            contract_addr: \"liquidity0000\".to_string(),\n            msg: to_binary(\u0026Cw20ExecuteMsg::Mint {\n                recipient: \"staking0000\".to_string(), // LP tokens sent to specified receiver\n                amount: Uint128::from(50u128),\n            })\n            .unwrap(),\n            funds: vec![],\n        }))\n    );\n\n    // check wrong argument\n    let msg = ExecuteMsg::ProvideLiquidity {\n        assets: [\n            Asset {\n                info: AssetInfo::Token {\n                    contract_addr: \"asset0000\".to_string(),\n                },\n                amount: Uint128::from(100u128),\n            },\n            Asset {\n                info: AssetInfo::NativeToken {\n                    denom: \"uusd\".to_string(),\n                },\n                amount: Uint128::from(50u128),\n            },\n        ],\n        slippage_tolerance: None,\n        receiver: None,\n    };\n\n    let env = mock_env();\n    let info = mock_info(\n        \"addr0000\",\n        \u0026[Coin {\n            denom: \"uusd\".to_string(),\n            amount: Uint128::from(100u128),\n        }],\n    );\n    let res = execute(deps.as_mut(), env, info, msg).unwrap_err();\n    match res {\n        ContractError::Std(StdError::GenericErr { msg, .. }) =\u003e assert_eq!(\n            msg,\n            \"Native token balance mismatch between the argument and the transferred\".to_string()\n        ),\n        _ =\u003e panic!(\"Must return generic error\"),\n    }\n\n    // initialize token balance to 1:1\n    deps.querier.with_balance(\u0026[(\n        \u0026MOCK_CONTRACT_ADDR.to_string(),\n        vec![Coin {\n            denom: \"uusd\".to_string(),\n            amount: Uint128::from(\n                100u128 + 100u128, /* user deposit must be pre-applied */\n            ),\n        }],\n    )]);\n\n    deps.querier.with_token_balances(\u0026[\n        (\n            \u0026\"liquidity0000\".to_string(),\n            \u0026[(\u0026MOCK_CONTRACT_ADDR.to_string(), \u0026Uint128::from(100u128))],\n        ),\n        (\n            \u0026\"asset0000\".to_string(),\n            \u0026[(\u0026MOCK_CONTRACT_ADDR.to_string(), \u0026Uint128::from(100u128))],\n        ),\n    ]);\n\n    // failed because the price is under slippage_tolerance\n    let msg = ExecuteMsg::ProvideLiquidity {\n        assets: [\n            Asset {\n                info: AssetInfo::Token {\n                    contract_addr: \"asset0000\".to_string(),\n                },\n                amount: Uint128::from(98u128),\n            },\n            Asset {\n                info: AssetInfo::NativeToken {\n                    denom: \"uusd\".to_string(),\n                },\n                amount: Uint128::from(100u128),\n            },\n        ],\n        slippage_tolerance: Some(Decimal::percent(1)),\n        receiver: None,\n    };\n\n    let env = mock_env();\n    let info = mock_info(\n        \"addr0001\",\n        \u0026[Coin {\n            denom: \"uusd\".to_string(),\n            amount: Uint128::from(100u128),\n        }],\n    );\n    let res = execute(deps.as_mut(), env, info, msg).unwrap_err();\n    match res {\n        ContractError::MaxSlippageAssertion {} =\u003e {}\n        _ =\u003e panic!(\"DO NOT ENTER HERE\"),\n    }\n\n    // initialize token balance to 1:1\n    deps.querier.with_balance(\u0026[(\n        \u0026MOCK_CONTRACT_ADDR.to_string(),\n        vec![Coin {\n            denom: \"uusd\".to_string(),\n            amount: Uint128::from(100u128 + 98u128 /* user deposit must be pre-applied */),\n        }],\n    )]);\n\n    // failed because the price is under slippage_tolerance\n    let msg = ExecuteMsg::ProvideLiquidity {\n        assets: [\n            Asset {\n                info: AssetInfo::Token {\n                    contract_addr: \"asset0000\".to_string(),\n                },\n                amount: Uint128::from(100u128),\n            },\n            Asset {\n                info: AssetInfo::NativeToken {\n                    denom: \"uusd\".to_string(),\n                },\n                amount: Uint128::from(98u128),\n            },\n        ],\n        slippage_tolerance: Some(Decimal::percent(1)),\n        receiver: None,\n    };\n\n    let env = mock_env();\n    let info = mock_info(\n        \"addr0001\",\n        \u0026[Coin {\n            denom: \"uusd\".to_string(),\n            amount: Uint128::from(98u128),\n        }],\n    );\n    let res = execute(deps.as_mut(), env, info, msg).unwrap_err();\n    match res {\n        ContractError::MaxSlippageAssertion {} =\u003e {}\n        _ =\u003e panic!(\"DO NOT ENTER HERE\"),\n    }\n\n    // initialize token balance to 1:1\n    deps.querier.with_balance(\u0026[(\n        \u0026MOCK_CONTRACT_ADDR.to_string(),\n        vec![Coin {\n            denom: \"uusd\".to_string(),\n            amount: Uint128::from(\n                100u128 + 100u128, /* user deposit must be pre-applied */\n            ),\n        }],\n    )]);\n\n    // successfully provides\n    let msg = ExecuteMsg::ProvideLiquidity {\n        assets: [\n            Asset {\n                info: AssetInfo::Token {\n                    contract_addr: \"asset0000\".to_string(),\n                },\n                amount: Uint128::from(99u128),\n            },\n            Asset {\n                info: AssetInfo::NativeToken {\n                    denom: \"uusd\".to_string(),\n                },\n                amount: Uint128::from(100u128),\n            },\n        ],\n        slippage_tolerance: Some(Decimal::percent(1)),\n        receiver: None,\n    };\n\n    let env = mock_env();\n    let info = mock_info(\n        \"addr0001\",\n        \u0026[Coin {\n            denom: \"uusd\".to_string(),\n            amount: Uint128::from(100u128),\n        }],\n    );\n    let _res = execute(deps.as_mut(), env, info, msg).unwrap();\n\n    // initialize token balance to 1:1\n    deps.querier.with_balance(\u0026[(\n        \u0026MOCK_CONTRACT_ADDR.to_string(),\n        vec![Coin {\n            denom: \"uusd\".to_string(),\n            amount: Uint128::from(100u128 + 99u128 /* user deposit must be pre-applied */),\n        }],\n    )]);\n\n    // successfully provides\n    let msg = ExecuteMsg::ProvideLiquidity {\n        assets: [\n            Asset {\n                info: AssetInfo::Token {\n                    contract_addr: \"asset0000\".to_string(),\n                },\n                amount: Uint128::from(100u128),\n            },\n            Asset {\n                info: AssetInfo::NativeToken {\n                    denom: \"uusd\".to_string(),\n                },\n                amount: Uint128::from(99u128),\n            },\n        ],\n        slippage_tolerance: Some(Decimal::percent(1)),\n        receiver: None,\n    };\n\n    let env = mock_env();\n    let info = mock_info(\n        \"addr0001\",\n        \u0026[Coin {\n            denom: \"uusd\".to_string(),\n            amount: Uint128::from(99u128),\n        }],\n    );\n    let _res = execute(deps.as_mut(), env, info, msg).unwrap();\n}\n\n#[test]\nfn withdraw_liquidity() {\n    let mut deps = mock_dependencies(\u0026[Coin {\n        denom: \"uusd\".to_string(),\n        amount: Uint128::from(100u128),\n    }]);\n\n    deps.querier.with_token_balances(\u0026[\n        (\n            \u0026\"liquidity0000\".to_string(),\n            \u0026[(\u0026\"addr0000\".to_string(), \u0026Uint128::from(100u128))],\n        ),\n        (\n            \u0026\"asset0000\".to_string(),\n            \u0026[(\u0026MOCK_CONTRACT_ADDR.to_string(), \u0026Uint128::from(100u128))],\n        ),\n    ]);\n\n    let msg = InstantiateMsg {\n        asset_infos: [\n            AssetInfo::NativeToken {\n                denom: \"uusd\".to_string(),\n            },\n            AssetInfo::Token {\n                contract_addr: \"asset0000\".to_string(),\n            },\n        ],\n        token_code_id: 10u64,\n        asset_decimals: [6u8, 8u8],\n        requirements: CreatePairRequirements {\n            whitelist: vec![Addr::unchecked(\"addr0000\")],\n            first_asset_minimum: Uint128::zero(),\n            second_asset_minimum: Uint128::zero(),\n        },\n    };\n\n    let env = mock_env();\n    let info = mock_info(\"addr0000\", \u0026[]);\n    // we can just call .unwrap() to assert this was a success\n    let _res = instantiate(deps.as_mut(), env, info, msg).unwrap();\n\n    // store liquidity token\n    let reply_msg = Reply {\n        id: 1,\n        result: SubMsgResult::Ok(SubMsgResponse {\n            events: vec![],\n            data: Some(\n                vec![\n                    10, 13, 108, 105, 113, 117, 105, 100, 105, 116, 121, 48, 48, 48, 48,\n                ]\n                .into(),\n            ),\n        }),\n    };\n\n    let _res = reply(deps.as_mut(), mock_env(), reply_msg).unwrap();\n\n    // withdraw liquidity\n    let msg = ExecuteMsg::Receive(Cw20ReceiveMsg {\n        sender: \"addr0000\".to_string(),\n        msg: to_binary(\u0026Cw20HookMsg::WithdrawLiquidity {}).unwrap(),\n        amount: Uint128::from(100u128),\n    });\n\n    let env = mock_env();\n    let info = mock_info(\"liquidity0000\", \u0026[]);\n    let res = execute(deps.as_mut(), env, info, msg).unwrap();\n    let log_withdrawn_share = res.attributes.get(2).expect(\"no log\");\n    let log_refund_assets = res.attributes.get(3).expect(\"no log\");\n    let msg_refund_0 = res.messages.get(0).expect(\"no message\");\n    let msg_refund_1 = res.messages.get(1).expect(\"no message\");\n    let msg_burn_liquidity = res.messages.get(2).expect(\"no message\");\n    assert_eq!(\n        msg_refund_0,\n        \u0026SubMsg::new(CosmosMsg::Bank(BankMsg::Send {\n            to_address: \"addr0000\".to_string(),\n            amount: vec![Coin {\n                denom: \"uusd\".to_string(),\n                amount: Uint128::from(100u128),\n            }],\n        }))\n    );\n    assert_eq!(\n        msg_refund_1,\n        \u0026SubMsg::new(CosmosMsg::Wasm(WasmMsg::Execute {\n            contract_addr: \"asset0000\".to_string(),\n            msg: to_binary(\u0026Cw20ExecuteMsg::Transfer {\n                recipient: \"addr0000\".to_string(),\n                amount: Uint128::from(100u128),\n            })\n            .unwrap(),\n            funds: vec![],\n        }))\n    );\n    assert_eq!(\n        msg_burn_liquidity,\n        \u0026SubMsg::new(CosmosMsg::Wasm(WasmMsg::Execute {\n            contract_addr: \"liquidity0000\".to_string(),\n            msg: to_binary(\u0026Cw20ExecuteMsg::Burn {\n                amount: Uint128::from(100u128),\n            })\n            .unwrap(),\n            funds: vec![],\n        }))\n    );\n\n    assert_eq!(\n        log_withdrawn_share,\n        \u0026attr(\"withdrawn_share\", 100u128.to_string())\n    );\n    assert_eq!(\n        log_refund_assets,\n        \u0026attr(\"refund_assets\", \"100uusd, 100asset0000\")\n    );\n}\n\n#[test]\nfn try_native_to_token() {\n    let total_share = Uint128::from(30000000000u128);\n    let asset_pool_amount = Uint128::from(20000000000u128);\n    let collateral_pool_amount = Uint128::from(30000000000u128);\n    let exchange_rate: Decimal = Decimal::from_ratio(asset_pool_amount, collateral_pool_amount);\n    let offer_amount = Uint128::from(1500000000u128);\n\n    let mut deps = mock_dependencies(\u0026[Coin {\n        denom: \"uusd\".to_string(),\n        amount: collateral_pool_amount + offer_amount, /* user deposit must be pre-applied */\n    }]);\n\n    deps.querier.with_token_balances(\u0026[\n        (\n            \u0026\"liquidity0000\".to_string(),\n            \u0026[(\u0026MOCK_CONTRACT_ADDR.to_string(), \u0026total_share)],\n        ),\n        (\n            \u0026\"asset0000\".to_string(),\n            \u0026[(\u0026MOCK_CONTRACT_ADDR.to_string(), \u0026asset_pool_amount)],\n        ),\n    ]);\n\n    let msg = InstantiateMsg {\n        asset_infos: [\n            AssetInfo::NativeToken {\n                denom: \"uusd\".to_string(),\n            },\n            AssetInfo::Token {\n                contract_addr: \"asset0000\".to_string(),\n            },\n        ],\n        token_code_id: 10u64,\n        asset_decimals: [6u8, 8u8],\n        requirements: CreatePairRequirements {\n            whitelist: vec![Addr::unchecked(\"addr0000\")],\n            first_asset_minimum: Uint128::zero(),\n            second_asset_minimum: Uint128::zero(),\n        },\n    };\n\n    let env = mock_env();\n    let info = mock_info(\"addr0000\", \u0026[]);\n    // we can just call .unwrap() to assert this was a success\n    let _res = instantiate(deps.as_mut(), env, info, msg).unwrap();\n\n    // store liquidity token\n    let reply_msg = Reply {\n        id: 1,\n        result: SubMsgResult::Ok(SubMsgResponse {\n            events: vec![],\n            data: Some(\n                vec![\n                    10, 13, 108, 105, 113, 117, 105, 100, 105, 116, 121, 48, 48, 48, 48,\n                ]\n                .into(),\n            ),\n        }),\n    };\n\n    let _res = reply(deps.as_mut(), mock_env(), reply_msg).unwrap();\n\n    // normal swap\n    let msg = ExecuteMsg::Swap {\n        offer_asset: Asset {\n            info: AssetInfo::NativeToken {\n                denom: \"uusd\".to_string(),\n            },\n            amount: offer_amount,\n        },\n        belief_price: None,\n        max_spread: None,\n        to: None,\n    };\n    let env = mock_env();\n    let info = mock_info(\n        \"addr0000\",\n        \u0026[Coin {\n            denom: \"uusd\".to_string(),\n            amount: offer_amount,\n        }],\n    );\n    let res = execute(deps.as_mut(), env, info, msg).unwrap();\n    let msg_transfer = res.messages.get(0).expect(\"no message\");\n\n    // current price is 1.5, so expected return without spread is 1000\n    // 952.380952 = 20000 - 20000 * 30000 / (30000 + 1500)\n    let expected_ret_amount = Uint128::from(952_380_952u128);\n    let expected_spread_amount = (offer_amount * exchange_rate)\n        .checked_sub(expected_ret_amount)\n        .unwrap();\n    let expected_commission_amount = expected_ret_amount.multiply_ratio(3u128, 1000u128); // 0.3%\n    let expected_return_amount = expected_ret_amount\n        .checked_sub(expected_commission_amount)\n        .unwrap();\n    // check simulation res\n    deps.querier.with_balance(\u0026[(\n        \u0026MOCK_CONTRACT_ADDR.to_string(),\n        vec![Coin {\n            denom: \"uusd\".to_string(),\n            amount: collateral_pool_amount, /* user deposit must be pre-applied */\n        }],\n    )]);\n\n    let simulation_res: SimulationResponse = query_simulation(\n        deps.as_ref(),\n        Asset {\n            info: AssetInfo::NativeToken {\n                denom: \"uusd\".to_string(),\n            },\n            amount: offer_amount,\n        },\n    )\n    .unwrap();\n    assert_eq!(expected_return_amount, simulation_res.return_amount);\n    assert_eq!(expected_commission_amount, simulation_res.commission_amount);\n    assert_eq!(expected_spread_amount, simulation_res.spread_amount);\n\n    // check reverse simulation res\n    let reverse_simulation_res: ReverseSimulationResponse = query_reverse_simulation(\n        deps.as_ref(),\n        Asset {\n            info: AssetInfo::Token {\n                contract_addr: \"asset0000\".to_string(),\n            },\n            amount: expected_return_amount,\n        },\n    )\n    .unwrap();\n\n    assert!(\n        (offer_amount.u128() as i128 - reverse_simulation_res.offer_amount.u128() as i128).abs()\n            \u003c 3i128\n    );\n    assert!(\n        (expected_commission_amount.u128() as i128\n            - reverse_simulation_res.commission_amount.u128() as i128)\n            .abs()\n            \u003c 3i128\n    );\n    assert!(\n        (expected_spread_amount.u128() as i128\n            - reverse_simulation_res.spread_amount.u128() as i128)\n            .abs()\n            \u003c 3i128\n    );\n\n    assert_eq!(\n        res.attributes,\n        vec![\n            attr(\"action\", \"swap\"),\n            attr(\"sender\", \"addr0000\"),\n            attr(\"receiver\", \"addr0000\"),\n            attr(\"offer_asset\", \"uusd\"),\n            attr(\"ask_asset\", \"asset0000\"),\n            attr(\"offer_amount\", offer_amount.to_string()),\n            attr(\"return_amount\", expected_return_amount.to_string()),\n            attr(\"spread_amount\", expected_spread_amount.to_string()),\n            attr(\"commission_amount\", expected_commission_amount.to_string()),\n        ]\n    );\n\n    assert_eq!(\n        \u0026SubMsg::new(CosmosMsg::Wasm(WasmMsg::Execute {\n            contract_addr: \"asset0000\".to_string(),\n            msg: to_binary(\u0026Cw20ExecuteMsg::Transfer {\n                recipient: \"addr0000\".to_string(),\n                amount: expected_return_amount,\n            })\n            .unwrap(),\n            funds: vec![],\n        })),\n        msg_transfer,\n    );\n}\n\n#[test]\nfn try_token_to_native() {\n    let total_share = Uint128::from(20000000000u128);\n    let asset_pool_amount = Uint128::from(30000000000u128);\n    let collateral_pool_amount = Uint128::from(20000000000u128);\n    let exchange_rate = Decimal::from_ratio(collateral_pool_amount, asset_pool_amount);\n    let offer_amount = Uint128::from(1500000000u128);\n\n    let mut deps = mock_dependencies(\u0026[Coin {\n        denom: \"uusd\".to_string(),\n        amount: collateral_pool_amount,\n    }]);\n    deps.querier.with_token_balances(\u0026[\n        (\n            \u0026\"liquidity0000\".to_string(),\n            \u0026[(\u0026MOCK_CONTRACT_ADDR.to_string(), \u0026total_share)],\n        ),\n        (\n            \u0026\"asset0000\".to_string(),\n            \u0026[(\n                \u0026MOCK_CONTRACT_ADDR.to_string(),\n                \u0026(asset_pool_amount + offer_amount),\n            )],\n        ),\n    ]);\n\n    let msg = InstantiateMsg {\n        asset_infos: [\n            AssetInfo::NativeToken {\n                denom: \"uusd\".to_string(),\n            },\n            AssetInfo::Token {\n                contract_addr: \"asset0000\".to_string(),\n            },\n        ],\n        token_code_id: 10u64,\n        asset_decimals: [8u8, 8u8],\n        requirements: CreatePairRequirements {\n            whitelist: vec![Addr::unchecked(\"addr0000\")],\n            first_asset_minimum: Uint128::zero(),\n            second_asset_minimum: Uint128::zero(),\n        },\n    };\n\n    let env = mock_env();\n    let info = mock_info(\"addr0000\", \u0026[]);\n    // we can just call .unwrap() to assert this was a success\n    let _res = instantiate(deps.as_mut(), env, info, msg).unwrap();\n\n    // store liquidity token\n    let reply_msg = Reply {\n        id: 1,\n        result: SubMsgResult::Ok(SubMsgResponse {\n            events: vec![],\n            data: Some(\n                vec![\n                    10, 13, 108, 105, 113, 117, 105, 100, 105, 116, 121, 48, 48, 48, 48,\n                ]\n                .into(),\n            ),\n        }),\n    };\n\n    let _res = reply(deps.as_mut(), mock_env(), reply_msg).unwrap();\n\n    // unauthorized access; can not execute swap directly for token swap\n    let msg = ExecuteMsg::Swap {\n        offer_asset: Asset {\n            info: AssetInfo::Token {\n                contract_addr: \"asset0000\".to_string(),\n            },\n            amount: offer_amount,\n        },\n        belief_price: None,\n        max_spread: None,\n        to: None,\n    };\n    let env = mock_env();\n    let info = mock_info(\"addr0000\", \u0026[]);\n    let res = execute(deps.as_mut(), env, info, msg).unwrap_err();\n    match res {\n        ContractError::Unauthorized {} =\u003e (),\n        _ =\u003e panic!(\"DO NOT ENTER HERE\"),\n    }\n\n    // normal sell\n    let msg = ExecuteMsg::Receive(Cw20ReceiveMsg {\n        sender: \"addr0000\".to_string(),\n        amount: offer_amount,\n        msg: to_binary(\u0026Cw20HookMsg::Swap {\n            belief_price: None,\n            max_spread: None,\n            to: None,\n        })\n        .unwrap(),\n    });\n    let env = mock_env();\n    let info = mock_info(\"asset0000\", \u0026[]);\n\n    let res = execute(deps.as_mut(), env, info, msg).unwrap();\n    let msg_transfer = res.messages.get(0).expect(\"no message\");\n\n    // current price is 1.5, so expected return without spread is 1000\n    // 952.380952 = 20000 - 20000 * 30000 / (30000 + 1500)\n    let expected_ret_amount = Uint128::from(952_380_952u128);\n    let expected_spread_amount = (offer_amount * exchange_rate)\n        .checked_sub(expected_ret_amount)\n        .unwrap();\n    let expected_commission_amount = expected_ret_amount.multiply_ratio(3u128, 1000u128); // 0.3%\n    let expected_return_amount = expected_ret_amount\n        .checked_sub(expected_commission_amount)\n        .unwrap();\n    // check simulation res\n    // return asset token balance as normal\n    deps.querier.with_token_balances(\u0026[\n        (\n            \u0026\"liquidity0000\".to_string(),\n            \u0026[(\u0026MOCK_CONTRACT_ADDR.to_string(), \u0026total_share)],\n        ),\n        (\n            \u0026\"asset0000\".to_string(),\n            \u0026[(\u0026MOCK_CONTRACT_ADDR.to_string(), \u0026(asset_pool_amount))],\n        ),\n    ]);\n\n    let simulation_res: SimulationResponse = query_simulation(\n        deps.as_ref(),\n        Asset {\n            amount: offer_amount,\n            info: AssetInfo::Token {\n                contract_addr: \"asset0000\".to_string(),\n            },\n        },\n    )\n    .unwrap();\n    assert_eq!(expected_return_amount, simulation_res.return_amount);\n    assert_eq!(expected_commission_amount, simulation_res.commission_amount);\n    assert_eq!(expected_spread_amount, simulation_res.spread_amount);\n\n    // check reverse simulation res\n    let reverse_simulation_res: ReverseSimulationResponse = query_reverse_simulation(\n        deps.as_ref(),\n        Asset {\n            amount: expected_return_amount,\n            info: AssetInfo::NativeToken {\n                denom: \"uusd\".to_string(),\n            },\n        },\n    )\n    .unwrap();\n    assert!(\n        (offer_amount.u128() as i128 - reverse_simulation_res.offer_amount.u128() as i128).abs()\n            \u003c 3i128\n    );\n    assert!(\n        (expected_commission_amount.u128() as i128\n            - reverse_simulation_res.commission_amount.u128() as i128)\n            .abs()\n            \u003c 3i128\n    );\n    assert!(\n        (expected_spread_amount.u128() as i128\n            - reverse_simulation_res.spread_amount.u128() as i128)\n            .abs()\n            \u003c 3i128\n    );\n\n    assert_eq!(\n        res.attributes,\n        vec![\n            attr(\"action\", \"swap\"),\n            attr(\"sender\", \"addr0000\"),\n            attr(\"receiver\", \"addr0000\"),\n            attr(\"offer_asset\", \"asset0000\"),\n            attr(\"ask_asset\", \"uusd\"),\n            attr(\"offer_amount\", offer_amount.to_string()),\n            attr(\"return_amount\", expected_return_amount.to_string()),\n            attr(\"spread_amount\", expected_spread_amount.to_string()),\n            attr(\"commission_amount\", expected_commission_amount.to_string()),\n        ]\n    );\n\n    assert_eq!(\n        \u0026SubMsg::new(CosmosMsg::Bank(BankMsg::Send {\n            to_address: \"addr0000\".to_string(),\n            amount: vec![Coin {\n                denom: \"uusd\".to_string(),\n                amount: expected_return_amount\n            }],\n        })),\n        msg_transfer,\n    );\n\n    // failed due to non asset token contract try to execute sell\n    let msg = ExecuteMsg::Receive(Cw20ReceiveMsg {\n        sender: \"addr0000\".to_string(),\n        amount: offer_amount,\n        msg: to_binary(\u0026Cw20HookMsg::Swap {\n            belief_price: None,\n            max_spread: None,\n            to: None,\n        })\n        .unwrap(),\n    });\n    let env = mock_env();\n    let info = mock_info(\"liquidity0000\", \u0026[]);\n    let res = execute(deps.as_mut(), env, info, msg).unwrap_err();\n    match res {\n        ContractError::Unauthorized {} =\u003e (),\n        _ =\u003e panic!(\"DO NOT ENTER HERE\"),\n    }\n}\n\n#[test]\nfn test_max_spread() {\n    let offer_asset_info = AssetInfo::NativeToken {\n        denom: \"offer_asset\".to_string(),\n    };\n    let ask_asset_info = AssetInfo::NativeToken {\n        denom: \"ask_asset_info\".to_string(),\n    };\n\n    assert_max_spread(\n        Some(Decimal::from_ratio(1200u128, 1u128)),\n        Some(Decimal::percent(1)),\n        Asset {\n            info: offer_asset_info.clone(),\n            amount: Uint128::from(1200000000u128),\n        },\n        Asset {\n            info: ask_asset_info.clone(),\n            amount: Uint128::from(989999u128),\n        },\n        Uint128::zero(),\n        6u8,\n        6u8,\n    )\n    .unwrap_err();\n\n    assert_max_spread(\n        Some(Decimal::from_ratio(1200u128, 1u128)),\n        Some(Decimal::percent(1)),\n        Asset {\n            info: offer_asset_info.clone(),\n            amount: Uint128::from(1200000000u128),\n        },\n        Asset {\n            info: ask_asset_info.clone(),\n            amount: Uint128::from(990000u128),\n        },\n        Uint128::zero(),\n        6u8,\n        6u8,\n    )\n    .unwrap();\n\n    assert_max_spread(\n        None,\n        Some(Decimal::percent(1)),\n        Asset {\n            info: offer_asset_info.clone(),\n            amount: Uint128::zero(),\n        },\n        Asset {\n            info: ask_asset_info.clone(),\n            amount: Uint128::from(989999u128),\n        },\n        Uint128::from(10001u128),\n        6u8,\n        6u8,\n    )\n    .unwrap_err();\n\n    assert_max_spread(\n        None,\n        Some(Decimal::percent(1)),\n        Asset {\n            info: offer_asset_info,\n            amount: Uint128::zero(),\n        },\n        Asset {\n            info: ask_asset_info,\n            amount: Uint128::from(990000u128),\n        },\n        Uint128::from(10000u128),\n        6u8,\n        6u8,\n    )\n    .unwrap();\n}\n\n#[test]\nfn test_max_spread_with_diff_decimal() {\n    let token_addr = \"ask_asset_info\".to_string();\n\n    let mut deps = mock_dependencies(\u0026[]);\n    deps.querier.with_token_balances(\u0026[(\n        \u0026token_addr,\n        \u0026[(\n            \u0026MOCK_CONTRACT_ADDR.to_string(),\n            \u0026Uint128::from(10000000000u64),\n        )],\n    )]);\n    let offer_asset_info = AssetInfo::NativeToken {\n        denom: \"offer_asset\".to_string(),\n    };\n    let ask_asset_info = AssetInfo::Token {\n        contract_addr: token_addr.to_string(),\n    };\n\n    assert_max_spread(\n        Some(Decimal::from_ratio(1200u128, 1u128)),\n        Some(Decimal::percent(1)),\n        Asset {\n            info: offer_asset_info.clone(),\n            amount: Uint128::from(1200000000u128),\n        },\n        Asset {\n            info: ask_asset_info.clone(),\n            amount: Uint128::from(100000000u128),\n        },\n        Uint128::zero(),\n        6u8,\n        8u8,\n    )\n    .unwrap();\n\n    assert_max_spread(\n        Some(Decimal::from_ratio(1200u128, 1u128)),\n        Some(Decimal::percent(1)),\n        Asset {\n            info: offer_asset_info,\n            amount: Uint128::from(1200000000u128),\n        },\n        Asset {\n            info: ask_asset_info,\n            amount: Uint128::from(98999999u128),\n        },\n        Uint128::zero(),\n        6u8,\n        8u8,\n    )\n    .unwrap_err();\n\n    let offer_asset_info = AssetInfo::Token {\n        contract_addr: token_addr,\n    };\n    let ask_asset_info = AssetInfo::NativeToken {\n        denom: \"offer_asset\".to_string(),\n    };\n\n    assert_max_spread(\n        Some(Decimal::from_ratio(1200u128, 1u128)),\n        Some(Decimal::percent(1)),\n        Asset {\n            info: offer_asset_info.clone(),\n            amount: Uint128::from(120000000000u128),\n        },\n        Asset {\n            info: ask_asset_info.clone(),\n            amount: Uint128::from(1000000u128),\n        },\n        Uint128::zero(),\n        8u8,\n        6u8,\n    )\n    .unwrap();\n\n    assert_max_spread(\n        Some(Decimal::from_ratio(1200u128, 1u128)),\n        Some(Decimal::percent(1)),\n        Asset {\n            info: offer_asset_info,\n            amount: Uint128::from(120000000000u128),\n        },\n        Asset {\n            info: ask_asset_info,\n            amount: Uint128::from(989999u128),\n        },\n        Uint128::zero(),\n        8u8,\n        6u8,\n    )\n    .unwrap_err();\n}\n\n#[test]\nfn test_query_pool() {\n    let total_share_amount = Uint128::from(111u128);\n    let asset_0_amount = Uint128::from(222u128);\n    let asset_1_amount = Uint128::from(333u128);\n    let mut deps = mock_dependencies(\u0026[Coin {\n        denom: \"uusd\".to_string(),\n        amount: asset_0_amount,\n    }]);\n\n    deps.querier.with_token_balances(\u0026[\n        (\n            \u0026\"asset0000\".to_string(),\n            \u0026[(\u0026MOCK_CONTRACT_ADDR.to_string(), \u0026asset_1_amount)],\n        ),\n        (\n            \u0026\"liquidity0000\".to_string(),\n            \u0026[(\u0026MOCK_CONTRACT_ADDR.to_string(), \u0026total_share_amount)],\n        ),\n    ]);\n\n    let msg = InstantiateMsg {\n        asset_infos: [\n            AssetInfo::NativeToken {\n                denom: \"uusd\".to_string(),\n            },\n            AssetInfo::Token {\n                contract_addr: \"asset0000\".to_string(),\n            },\n        ],\n        token_code_id: 10u64,\n        asset_decimals: [6u8, 8u8],\n        requirements: CreatePairRequirements {\n            whitelist: vec![Addr::unchecked(\"addr0000\")],\n            first_asset_minimum: Uint128::zero(),\n            second_asset_minimum: Uint128::zero(),\n        },\n    };\n\n    let env = mock_env();\n    let info = mock_info(\"addr0000\", \u0026[]);\n    // we can just call .unwrap() to assert this was a success\n    let _res = instantiate(deps.as_mut(), env, info, msg).unwrap();\n\n    // store liquidity token\n    let reply_msg = Reply {\n        id: 1,\n        result: SubMsgResult::Ok(SubMsgResponse {\n            events: vec![],\n            data: Some(\n                vec![\n                    10, 13, 108, 105, 113, 117, 105, 100, 105, 116, 121, 48, 48, 48, 48,\n                ]\n                .into(),\n            ),\n        }),\n    };\n\n    let _res = reply(deps.as_mut(), mock_env(), reply_msg).unwrap();\n\n    let res: PoolResponse = query_pool(deps.as_ref()).unwrap();\n\n    assert_eq!(\n        res.assets,\n        [\n            Asset {\n                info: AssetInfo::NativeToken {\n                    denom: \"uusd\".to_string(),\n                },\n                amount: asset_0_amount\n            },\n            Asset {\n                info: AssetInfo::Token {\n                    contract_addr: \"asset0000\".to_string(),\n                },\n                amount: asset_1_amount\n            }\n        ]\n    );\n    assert_eq!(res.total_share, total_share_amount);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","haitran","AURA-NETWORK","smart-contracts-halotrade-zone","contracts","halo-router","src","contract.rs"],"content":"#[cfg(not(feature = \"library\"))]\nuse cosmwasm_std::entry_point;\n\nuse cosmwasm_std::{\n    from_binary, to_binary, Addr, Api, Binary, CosmosMsg, Deps, DepsMut, Env, MessageInfo,\n    Response, StdError, StdResult, Uint128, WasmMsg,\n};\nuse cw2::set_contract_version;\n\nuse crate::operations::execute_swap_operation;\nuse crate::state::{Config, CONFIG};\n\nuse cw20::Cw20ReceiveMsg;\nuse std::collections::HashMap;\nuse haloswap::asset::{Asset, AssetInfo, PairInfo};\nuse haloswap::pair::SimulationResponse;\nuse haloswap::querier::{query_pair_info, reverse_simulate, simulate};\nuse haloswap::router::{\n    ConfigResponse, Cw20HookMsg, ExecuteMsg, InstantiateMsg, MigrateMsg, QueryMsg,\n    SimulateSwapOperationsResponse, SwapOperation,\n};\n\n// version info for migration info\nconst CONTRACT_NAME: \u0026str = \"crates.io:halo-router\";\nconst CONTRACT_VERSION: \u0026str = env!(\"CARGO_PKG_VERSION\");\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn instantiate(\n    deps: DepsMut,\n    _env: Env,\n    _info: MessageInfo,\n    msg: InstantiateMsg,\n) -\u003e StdResult\u003cResponse\u003e {\n    set_contract_version(deps.storage, CONTRACT_NAME, CONTRACT_VERSION)?;\n\n    CONFIG.save(\n        deps.storage,\n        \u0026Config {\n            halo_factory: deps.api.addr_canonicalize(\u0026msg.halo_factory)?,\n        },\n    )?;\n\n    Ok(Response::default())\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn execute(deps: DepsMut, env: Env, info: MessageInfo, msg: ExecuteMsg) -\u003e StdResult\u003cResponse\u003e {\n    match msg {\n        ExecuteMsg::Receive(msg) =\u003e receive_cw20(deps, env, info, msg),\n        ExecuteMsg::ExecuteSwapOperations {\n            operations,\n            minimum_receive,\n            to,\n        } =\u003e {\n            let api = deps.api;\n            execute_swap_operations(\n                deps,\n                env,\n                info.sender,\n                operations,\n                minimum_receive,\n                optional_addr_validate(api, to)?,\n            )\n        }\n        ExecuteMsg::ExecuteSwapOperation { operation, to } =\u003e {\n            let api = deps.api;\n            execute_swap_operation(\n                deps,\n                env,\n                info,\n                operation,\n                optional_addr_validate(api, to)?.map(|v| v.to_string()),\n            )\n        }\n        ExecuteMsg::AssertMinimumReceive {\n            asset_info,\n            prev_balance,\n            minimum_receive,\n            receiver,\n        } =\u003e assert_minium_receive(\n            deps.as_ref(),\n            asset_info,\n            prev_balance,\n            minimum_receive,\n            deps.api.addr_validate(\u0026receiver)?,\n        ),\n    }\n}\n\nfn optional_addr_validate(api: \u0026dyn Api, addr: Option\u003cString\u003e) -\u003e StdResult\u003cOption\u003cAddr\u003e\u003e {\n    let addr = if let Some(addr) = addr {\n        Some(api.addr_validate(\u0026addr)?)\n    } else {\n        None\n    };\n\n    Ok(addr)\n}\n\npub fn receive_cw20(\n    deps: DepsMut,\n    env: Env,\n    _info: MessageInfo,\n    cw20_msg: Cw20ReceiveMsg,\n) -\u003e StdResult\u003cResponse\u003e {\n    let sender = deps.api.addr_validate(\u0026cw20_msg.sender)?;\n    match from_binary(\u0026cw20_msg.msg)? {\n        Cw20HookMsg::ExecuteSwapOperations {\n            operations,\n            minimum_receive,\n            to,\n        } =\u003e {\n            let api = deps.api;\n            execute_swap_operations(\n                deps,\n                env,\n                sender,\n                operations,\n                minimum_receive,\n                optional_addr_validate(api, to)?,\n            )\n        }\n    }\n}\n\npub fn execute_swap_operations(\n    deps: DepsMut,\n    env: Env,\n    sender: Addr,\n    operations: Vec\u003cSwapOperation\u003e,\n    minimum_receive: Option\u003cUint128\u003e,\n    to: Option\u003cAddr\u003e,\n) -\u003e StdResult\u003cResponse\u003e {\n    let operations_len = operations.len();\n    if operations_len == 0 {\n        return Err(StdError::generic_err(\"must provide operations\"));\n    }\n\n    // Assert the operations are properly set\n    assert_operations(\u0026operations)?;\n\n    let to = if let Some(to) = to { to } else { sender };\n    let target_asset_info = operations.last().unwrap().get_target_asset_info();\n\n    let mut operation_index = 0;\n    let mut messages: Vec\u003cCosmosMsg\u003e = operations\n        .into_iter()\n        .map(|op| {\n            operation_index += 1;\n            Ok(CosmosMsg::Wasm(WasmMsg::Execute {\n                contract_addr: env.contract.address.to_string(),\n                funds: vec![],\n                msg: to_binary(\u0026ExecuteMsg::ExecuteSwapOperation {\n                    operation: op,\n                    to: if operation_index == operations_len {\n                        Some(to.to_string())\n                    } else {\n                        None\n                    },\n                })?,\n            }))\n        })\n        .collect::\u003cStdResult\u003cVec\u003cCosmosMsg\u003e\u003e\u003e()?;\n\n    // Execute minimum amount assertion\n    if let Some(minimum_receive) = minimum_receive {\n        let receiver_balance = target_asset_info.query_pool(\u0026deps.querier, deps.api, to.clone())?;\n\n        messages.push(CosmosMsg::Wasm(WasmMsg::Execute {\n            contract_addr: env.contract.address.to_string(),\n            funds: vec![],\n            msg: to_binary(\u0026ExecuteMsg::AssertMinimumReceive {\n                asset_info: target_asset_info,\n                prev_balance: receiver_balance,\n                minimum_receive,\n                receiver: to.to_string(),\n            })?,\n        }))\n    }\n\n    Ok(Response::new().add_messages(messages))\n}\n\nfn assert_minium_receive(\n    deps: Deps,\n    asset_info: AssetInfo,\n    prev_balance: Uint128,\n    minium_receive: Uint128,\n    receiver: Addr,\n) -\u003e StdResult\u003cResponse\u003e {\n    let receiver_balance = asset_info.query_pool(\u0026deps.querier, deps.api, receiver)?;\n    let swap_amount = receiver_balance.checked_sub(prev_balance)?;\n\n    if swap_amount \u003c minium_receive {\n        return Err(StdError::generic_err(format!(\n            \"assertion failed; minimum receive amount: {}, swap amount: {}\",\n            minium_receive, swap_amount\n        )));\n    }\n\n    Ok(Response::default())\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn query(deps: Deps, _env: Env, msg: QueryMsg) -\u003e StdResult\u003cBinary\u003e {\n    match msg {\n        QueryMsg::Config {} =\u003e to_binary(\u0026query_config(deps)?),\n        QueryMsg::SimulateSwapOperations {\n            offer_amount,\n            operations,\n        } =\u003e to_binary(\u0026simulate_swap_operations(deps, offer_amount, operations)?),\n        QueryMsg::ReverseSimulateSwapOperations {\n            ask_amount,\n            operations,\n        } =\u003e to_binary(\u0026reverse_simulate_swap_operations(\n            deps, ask_amount, operations,\n        )?),\n    }\n}\n\npub fn query_config(deps: Deps) -\u003e StdResult\u003cConfigResponse\u003e {\n    let state = CONFIG.load(deps.storage)?;\n    let resp = ConfigResponse {\n        halo_factory: deps\n            .api\n            .addr_humanize(\u0026state.halo_factory)?\n            .to_string(),\n    };\n\n    Ok(resp)\n}\n\nfn simulate_swap_operations(\n    deps: Deps,\n    offer_amount: Uint128,\n    operations: Vec\u003cSwapOperation\u003e,\n) -\u003e StdResult\u003cSimulateSwapOperationsResponse\u003e {\n    let config: Config = CONFIG.load(deps.storage)?;\n    let halo_factory = deps.api.addr_humanize(\u0026config.halo_factory)?;\n\n    let operations_len = operations.len();\n    if operations_len == 0 {\n        return Err(StdError::generic_err(\"must provide operations\"));\n    }\n\n    let mut offer_amount = offer_amount;\n    for operation in operations.into_iter() {\n        match operation {\n            SwapOperation::HaloSwap {\n                offer_asset_info,\n                ask_asset_info,\n            } =\u003e {\n                let pair_info: PairInfo = query_pair_info(\n                    \u0026deps.querier,\n                    halo_factory.clone(),\n                    \u0026[offer_asset_info.clone(), ask_asset_info.clone()],\n                )?;\n\n                let res: SimulationResponse = simulate(\n                    \u0026deps.querier,\n                    Addr::unchecked(pair_info.contract_addr),\n                    \u0026Asset {\n                        info: offer_asset_info,\n                        amount: offer_amount,\n                    },\n                )?;\n\n                offer_amount = res.return_amount;\n            }\n        }\n    }\n\n    Ok(SimulateSwapOperationsResponse {\n        amount: offer_amount,\n    })\n}\n\nfn reverse_simulate_swap_operations(\n    deps: Deps,\n    ask_amount: Uint128,\n    operations: Vec\u003cSwapOperation\u003e,\n) -\u003e StdResult\u003cSimulateSwapOperationsResponse\u003e {\n    let config: Config = CONFIG.load(deps.storage)?;\n\n    let operations_len = operations.len();\n    if operations_len == 0 {\n        return Err(StdError::generic_err(\"must provide operations\"));\n    }\n\n    let mut ask_amount = ask_amount;\n    for operation in operations.into_iter().rev() {\n        ask_amount = match operation {\n            SwapOperation::HaloSwap {\n                offer_asset_info,\n                ask_asset_info,\n            } =\u003e {\n                let halo_factory = deps.api.addr_humanize(\u0026config.halo_factory)?;\n\n                reverse_simulate_return_amount(\n                    deps,\n                    halo_factory,\n                    ask_amount,\n                    offer_asset_info,\n                    ask_asset_info,\n                )\n                .unwrap()\n            }\n        }\n    }\n\n    Ok(SimulateSwapOperationsResponse { amount: ask_amount })\n}\n\nfn reverse_simulate_return_amount(\n    deps: Deps,\n    factory: Addr,\n    ask_amount: Uint128,\n    offer_asset_info: AssetInfo,\n    ask_asset_info: AssetInfo,\n) -\u003e StdResult\u003cUint128\u003e {\n    let pair_info: PairInfo = query_pair_info(\n        \u0026deps.querier,\n        factory,\n        \u0026[offer_asset_info, ask_asset_info.clone()],\n    )?;\n\n    let res = reverse_simulate(\n        \u0026deps.querier,\n        Addr::unchecked(pair_info.contract_addr),\n        \u0026Asset {\n            amount: ask_amount,\n            info: ask_asset_info,\n        },\n    )?;\n\n    Ok(res.offer_amount)\n}\n\nfn assert_operations(operations: \u0026[SwapOperation]) -\u003e StdResult\u003c()\u003e {\n    let mut ask_asset_map: HashMap\u003cString, bool\u003e = HashMap::new();\n    for operation in operations.iter() {\n        let (offer_asset, ask_asset) = match operation {\n            SwapOperation::HaloSwap {\n                offer_asset_info,\n                ask_asset_info,\n            } =\u003e (offer_asset_info.clone(), ask_asset_info.clone()),\n        };\n\n        ask_asset_map.remove(\u0026offer_asset.to_string());\n        ask_asset_map.insert(ask_asset.to_string(), true);\n    }\n\n    if ask_asset_map.keys().len() != 1 {\n        return Err(StdError::generic_err(\n            \"invalid operations; multiple output token\",\n        ));\n    }\n\n    Ok(())\n}\n\n#[test]\nfn test_invalid_operations() {\n    // empty error\n    assert!(assert_operations(\u0026[]).is_err());\n\n    // uluna output\n    assert!(assert_operations(\u0026[\n        SwapOperation::HaloSwap {\n            offer_asset_info: AssetInfo::NativeToken {\n                denom: \"ukrw\".to_string(),\n            },\n            ask_asset_info: AssetInfo::Token {\n                contract_addr: \"asset0001\".to_string(),\n            },\n        },\n        SwapOperation::HaloSwap {\n            offer_asset_info: AssetInfo::Token {\n                contract_addr: \"asset0001\".to_string(),\n            },\n            ask_asset_info: AssetInfo::NativeToken {\n                denom: \"uluna\".to_string(),\n            },\n        }\n    ])\n    .is_ok());\n\n    // asset0002 output\n    assert!(assert_operations(\u0026[\n        SwapOperation::HaloSwap {\n            offer_asset_info: AssetInfo::NativeToken {\n                denom: \"ukrw\".to_string(),\n            },\n            ask_asset_info: AssetInfo::Token {\n                contract_addr: \"asset0001\".to_string(),\n            },\n        },\n        SwapOperation::HaloSwap {\n            offer_asset_info: AssetInfo::Token {\n                contract_addr: \"asset0001\".to_string(),\n            },\n            ask_asset_info: AssetInfo::NativeToken {\n                denom: \"uluna\".to_string(),\n            },\n        },\n        SwapOperation::HaloSwap {\n            offer_asset_info: AssetInfo::NativeToken {\n                denom: \"uluna\".to_string(),\n            },\n            ask_asset_info: AssetInfo::Token {\n                contract_addr: \"asset0002\".to_string(),\n            },\n        },\n    ])\n    .is_ok());\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn migrate(deps: DepsMut, _env: Env, _msg: MigrateMsg) -\u003e StdResult\u003cResponse\u003e {\n    set_contract_version(deps.storage, CONTRACT_NAME, CONTRACT_VERSION)?;\n    Ok(Response::default())\n}\n","traces":[{"line":34,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":250,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":260,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":264,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":268,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":273,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":274,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":278,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":283,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":285,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":286,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":287,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":290,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":291,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":292,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":293,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":294,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":295,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":297,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":299,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":300,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":302,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":303,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":304,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":306,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":311,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":314,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":322,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":323,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":324,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":328,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":329,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":330,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":331,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":332,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":336,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":339,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":340,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":341,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":342,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":343,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":344,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":345,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":346,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":349,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":350,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":353,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":354,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":355,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":359,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":420,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":421,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":171,"coverable":175},{"path":["/","Users","haitran","AURA-NETWORK","smart-contracts-halotrade-zone","contracts","halo-router","src","lib.rs"],"content":"pub mod contract;\npub mod state;\n\nmod operations;\n\n#[cfg(test)]\nmod testing;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","haitran","AURA-NETWORK","smart-contracts-halotrade-zone","contracts","halo-router","src","operations.rs"],"content":"use cosmwasm_std::{\n    to_binary, Addr, Coin, CosmosMsg, Decimal, Deps, DepsMut, Env, MessageInfo, Response, StdError,\n    StdResult, WasmMsg,\n};\n\nuse crate::state::{Config, CONFIG};\n\nuse cw20::Cw20ExecuteMsg;\nuse haloswap::asset::{Asset, AssetInfo, PairInfo};\nuse haloswap::pair::Cw20HookMsg as PairHookMsg;\nuse haloswap::querier::{query_balance, query_pair_info, query_token_balance};\nuse haloswap::router::SwapOperation;\n\n/// Execute swap operation\n/// swap all offer asset to ask asset\npub fn execute_swap_operation(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    operation: SwapOperation,\n    to: Option\u003cString\u003e,\n) -\u003e StdResult\u003cResponse\u003e {\n    if env.contract.address != info.sender {\n        return Err(StdError::generic_err(\"unauthorized\"));\n    }\n\n    let messages: Vec\u003cCosmosMsg\u003e = match operation {\n        SwapOperation::HaloSwap {\n            offer_asset_info,\n            ask_asset_info,\n        } =\u003e {\n            let config: Config = CONFIG.load(deps.as_ref().storage)?;\n            let halo_factory = deps.api.addr_humanize(\u0026config.halo_factory)?;\n            let pair_info: PairInfo = query_pair_info(\n                \u0026deps.querier,\n                halo_factory,\n                \u0026[offer_asset_info.clone(), ask_asset_info],\n            )?;\n\n            let amount = match offer_asset_info.clone() {\n                AssetInfo::NativeToken { denom } =\u003e {\n                    query_balance(\u0026deps.querier, env.contract.address, denom)?\n                }\n                AssetInfo::Token { contract_addr } =\u003e query_token_balance(\n                    \u0026deps.querier,\n                    deps.api.addr_validate(contract_addr.as_str())?,\n                    env.contract.address,\n                )?,\n            };\n            let offer_asset: Asset = Asset {\n                info: offer_asset_info,\n                amount,\n            };\n\n            vec![asset_into_swap_msg(\n                deps.as_ref(),\n                Addr::unchecked(pair_info.contract_addr),\n                offer_asset,\n                None,\n                to,\n            )?]\n        }\n    };\n\n    Ok(Response::new().add_messages(messages))\n}\n\npub fn asset_into_swap_msg(\n    _deps: Deps,\n    pair_contract: Addr,\n    offer_asset: Asset,\n    max_spread: Option\u003cDecimal\u003e,\n    to: Option\u003cString\u003e,\n) -\u003e StdResult\u003cCosmosMsg\u003e {\n    match offer_asset.info.clone() {\n        AssetInfo::NativeToken { denom } =\u003e Ok(CosmosMsg::Wasm(WasmMsg::Execute {\n            contract_addr: pair_contract.to_string(),\n            funds: vec![Coin {\n                denom,\n                amount: offer_asset.amount,\n            }],\n            msg: to_binary(\u0026PairHookMsg::Swap {\n                belief_price: None,\n                max_spread,\n                to,\n            })?,\n        })),\n        AssetInfo::Token { contract_addr } =\u003e Ok(CosmosMsg::Wasm(WasmMsg::Execute {\n            contract_addr,\n            funds: vec![],\n            msg: to_binary(\u0026Cw20ExecuteMsg::Send {\n                contract: pair_contract.to_string(),\n                amount: offer_asset.amount,\n                msg: to_binary(\u0026PairHookMsg::Swap {\n                    belief_price: None,\n                    max_spread,\n                    to,\n                })?,\n            })?,\n        })),\n    }\n}\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":2},"fn_name":null}],"covered":46,"coverable":46},{"path":["/","Users","haitran","AURA-NETWORK","smart-contracts-halotrade-zone","contracts","halo-router","src","state.rs"],"content":"use schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\n\nuse cosmwasm_std::CanonicalAddr;\nuse cw_storage_plus::Item;\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\npub struct Config {\n    pub halo_factory: CanonicalAddr,\n}\n\npub const CONFIG: Item\u003cConfig\u003e = Item::new(\"config\");\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","haitran","AURA-NETWORK","smart-contracts-halotrade-zone","contracts","halo-router","src","testing","integration_test.rs"],"content":"","traces":[],"covered":0,"coverable":0},{"path":["/","Users","haitran","AURA-NETWORK","smart-contracts-halotrade-zone","contracts","halo-router","src","testing","mod.rs"],"content":"mod tests;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","haitran","AURA-NETWORK","smart-contracts-halotrade-zone","contracts","halo-router","src","testing","tests.rs"],"content":"use cosmwasm_std::testing::{mock_env, mock_info, MOCK_CONTRACT_ADDR};\nuse cosmwasm_std::{\n    coin, from_binary, to_binary, Addr, Coin, CosmosMsg, StdError, SubMsg, Uint128, WasmMsg,\n};\n\nuse crate::contract::{execute, instantiate, query};\nuse crate::operations::asset_into_swap_msg;\nuse haloswap::mock_querier::mock_dependencies;\n\nuse cw20::{Cw20ExecuteMsg, Cw20ReceiveMsg};\nuse haloswap::asset::{Asset, AssetInfo, PairInfo, CreatePairRequirements};\nuse haloswap::pair::Cw20HookMsg as PairHookMsg;\nuse haloswap::router::{\n    ConfigResponse, Cw20HookMsg, ExecuteMsg, InstantiateMsg, QueryMsg,\n    SimulateSwapOperationsResponse, SwapOperation,\n};\n\n#[test]\nfn proper_initialization() {\n    let mut deps = mock_dependencies(\u0026[]);\n\n    let msg = InstantiateMsg {\n        halo_factory: \"halofactory\".to_string(),\n    };\n\n    let info = mock_info(\"addr0000\", \u0026[]);\n\n    // we can just call .unwrap() to assert this was a success\n    let _res = instantiate(deps.as_mut(), mock_env(), info, msg).unwrap();\n\n    // it worked, let's query the state\n    let config: ConfigResponse =\n        from_binary(\u0026query(deps.as_ref(), mock_env(), QueryMsg::Config {}).unwrap()).unwrap();\n    assert_eq!(\"halofactory\", config.halo_factory.as_str());\n}\n\n#[test]\nfn execute_swap_operations() {\n    let mut deps = mock_dependencies(\u0026[]);\n    deps.querier.with_token_balances(\u0026[(\n        \u0026\"asset0002\".to_string(),\n        \u0026[(\u0026MOCK_CONTRACT_ADDR.to_string(), \u0026Uint128::from(1000000u128))],\n    )]);\n\n    let msg = InstantiateMsg {\n        halo_factory: \"halofactory\".to_string(),\n    };\n\n    let info = mock_info(\"addr0000\", \u0026[]);\n\n    // we can just call .unwrap() to assert this was a success\n    let _res = instantiate(deps.as_mut(), mock_env(), info, msg).unwrap();\n\n    let msg = ExecuteMsg::ExecuteSwapOperations {\n        operations: vec![],\n        minimum_receive: None,\n        to: None,\n    };\n\n    let info = mock_info(\"addr0000\", \u0026[]);\n    let res = execute(deps.as_mut(), mock_env(), info, msg);\n    match res {\n        Err(StdError::GenericErr { msg, .. }) =\u003e assert_eq!(msg, \"must provide operations\"),\n        _ =\u003e panic!(\"DO NOT ENTER HERE\"),\n    }\n\n    let msg = ExecuteMsg::ExecuteSwapOperations {\n        operations: vec![\n            SwapOperation::HaloSwap {\n                offer_asset_info: AssetInfo::NativeToken {\n                    denom: \"ukrw\".to_string(),\n                },\n                ask_asset_info: AssetInfo::Token {\n                    contract_addr: \"asset0001\".to_string(),\n                },\n            },\n            SwapOperation::HaloSwap {\n                offer_asset_info: AssetInfo::Token {\n                    contract_addr: \"asset0001\".to_string(),\n                },\n                ask_asset_info: AssetInfo::NativeToken {\n                    denom: \"uluna\".to_string(),\n                },\n            },\n            SwapOperation::HaloSwap {\n                offer_asset_info: AssetInfo::NativeToken {\n                    denom: \"uluna\".to_string(),\n                },\n                ask_asset_info: AssetInfo::Token {\n                    contract_addr: \"asset0002\".to_string(),\n                },\n            },\n        ],\n        minimum_receive: Some(Uint128::from(1000000u128)),\n        to: None,\n    };\n\n    let info = mock_info(\"addr0000\", \u0026[]);\n    let res = execute(deps.as_mut(), mock_env(), info, msg).unwrap();\n    assert_eq!(\n        res.messages,\n        vec![\n            SubMsg::new(CosmosMsg::Wasm(WasmMsg::Execute {\n                contract_addr: MOCK_CONTRACT_ADDR.to_string(),\n                funds: vec![],\n                msg: to_binary(\u0026ExecuteMsg::ExecuteSwapOperation {\n                    operation: SwapOperation::HaloSwap {\n                        offer_asset_info: AssetInfo::NativeToken {\n                            denom: \"ukrw\".to_string(),\n                        },\n                        ask_asset_info: AssetInfo::Token {\n                            contract_addr: \"asset0001\".to_string(),\n                        },\n                    },\n                    to: None,\n                })\n                .unwrap(),\n            })),\n            SubMsg::new(CosmosMsg::Wasm(WasmMsg::Execute {\n                contract_addr: MOCK_CONTRACT_ADDR.to_string(),\n                funds: vec![],\n                msg: to_binary(\u0026ExecuteMsg::ExecuteSwapOperation {\n                    operation: SwapOperation::HaloSwap {\n                        offer_asset_info: AssetInfo::Token {\n                            contract_addr: \"asset0001\".to_string(),\n                        },\n                        ask_asset_info: AssetInfo::NativeToken {\n                            denom: \"uluna\".to_string(),\n                        },\n                    },\n                    to: None,\n                })\n                .unwrap(),\n            })),\n            SubMsg::new(CosmosMsg::Wasm(WasmMsg::Execute {\n                contract_addr: MOCK_CONTRACT_ADDR.to_string(),\n                funds: vec![],\n                msg: to_binary(\u0026ExecuteMsg::ExecuteSwapOperation {\n                    operation: SwapOperation::HaloSwap {\n                        offer_asset_info: AssetInfo::NativeToken {\n                            denom: \"uluna\".to_string(),\n                        },\n                        ask_asset_info: AssetInfo::Token {\n                            contract_addr: \"asset0002\".to_string(),\n                        },\n                    },\n                    to: Some(\"addr0000\".to_string()),\n                })\n                .unwrap(),\n            })),\n            SubMsg::new(CosmosMsg::Wasm(WasmMsg::Execute {\n                contract_addr: MOCK_CONTRACT_ADDR.to_string(),\n                funds: vec![],\n                msg: to_binary(\u0026ExecuteMsg::AssertMinimumReceive {\n                    asset_info: AssetInfo::Token {\n                        contract_addr: \"asset0002\".to_string(),\n                    },\n                    prev_balance: Uint128::zero(),\n                    minimum_receive: Uint128::from(1000000u128),\n                    receiver: \"addr0000\".to_string(),\n                })\n                .unwrap(),\n            })),\n        ]\n    );\n\n    let msg = ExecuteMsg::Receive(Cw20ReceiveMsg {\n        sender: \"addr0000\".to_string(),\n        amount: Uint128::from(1000000u128),\n        msg: to_binary(\u0026Cw20HookMsg::ExecuteSwapOperations {\n            operations: vec![\n                SwapOperation::HaloSwap {\n                    offer_asset_info: AssetInfo::NativeToken {\n                        denom: \"ukrw\".to_string(),\n                    },\n                    ask_asset_info: AssetInfo::Token {\n                        contract_addr: \"asset0001\".to_string(),\n                    },\n                },\n                SwapOperation::HaloSwap {\n                    offer_asset_info: AssetInfo::Token {\n                        contract_addr: \"asset0001\".to_string(),\n                    },\n                    ask_asset_info: AssetInfo::NativeToken {\n                        denom: \"uluna\".to_string(),\n                    },\n                },\n                SwapOperation::HaloSwap {\n                    offer_asset_info: AssetInfo::NativeToken {\n                        denom: \"uluna\".to_string(),\n                    },\n                    ask_asset_info: AssetInfo::Token {\n                        contract_addr: \"asset0002\".to_string(),\n                    },\n                },\n            ],\n            minimum_receive: None,\n            to: Some(\"addr0002\".to_string()),\n        })\n        .unwrap(),\n    });\n\n    let info = mock_info(\"asset0000\", \u0026[]);\n    let res = execute(deps.as_mut(), mock_env(), info, msg).unwrap();\n    assert_eq!(\n        res.messages,\n        vec![\n            SubMsg::new(CosmosMsg::Wasm(WasmMsg::Execute {\n                contract_addr: MOCK_CONTRACT_ADDR.to_string(),\n                funds: vec![],\n                msg: to_binary(\u0026ExecuteMsg::ExecuteSwapOperation {\n                    operation: SwapOperation::HaloSwap {\n                        offer_asset_info: AssetInfo::NativeToken {\n                            denom: \"ukrw\".to_string(),\n                        },\n                        ask_asset_info: AssetInfo::Token {\n                            contract_addr: \"asset0001\".to_string(),\n                        },\n                    },\n                    to: None,\n                })\n                .unwrap(),\n            })),\n            SubMsg::new(CosmosMsg::Wasm(WasmMsg::Execute {\n                contract_addr: MOCK_CONTRACT_ADDR.to_string(),\n                funds: vec![],\n                msg: to_binary(\u0026ExecuteMsg::ExecuteSwapOperation {\n                    operation: SwapOperation::HaloSwap {\n                        offer_asset_info: AssetInfo::Token {\n                            contract_addr: \"asset0001\".to_string(),\n                        },\n                        ask_asset_info: AssetInfo::NativeToken {\n                            denom: \"uluna\".to_string(),\n                        },\n                    },\n                    to: None,\n                })\n                .unwrap(),\n            })),\n            SubMsg::new(CosmosMsg::Wasm(WasmMsg::Execute {\n                contract_addr: MOCK_CONTRACT_ADDR.to_string(),\n                funds: vec![],\n                msg: to_binary(\u0026ExecuteMsg::ExecuteSwapOperation {\n                    operation: SwapOperation::HaloSwap {\n                        offer_asset_info: AssetInfo::NativeToken {\n                            denom: \"uluna\".to_string(),\n                        },\n                        ask_asset_info: AssetInfo::Token {\n                            contract_addr: \"asset0002\".to_string(),\n                        },\n                    },\n                    to: Some(\"addr0002\".to_string()),\n                })\n                .unwrap(),\n            }))\n        ]\n    );\n}\n\n#[test]\nfn execute_swap_operation() {\n    let mut deps = mock_dependencies(\u0026[]);\n    let msg = InstantiateMsg {\n        halo_factory: \"halofactory\".to_string(),\n    };\n\n    let info = mock_info(\"addr0000\", \u0026[]);\n\n    // we can just call .unwrap() to assert this was a success\n    let _res = instantiate(deps.as_mut(), mock_env(), info, msg).unwrap();\n\n    deps.querier.with_halo_factory(\n        \u0026[(\n            \u0026\"uusdasset0000\".to_string(),\n            \u0026PairInfo {\n                asset_infos: [\n                    AssetInfo::NativeToken {\n                        denom: \"uusd\".to_string(),\n                    },\n                    AssetInfo::Token {\n                        contract_addr: \"asset0000\".to_string(),\n                    },\n                ],\n                contract_addr: \"pair0000\".to_string(),\n                liquidity_token: \"liquidity0000\".to_string(),\n                asset_decimals: [6u8, 6u8],\n                requirements: CreatePairRequirements {\n                    whitelist: vec![Addr::unchecked(\"deployer\")],\n                    first_asset_minimum: Uint128::zero(),\n                    second_asset_minimum: Uint128::zero(),\n                },\n            },\n        )],\n        \u0026[(\"uusd\".to_string(), 6u8)],\n    );\n    deps.querier.with_balance(\u0026[(\n        \u0026MOCK_CONTRACT_ADDR.to_string(),\n        [Coin {\n            amount: Uint128::from(1000000u128),\n            denom: \"uusd\".to_string(),\n        }]\n        .to_vec(),\n    )]);\n\n    let msg = ExecuteMsg::ExecuteSwapOperation {\n        operation: SwapOperation::HaloSwap {\n            offer_asset_info: AssetInfo::NativeToken {\n                denom: \"uusd\".to_string(),\n            },\n            ask_asset_info: AssetInfo::Token {\n                contract_addr: \"asset0000\".to_string(),\n            },\n        },\n        to: None,\n    };\n    let info = mock_info(\"addr0000\", \u0026[]);\n    let res = execute(deps.as_mut(), mock_env(), info, msg.clone());\n    match res {\n        Err(StdError::GenericErr { msg, .. }) =\u003e assert_eq!(msg, \"unauthorized\"),\n        _ =\u003e panic!(\"DO NOT ENTER HERE\"),\n    }\n\n    let info = mock_info(MOCK_CONTRACT_ADDR, \u0026[]);\n    let res = execute(deps.as_mut(), mock_env(), info, msg).unwrap();\n    assert_eq!(\n        res.messages,\n        vec![SubMsg::new(\n            asset_into_swap_msg(\n                deps.as_ref(),\n                Addr::unchecked(\"pair0000\"),\n                Asset {\n                    info: AssetInfo::NativeToken {\n                        denom: \"uusd\".to_string(),\n                    },\n                    amount: Uint128::from(1000000u128)\n                },\n                None,\n                None\n            )\n            .unwrap()\n        )],\n    );\n\n    // optional to address\n    // swap_send\n    let msg = ExecuteMsg::ExecuteSwapOperation {\n        operation: SwapOperation::HaloSwap {\n            offer_asset_info: AssetInfo::NativeToken {\n                denom: \"uusd\".to_string(),\n            },\n            ask_asset_info: AssetInfo::Token {\n                contract_addr: \"asset0000\".to_string(),\n            },\n        },\n        to: Some(\"addr0000\".to_string()),\n    };\n    let info = mock_info(MOCK_CONTRACT_ADDR, \u0026[]);\n    let res = execute(deps.as_mut(), mock_env(), info, msg).unwrap();\n    assert_eq!(\n        res.messages,\n        vec![SubMsg::new(\n            asset_into_swap_msg(\n                deps.as_ref(),\n                Addr::unchecked(\"pair0000\"),\n                Asset {\n                    info: AssetInfo::NativeToken {\n                        denom: \"uusd\".to_string(),\n                    },\n                    amount: Uint128::from(1000000u128)\n                },\n                None,\n                Some(\"addr0000\".to_string())\n            )\n            .unwrap()\n        )],\n    );\n    deps.querier.with_halo_factory(\n        \u0026[(\n            \u0026\"assetuusd\".to_string(),\n            \u0026PairInfo {\n                asset_infos: [\n                    AssetInfo::Token {\n                        contract_addr: \"asset\".to_string(),\n                    },\n                    AssetInfo::NativeToken {\n                        denom: \"uusd\".to_string(),\n                    },\n                ],\n                contract_addr: \"pair0000\".to_string(),\n                liquidity_token: \"liquidity0000\".to_string(),\n                asset_decimals: [6u8, 6u8],\n                requirements: CreatePairRequirements {\n                    whitelist: vec![Addr::unchecked(\"deployer\")],\n                    first_asset_minimum: Uint128::zero(),\n                    second_asset_minimum: Uint128::zero(),\n                },\n            },\n        )],\n        \u0026[(\"uusd\".to_string(), 6u8)],\n    );\n    deps.querier.with_token_balances(\u0026[(\n        \u0026\"asset\".to_string(),\n        \u0026[(\u0026MOCK_CONTRACT_ADDR.to_string(), \u0026Uint128::from(1000000u128))],\n    )]);\n\n    let msg = ExecuteMsg::ExecuteSwapOperation {\n        operation: SwapOperation::HaloSwap {\n            offer_asset_info: AssetInfo::Token {\n                contract_addr: \"asset\".to_string(),\n            },\n            ask_asset_info: AssetInfo::NativeToken {\n                denom: \"uusd\".to_string(),\n            },\n        },\n        to: Some(\"addr0000\".to_string()),\n    };\n\n    let info = mock_info(MOCK_CONTRACT_ADDR, \u0026[]);\n    let res = execute(deps.as_mut(), mock_env(), info, msg).unwrap();\n    assert_eq!(\n        res.messages,\n        vec![SubMsg::new(CosmosMsg::Wasm(WasmMsg::Execute {\n            contract_addr: \"asset\".to_string(),\n            funds: vec![],\n            msg: to_binary(\u0026Cw20ExecuteMsg::Send {\n                contract: \"pair0000\".to_string(),\n                amount: Uint128::from(1000000u128),\n                msg: to_binary(\u0026PairHookMsg::Swap {\n                    belief_price: None,\n                    max_spread: None,\n                    to: Some(\"addr0000\".to_string()),\n                })\n                .unwrap()\n            })\n            .unwrap()\n        }))]\n    );\n}\n\n#[test]\nfn query_buy_with_routes() {\n    let mut deps = mock_dependencies(\u0026[]);\n\n    let msg = InstantiateMsg {\n        halo_factory: \"halofactory\".to_string(),\n    };\n\n    let info = mock_info(\"addr0000\", \u0026[]);\n\n    // we can just call .unwrap() to assert this was a success\n    let _res = instantiate(deps.as_mut(), mock_env(), info, msg).unwrap();\n\n    let msg = QueryMsg::SimulateSwapOperations {\n        offer_amount: Uint128::from(1000000u128),\n        operations: vec![\n            SwapOperation::HaloSwap {\n                offer_asset_info: AssetInfo::NativeToken {\n                    denom: \"ukrw\".to_string(),\n                },\n                ask_asset_info: AssetInfo::Token {\n                    contract_addr: \"asset0000\".to_string(),\n                },\n            },\n            SwapOperation::HaloSwap {\n                offer_asset_info: AssetInfo::Token {\n                    contract_addr: \"asset0000\".to_string(),\n                },\n                ask_asset_info: AssetInfo::NativeToken {\n                    denom: \"uluna\".to_string(),\n                },\n            },\n        ],\n    };\n\n    deps.querier.with_halo_factory(\n        \u0026[\n            (\n                \u0026\"ukrwasset0000\".to_string(),\n                \u0026PairInfo {\n                    asset_infos: [\n                        AssetInfo::NativeToken {\n                            denom: \"ukrw\".to_string(),\n                        },\n                        AssetInfo::Token {\n                            contract_addr: \"asset0000\".to_string(),\n                        },\n                    ],\n                    contract_addr: \"pair0000\".to_string(),\n                    liquidity_token: \"liquidity0000\".to_string(),\n                    asset_decimals: [6u8, 6u8],\n                    requirements: CreatePairRequirements {\n                        whitelist: vec![Addr::unchecked(\"deployer\")],\n                        first_asset_minimum: Uint128::zero(),\n                        second_asset_minimum: Uint128::zero(),\n                    },\n                },\n            ),\n            (\n                \u0026\"asset0000uluna\".to_string(),\n                \u0026PairInfo {\n                    asset_infos: [\n                        AssetInfo::Token {\n                            contract_addr: \"asset0000\".to_string(),\n                        },\n                        AssetInfo::NativeToken {\n                            denom: \"uluna\".to_string(),\n                        },\n                    ],\n                    contract_addr: \"pair0001\".to_string(),\n                    liquidity_token: \"liquidity0001\".to_string(),\n                    asset_decimals: [6u8, 6u8],\n                    requirements: CreatePairRequirements {\n                        whitelist: vec![Addr::unchecked(\"deployer\")],\n                        first_asset_minimum: Uint128::zero(),\n                        second_asset_minimum: Uint128::zero(),\n                    },\n                },\n            ),\n        ],\n        \u0026[(\"ukrw\".to_string(), 6u8), (\"uluna\".to_string(), 6u8)],\n    );\n\n    let res: SimulateSwapOperationsResponse =\n        from_binary(\u0026query(deps.as_ref(), mock_env(), msg).unwrap()).unwrap();\n    assert_eq!(\n        res,\n        SimulateSwapOperationsResponse {\n            amount: Uint128::from(1000000u128)\n        }\n    );\n}\n\n#[test]\nfn query_reverse_routes_with_from_native() {\n    let mut deps = mock_dependencies(\u0026[]);\n\n    let msg = InstantiateMsg {\n        halo_factory: \"halofactory\".to_string(),\n    };\n\n    let target_amount = 1000000u128;\n\n    let info = mock_info(\"addr0000\", \u0026[coin(10000000, \"ukrw\")]);\n\n    // we can just call .unwrap() to assert this was a success\n    let _res = instantiate(deps.as_mut(), mock_env(), info, msg).unwrap();\n\n    deps.querier.with_balance(\u0026[(\n        \u0026MOCK_CONTRACT_ADDR.to_string(),\n        [Coin {\n            amount: Uint128::from(1000000u128),\n            denom: \"ukrw\".to_string(),\n        }]\n        .to_vec(),\n    )]);\n\n    deps.querier.with_token_balances(\u0026[(\n        \u0026\"asset0001\".to_string(),\n        \u0026[(\u0026MOCK_CONTRACT_ADDR.to_string(), \u0026Uint128::from(1000000u128))],\n    )]);\n\n    let msg = QueryMsg::ReverseSimulateSwapOperations {\n        ask_amount: Uint128::from(target_amount),\n        operations: vec![SwapOperation::HaloSwap {\n            offer_asset_info: AssetInfo::NativeToken {\n                denom: \"ukrw\".to_string(),\n            },\n            ask_asset_info: AssetInfo::Token {\n                contract_addr: \"asset0000\".to_string(),\n            },\n        }],\n    };\n\n    deps.querier.with_halo_factory(\n        \u0026[\n            (\n                \u0026\"ukrwasset0000\".to_string(),\n                \u0026PairInfo {\n                    contract_addr: \"pair0000\".to_string(),\n                    liquidity_token: \"liquidity0000\".to_string(),\n                    asset_infos: [\n                        AssetInfo::Token {\n                            contract_addr: \"asset0000\".to_string(),\n                        },\n                        AssetInfo::NativeToken {\n                            denom: \"ukrw\".to_string(),\n                        },\n                    ],\n                    asset_decimals: [8u8, 6u8],\n                    requirements: CreatePairRequirements {\n                        whitelist: vec![Addr::unchecked(\"deployer\")],\n                        first_asset_minimum: Uint128::zero(),\n                        second_asset_minimum: Uint128::zero(),\n                    },\n                },\n            ),\n            (\n                \u0026\"asset0000uluna\".to_string(),\n                \u0026PairInfo {\n                    contract_addr: \"pair0001\".to_string(),\n                    liquidity_token: \"liquidity0001\".to_string(),\n                    asset_infos: [\n                        AssetInfo::Token {\n                            contract_addr: \"asset0000\".to_string(),\n                        },\n                        AssetInfo::NativeToken {\n                            denom: \"uluna\".to_string(),\n                        },\n                    ],\n                    asset_decimals: [8u8, 6u8],\n                    requirements: CreatePairRequirements {\n                        whitelist: vec![Addr::unchecked(\"deployer\")],\n                        first_asset_minimum: Uint128::zero(),\n                        second_asset_minimum: Uint128::zero(),\n                    },\n                },\n            ),\n        ],\n        \u0026[(\"ukrw\".to_string(), 6u8), (\"uluna\".to_string(), 6u8)],\n    );\n\n    let res: SimulateSwapOperationsResponse =\n        from_binary(\u0026query(deps.as_ref(), mock_env(), msg).unwrap()).unwrap();\n\n    assert_eq!(\n        res,\n        SimulateSwapOperationsResponse {\n            amount: Uint128::from(1000000u128),\n        }\n    );\n\n    let offer_amount = res.amount;\n\n    let msg = ExecuteMsg::ExecuteSwapOperation {\n        operation: SwapOperation::HaloSwap {\n            offer_asset_info: AssetInfo::NativeToken {\n                denom: \"ukrw\".to_string(),\n            },\n            ask_asset_info: AssetInfo::Token {\n                contract_addr: \"asset0000\".to_string(),\n            },\n        },\n        to: None,\n    };\n    let info = mock_info(\"addr0\", \u0026[coin(offer_amount.u128(), \"ukrw\")]);\n    let res = execute(deps.as_mut(), mock_env(), info, msg.clone());\n    match res {\n        Err(StdError::GenericErr { msg, .. }) =\u003e assert_eq!(msg, \"unauthorized\"),\n        _ =\u003e panic!(\"DO NOT ENTER HERE\"),\n    }\n\n    let info = mock_info(MOCK_CONTRACT_ADDR, \u0026[]);\n    let res = execute(deps.as_mut(), mock_env(), info, msg).unwrap();\n\n    assert_eq!(\n        res.messages,\n        vec![SubMsg::new(CosmosMsg::Wasm(WasmMsg::Execute {\n            contract_addr: \"pair0000\".to_string(),\n            funds: vec![coin(target_amount, \"ukrw\")],\n            msg: to_binary(\u0026PairHookMsg::Swap {\n                belief_price: None,\n                max_spread: None,\n                to: None,\n            })\n            .unwrap(),\n        })),],\n    );\n}\n\n#[test]\nfn query_reverse_routes_with_to_native() {\n    let mut deps = mock_dependencies(\u0026[]);\n\n    let msg = InstantiateMsg {\n        halo_factory: \"halofactory\".to_string(),\n    };\n\n    let target_amount = 1000000u128;\n\n    let info = mock_info(\"addr0000\", \u0026[]);\n\n    // we can just call .unwrap() to assert this was a success\n    let _res = instantiate(deps.as_mut(), mock_env(), info, msg).unwrap();\n\n    deps.querier.with_token_balances(\u0026[\n        (\n            \u0026\"asset0000\".to_string(),\n            \u0026[(\u0026\"pair0000\".to_string(), \u0026Uint128::from(1000000u128))],\n        ),\n        (\n            \u0026\"asset0000\".to_string(),\n            \u0026[(\u0026MOCK_CONTRACT_ADDR.to_string(), \u0026Uint128::from(1000000u128))],\n        ),\n    ]);\n\n    let msg = QueryMsg::ReverseSimulateSwapOperations {\n        ask_amount: Uint128::from(target_amount),\n        operations: vec![SwapOperation::HaloSwap {\n            offer_asset_info: AssetInfo::Token {\n                contract_addr: \"asset0000\".to_string(),\n            },\n            ask_asset_info: AssetInfo::NativeToken {\n                denom: \"ukrw\".to_string(),\n            },\n        }],\n    };\n\n    deps.querier.with_halo_factory(\n        \u0026[\n            (\n                \u0026\"ukrwasset0000\".to_string(),\n                \u0026PairInfo {\n                    contract_addr: \"pair0000\".to_string(),\n                    liquidity_token: \"liquidity0000\".to_string(),\n                    asset_infos: [\n                        AssetInfo::Token {\n                            contract_addr: \"asset0000\".to_string(),\n                        },\n                        AssetInfo::NativeToken {\n                            denom: \"ukrw\".to_string(),\n                        },\n                    ],\n                    asset_decimals: [8u8, 6u8],\n                    requirements: CreatePairRequirements {\n                        whitelist: vec![Addr::unchecked(\"deployer\")],\n                        first_asset_minimum: Uint128::zero(),\n                        second_asset_minimum: Uint128::zero(),\n                    },\n                },\n            ),\n            (\n                \u0026\"asset0000uluna\".to_string(),\n                \u0026PairInfo {\n                    contract_addr: \"pair0001\".to_string(),\n                    liquidity_token: \"liquidity0001\".to_string(),\n                    asset_infos: [\n                        AssetInfo::Token {\n                            contract_addr: \"asset0000\".to_string(),\n                        },\n                        AssetInfo::NativeToken {\n                            denom: \"uluna\".to_string(),\n                        },\n                    ],\n                    asset_decimals: [8u8, 6u8],\n                    requirements: CreatePairRequirements {\n                        whitelist: vec![Addr::unchecked(\"deployer\")],\n                        first_asset_minimum: Uint128::zero(),\n                        second_asset_minimum: Uint128::zero(),\n                    },\n                },\n            ),\n        ],\n        \u0026[(\"ukrw\".to_string(), 6u8), (\"uluna\".to_string(), 6u8)],\n    );\n\n    let res: SimulateSwapOperationsResponse =\n        from_binary(\u0026query(deps.as_ref(), mock_env(), msg).unwrap()).unwrap();\n\n    assert_eq!(\n        res,\n        SimulateSwapOperationsResponse {\n            amount: Uint128::from(target_amount),\n        }\n    );\n\n    let offer_amount = res.amount;\n\n    let msg = ExecuteMsg::Receive(Cw20ReceiveMsg {\n        sender: \"addr0\".to_string(),\n        amount: offer_amount,\n        msg: to_binary(\u0026Cw20HookMsg::ExecuteSwapOperations {\n            operations: vec![SwapOperation::HaloSwap {\n                offer_asset_info: AssetInfo::Token {\n                    contract_addr: \"asset0000\".to_string(),\n                },\n                ask_asset_info: AssetInfo::NativeToken {\n                    denom: \"ukrw\".to_string(),\n                },\n            }],\n            minimum_receive: None,\n            to: None,\n        })\n        .unwrap(),\n    });\n    let info = mock_info(\"addr0\", \u0026[]);\n    let res = execute(deps.as_mut(), mock_env(), info, msg).unwrap();\n\n    assert_eq!(\n        res.messages,\n        vec![SubMsg::new(CosmosMsg::Wasm(WasmMsg::Execute {\n            contract_addr: MOCK_CONTRACT_ADDR.to_string(),\n            funds: vec![],\n            msg: to_binary(\u0026ExecuteMsg::ExecuteSwapOperation {\n                operation: SwapOperation::HaloSwap {\n                    offer_asset_info: AssetInfo::Token {\n                        contract_addr: \"asset0000\".to_string(),\n                    },\n                    ask_asset_info: AssetInfo::NativeToken {\n                        denom: \"ukrw\".to_string(),\n                    },\n                },\n                to: Some(\"addr0\".to_string()),\n            })\n            .unwrap(),\n        })),],\n    );\n\n    let msg = ExecuteMsg::ExecuteSwapOperation {\n        operation: SwapOperation::HaloSwap {\n            offer_asset_info: AssetInfo::Token {\n                contract_addr: \"asset0000\".to_string(),\n            },\n            ask_asset_info: AssetInfo::NativeToken {\n                denom: \"ukrw\".to_string(),\n            },\n        },\n        to: None,\n    };\n\n    let info = mock_info(MOCK_CONTRACT_ADDR, \u0026[]);\n    let res = execute(deps.as_mut(), mock_env(), info, msg).unwrap();\n\n    assert_eq!(\n        res.messages,\n        vec![SubMsg::new(CosmosMsg::Wasm(WasmMsg::Execute {\n            contract_addr: \"asset0000\".to_string(),\n            funds: vec![],\n            msg: to_binary(\u0026Cw20ExecuteMsg::Send {\n                contract: \"pair0000\".to_string(),\n                amount: Uint128::from(target_amount),\n                msg: to_binary(\u0026PairHookMsg::Swap {\n                    belief_price: None,\n                    max_spread: None,\n                    to: None,\n                })\n                .unwrap(),\n            })\n            .unwrap(),\n        }))],\n    );\n}\n\n#[test]\nfn assert_minimum_receive_native_token() {\n    let mut deps = mock_dependencies(\u0026[]);\n    deps.querier.with_balance(\u0026[(\n        \u0026\"addr0000\".to_string(),\n        [Coin {\n            denom: \"uusd\".to_string(),\n            amount: Uint128::from(1000000u128),\n        }]\n        .to_vec(),\n    )]);\n\n    let info = mock_info(\"addr0000\", \u0026[]);\n    // success\n    let msg = ExecuteMsg::AssertMinimumReceive {\n        asset_info: AssetInfo::NativeToken {\n            denom: \"uusd\".to_string(),\n        },\n        prev_balance: Uint128::zero(),\n        minimum_receive: Uint128::from(1000000u128),\n        receiver: \"addr0000\".to_string(),\n    };\n    let _res = execute(deps.as_mut(), mock_env(), info.clone(), msg).unwrap();\n\n    // assertion failed; native token\n    let msg = ExecuteMsg::AssertMinimumReceive {\n        asset_info: AssetInfo::NativeToken {\n            denom: \"uusd\".to_string(),\n        },\n        prev_balance: Uint128::zero(),\n        minimum_receive: Uint128::from(1000001u128),\n        receiver: \"addr0000\".to_string(),\n    };\n    let res = execute(deps.as_mut(), mock_env(), info, msg);\n    match res {\n        Err(StdError::GenericErr { msg, .. }) =\u003e assert_eq!(\n            msg,\n            \"assertion failed; minimum receive amount: 1000001, swap amount: 1000000\"\n        ),\n        _ =\u003e panic!(\"DO NOT ENTER HERE\"),\n    }\n}\n\n#[test]\nfn assert_minimum_receive_token() {\n    let mut deps = mock_dependencies(\u0026[]);\n    deps.querier.with_token_balances(\u0026[(\n        \u0026\"token0000\".to_string(),\n        \u0026[(\u0026\"addr0000\".to_string(), \u0026Uint128::from(1000000u128))],\n    )]);\n\n    let info = mock_info(\"addr0000\", \u0026[]);\n    // success\n    let msg = ExecuteMsg::AssertMinimumReceive {\n        asset_info: AssetInfo::Token {\n            contract_addr: \"token0000\".to_string(),\n        },\n        prev_balance: Uint128::zero(),\n        minimum_receive: Uint128::from(1000000u128),\n        receiver: \"addr0000\".to_string(),\n    };\n    let _res = execute(deps.as_mut(), mock_env(), info.clone(), msg).unwrap();\n\n    // assertion failed; native token\n    let msg = ExecuteMsg::AssertMinimumReceive {\n        asset_info: AssetInfo::Token {\n            contract_addr: \"token0000\".to_string(),\n        },\n        prev_balance: Uint128::zero(),\n        minimum_receive: Uint128::from(1000001u128),\n        receiver: \"addr0000\".to_string(),\n    };\n    let res = execute(deps.as_mut(), mock_env(), info, msg);\n    match res {\n        Err(StdError::GenericErr { msg, .. }) =\u003e assert_eq!(\n            msg,\n            \"assertion failed; minimum receive amount: 1000001, swap amount: 1000000\"\n        ),\n        _ =\u003e panic!(\"DO NOT ENTER HERE\"),\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","haitran","AURA-NETWORK","smart-contracts-halotrade-zone","contracts","halo-token","src","contract.rs"],"content":"#[cfg(not(feature = \"library\"))]\nuse cosmwasm_std::entry_point;\nuse cosmwasm_std::{Binary, Deps, DepsMut, Env, MessageInfo, Response, StdError, StdResult};\n\nuse cw2::set_contract_version;\nuse cw20_base::contract::{create_accounts, execute as cw20_execute, query as cw20_query};\nuse cw20_base::msg::{ExecuteMsg, QueryMsg};\nuse cw20_base::state::{MinterData, TokenInfo, TOKEN_INFO};\nuse cw20_base::ContractError;\n\nuse haloswap::token::InstantiateMsg;\n\n// version info for migration info\nconst CONTRACT_NAME: \u0026str = \"crates.io:cw20-base\";\nconst CONTRACT_VERSION: \u0026str = env!(\"CARGO_PKG_VERSION\");\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn instantiate(\n    mut deps: DepsMut,\n    _env: Env,\n    _info: MessageInfo,\n    msg: InstantiateMsg,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    set_contract_version(deps.storage, CONTRACT_NAME, CONTRACT_VERSION)?;\n    // check valid token info\n    msg.validate()?;\n\n    // convert initial_balances to slice of Cw20Coin\n    let initial_balances_slice = msg.initial_balances.as_slice();\n\n    // create initial accounts\n    let total_supply = create_accounts(\u0026mut deps, initial_balances_slice)?;\n\n    if let Some(limit) = msg.get_cap() {\n        if total_supply \u003e limit {\n            return Err(ContractError::Std(StdError::generic_err(\n                \"Initial supply greater than cap\",\n            )));\n        }\n    }\n\n    let mint = match msg.mint {\n        Some(m) =\u003e Some(MinterData {\n            minter: deps.api.addr_validate(\u0026m.minter)?,\n            cap: m.cap,\n        }),\n        None =\u003e None,\n    };\n\n    // store token info\n    let data = TokenInfo {\n        name: msg.name,\n        symbol: msg.symbol,\n        decimals: msg.decimals,\n        total_supply,\n        mint,\n    };\n\n    TOKEN_INFO.save(deps.storage, \u0026data)?;\n    Ok(Response::default())\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn execute(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    msg: ExecuteMsg,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    cw20_execute(deps, env, info, msg)\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn query(deps: Deps, env: Env, msg: QueryMsg) -\u003e StdResult\u003cBinary\u003e {\n    cw20_query(deps, env, msg)\n}\n","traces":[{"line":24,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":22,"coverable":22},{"path":["/","Users","haitran","AURA-NETWORK","smart-contracts-halotrade-zone","contracts","halo-token","src","env_setup.rs"],"content":"#[cfg(test)]\npub mod env {\n    use cosmwasm_std::{Addr, Coin, Empty, StdError, Uint128};\n    use cw_multi_test::{App, AppBuilder, Contract, ContractWrapper, Executor};\n    use cw20::{Cw20Coin, MinterResponse};\n\n    use crate::contract::{execute as halo_token_execute, instantiate as halo_token_instantiate, query as halo_token_query};\n    use haloswap::token::InstantiateMsg;\n    // ****************************************\n    // You MUST define the constants value here\n    // ****************************************\n    pub const ADMIN: \u0026str = \"aura1uh24g2lc8hvvkaaf7awz25lrh5fptthu2dhq0n\";\n    pub const USER_1: \u0026str = \"aura1fqj2redmssckrdeekhkcvd2kzp9f4nks4fctrt\";\n\n    pub const NATIVE_DENOM: \u0026str = \"uaura\";\n    pub const NATIVE_BALANCE: u128 = 1_000_000_000_000u128;\n\n    pub const NATIVE_DENOM_2: \u0026str = \"uaura1\";\n    pub const NATIVE_BALANCE_2: u128 = 500_000_000_000u128;\n\n    pub struct ContractInfo {\n        pub contract_addr: String,\n        pub contract_code_id: u64,\n    }\n\n\n    fn mock_app() -\u003e App {\n        AppBuilder::new().build(|router, _, storage| {\n            router\n                .bank\n                .init_balance(\n                    storage,\n                    \u0026Addr::unchecked(ADMIN),\n                    vec![\n                        Coin {\n                            denom: NATIVE_DENOM.to_string(),\n                            amount: Uint128::new(NATIVE_BALANCE),\n                        },\n                        Coin {\n                            denom: NATIVE_DENOM_2.to_string(),\n                            amount: Uint128::new(NATIVE_BALANCE_2),\n                        },\n                    ],\n                )\n                .unwrap();\n        })\n    }\n\n    fn halo_contract_template() -\u003e Box\u003cdyn Contract\u003cEmpty\u003e\u003e {\n        let contract = ContractWrapper::new(halo_token_execute, halo_token_instantiate, halo_token_query);\n        Box::new(contract)\n    }\n\n    // *********************************************************\n    // You MUST store code and instantiate all contracts here\n    // Follow the example (2) below:\n    // @return App: the mock app\n    // @return String: the address of the contract\n    // @return u64: the code id of the contract\n    //    pub fn instantiate_contracts() -\u003e (App, String, u64) {\n    //        // Create a new app instance\n    //        let mut app = mock_app();\n    //\n    //        // store the code of all contracts to the app and get the code ids\n    //        let contract_code_id = app.store_code(contract_template());\n    //\n    //        // create instantiate message for contract\n    //        let contract_instantiate_msg = InstantiateMsg {\n    //            name: \"Contract_A\".to_string(),\n    //        };\n    //\n    //        // instantiate contract\n    //        let contract_addr = app\n    //            .instantiate_contract(\n    //                contract_code_id,\n    //                Addr::unchecked(ADMIN),\n    //                \u0026contract_instantiate_msg,\n    //                \u0026[],\n    //                \"test instantiate contract\",\n    //                None,\n    //            )\n    //            .unwrap();\n    //\n    //        // return the app instance, the addresses and code IDs of all contracts\n    //        (app, contract_addr, contract_code_id)\n    //    }\n    // *********************************************************\n    pub fn instantiate_contracts() -\u003e (App, Vec\u003cContractInfo\u003e) {\n        // Create a new app instance\n        let mut app = mock_app();\n\n        // halo token contract\n        // store the code of all contracts to the app and get the code ids\n        let halo_token_contract_code_id = app.store_code(halo_contract_template());\n\n        let mut contract_info_vec: Vec\u003cContractInfo\u003e = Vec::new();\n\n        // create instantiate message for contract\n        let contract_instantiate_msg = InstantiateMsg {\n            name: \"Halo Token\".to_string(),\n            symbol: \"HALO\".to_string(),\n            decimals: 6,\n            initial_balances: vec![],\n            mint: None,\n        };\n\n        // instantiate contract\n        let halo_token_contract_addr = app\n            .instantiate_contract(\n                halo_token_contract_code_id,\n                Addr::unchecked(ADMIN),\n                \u0026contract_instantiate_msg,\n                \u0026[],\n                \"test instantiate contract\",\n                None,\n            )\n            .unwrap();\n\n        // add contract info to the vector\n        contract_info_vec.push(ContractInfo {\n            contract_addr: halo_token_contract_addr.to_string(),\n            contract_code_id: halo_token_contract_code_id,\n        });\n\n        // return the app instance, the addresses and code IDs of all contracts\n        (app, contract_info_vec)\n    }\n\n    // can not instantiate halo token with wrong validate condition (name, symbol, decimals)\n#[test]\n    fn cannot_instantiate_with_wrong_validate_condition() {\n        let mut app = mock_app();\n        let halo_token_contract_code_id = app.store_code(halo_contract_template());\n\n        let too_short_token_name_instantiate_msg = InstantiateMsg {\n            name: \"H\".to_string(),\n            symbol: \"HALO\".to_string(),\n            decimals: 18,\n            initial_balances: vec![],\n            mint: None,\n        };\n\n        let too_long_token_name_instantiate_msg = InstantiateMsg {\n            name: \"0123456789a123456789b123456789c123456789d123456789e\".to_string(), // 51 characters\n            symbol: \"HALO\".to_string(),\n            decimals: 18,\n            initial_balances: vec![],\n            mint: None,\n        };\n\n        let too_short_token_symbol_instantiate_msg = InstantiateMsg {\n            name: \"Halo Token\".to_string(),\n            symbol: \"H\".to_string(),\n            decimals: 18,\n            initial_balances: vec![],\n            mint: None,\n        };\n\n        let too_long_token_symbol_instantiate_msg = InstantiateMsg {\n            name: \"Halo Token\".to_string(),\n            symbol: \"0123456789a123456789b123456789c123456789d123456789e\".to_string(), // 51 characters\n            decimals: 18,\n            initial_balances: vec![],\n            mint: None,\n        };\n\n        let too_big_token_decimals_instantiate_msg = InstantiateMsg {\n            name: \"Halo Token\".to_string(),\n            symbol: \"HALO\".to_string(),\n            decimals: 20,\n            initial_balances: vec![],\n            mint: None,\n        };\n\n        let initial_supply_greater_than_cap_msg = InstantiateMsg {\n            name: \"Halo Token\".to_string(),\n            symbol: \"HALO\".to_string(),\n            decimals: 18,\n            initial_balances: vec![Cw20Coin{\n                address: Addr::unchecked(ADMIN).to_string(),\n                amount: Uint128::new(100),\n            }],\n            mint: Some(MinterResponse {\n                minter: ADMIN.to_string(),\n                cap: Some(Uint128::new(90)),\n            }),\n        };\n\n        let err = app\n            .instantiate_contract(\n                halo_token_contract_code_id,\n                Addr::unchecked(ADMIN),\n                \u0026too_short_token_name_instantiate_msg,\n                \u0026[],\n                \"test wrong token name instantiate contract\",\n                None,\n            )\n            .unwrap_err();\n        \n        assert_eq!(\n            err.source().unwrap().to_string(),\n            StdError::generic_err(\"Name is not in the expected format (3-50 UTF-8 bytes)\").to_string()\n        );\n\n        let err = app\n            .instantiate_contract(\n                halo_token_contract_code_id,\n                Addr::unchecked(ADMIN),\n                \u0026too_long_token_name_instantiate_msg,\n                \u0026[],\n                \"test wrong token name instantiate contract\",\n                None,\n            )\n            .unwrap_err();\n        \n        assert_eq!(\n            err.source().unwrap().to_string(),\n            StdError::generic_err(\"Name is not in the expected format (3-50 UTF-8 bytes)\").to_string()\n        );\n\n        let err = app\n            .instantiate_contract(\n                halo_token_contract_code_id,\n                Addr::unchecked(ADMIN),\n                \u0026too_short_token_symbol_instantiate_msg,\n                \u0026[],\n                \"test wrong token symbol instantiate contract\",\n                None,\n            )\n            .unwrap_err();\n\n        assert_eq!(\n            err.source().unwrap().to_string(),\n            StdError::generic_err(\"Ticker symbol is not in expected format [a-zA-Z\\\\-]{3,12}\").to_string()\n        );\n\n        let err = app\n            .instantiate_contract(\n                halo_token_contract_code_id,\n                Addr::unchecked(ADMIN),\n                \u0026too_long_token_symbol_instantiate_msg,\n                \u0026[],\n                \"test wrong token symbol instantiate contract\",\n                None,\n            )\n            .unwrap_err();\n\n        assert_eq!(\n            err.source().unwrap().to_string(),\n            StdError::generic_err(\"Ticker symbol is not in expected format [a-zA-Z\\\\-]{3,12}\").to_string()\n        );\n\n        let err = app\n            .instantiate_contract(\n                halo_token_contract_code_id,\n                Addr::unchecked(ADMIN),\n                \u0026too_big_token_decimals_instantiate_msg,\n                \u0026[],\n                \"test wrong token decimals instantiate contract\",\n                None,\n            )\n            .unwrap_err();\n\n        assert_eq!(\n            err.source().unwrap().to_string(),\n            StdError::generic_err(\"Decimals must not exceed 18\").to_string()\n        );\n\n        let err = app\n            .instantiate_contract(\n                halo_token_contract_code_id,\n                Addr::unchecked(ADMIN),\n                \u0026initial_supply_greater_than_cap_msg,\n                \u0026[],\n                \"test initial supply greater than cap msg\",\n                None,\n            )\n            .unwrap_err();\n\n        assert_eq!(\n            err.source().unwrap().to_string(),\n            StdError::generic_err(\"Initial supply greater than cap\").to_string()\n        );\n\n    }\n}\n\n\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","haitran","AURA-NETWORK","smart-contracts-halotrade-zone","contracts","halo-token","src","integration_test.rs"],"content":"#[cfg(test)]\nmod tests {\n    use cosmwasm_std::{coins, from_binary, to_binary, Addr, DepsMut, Response, OwnedDeps, MemoryStorage, testing::{MockApi, MockQuerier, mock_dependencies, mock_info, mock_env}, WasmQuery, Uint128, ContractResult};\n\n    use cw20_base::{ContractError, msg::QueryMsg, msg::ExecuteMsg};\n    \n    use crate::env_setup::env::{instantiate_contracts, ADMIN, USER_1};\n    use crate::contract::*;\n    use cw20::{Expiration as Cw20Expiration, TokenInfoResponse, Cw20Coin, MinterResponse};\n    use haloswap::token::InstantiateMsg;\n\n    const MOCK_HALO_TOKEN_ADDR: \u0026str = \"halo_token_addr\";\n\n    const MOCK_OFFER_CW20_ADDR: \u0026str = \"cw20_addr\";\n    const MOCK_OFFER_CW20_AMOUNT: u128 = 1000000000;\n    const MOCK_OFFER_CW20_AMOUNT_MINIMUM: u128 = 1;\n    const MOCK_OFFER_CW20_PRICE: u128 = 10000000;\n\n\n    const MOCK_OFFER_NFT_OFFERER_INSUFFICIENT_BALANCE: \u0026str = \"offerer 2\";\n    const MOCK_OFFER_NFT_OFFERER_INSUFFICIENT_ALLOWANCE: \u0026str = \"offerer 3\";\n\n    fn mock_deps() -\u003e OwnedDeps\u003cMemoryStorage, MockApi, MockQuerier\u003e {\n        let mut deps = mock_dependencies();\n        let msg = InstantiateMsg {\n            name: \"Cafe Token\".to_string(),\n            symbol: \"CAFE\".to_string(),\n            decimals: 6,\n            initial_balances: vec![],\n            mint: Some(MinterResponse {\n                minter: ADMIN.to_string(),\n                cap: Some(Uint128::new(90)),\n            }),\n        };\n\n        // mock querier\n        deps.querier.update_wasm(|query| {\n            match query {\n                WasmQuery::Smart { contract_addr, msg } =\u003e match contract_addr.as_str() {\n                    MOCK_HALO_TOKEN_ADDR =\u003e {\n                        let query_msg = from_binary::\u003ccw20_base::msg::QueryMsg\u003e(msg).unwrap();\n                        match query_msg {\n                            cw20_base::msg::QueryMsg::Balance { address, .. } =\u003e {\n                                if address == MOCK_OFFER_NFT_OFFERER_INSUFFICIENT_BALANCE {\n                                    let result = ContractResult::Ok(\n                                        to_binary(\u0026cw20::BalanceResponse {\n                                            balance: Uint128::from(MOCK_OFFER_CW20_AMOUNT_MINIMUM),\n                                        })\n                                        .unwrap(),\n                                    );\n                                    cosmwasm_std::SystemResult::Ok(result)\n                                } else {\n                                    let result = ContractResult::Ok(\n                                        to_binary(\u0026cw20::BalanceResponse {\n                                            balance: Uint128::from(MOCK_OFFER_CW20_AMOUNT),\n                                        })\n                                        .unwrap(),\n                                    );\n                                    cosmwasm_std::SystemResult::Ok(result)\n                                }\n                            }\n                            cw20_base::msg::QueryMsg::Allowance { owner, spender: _ } =\u003e {\n                                if owner == MOCK_OFFER_NFT_OFFERER_INSUFFICIENT_ALLOWANCE {\n                                    let result = ContractResult::Ok(\n                                        to_binary(\u0026cw20::AllowanceResponse {\n                                            allowance: Uint128::from(\n                                                MOCK_OFFER_CW20_AMOUNT_MINIMUM,\n                                            ),\n                                            expires: Cw20Expiration::Never {},\n                                        })\n                                        .unwrap(),\n                                    );\n                                    cosmwasm_std::SystemResult::Ok(result)\n                                } else {\n                                    let result = ContractResult::Ok(\n                                        to_binary(\u0026cw20::AllowanceResponse {\n                                            allowance: Uint128::from(MOCK_OFFER_CW20_AMOUNT),\n                                            expires: Cw20Expiration::Never {},\n                                        })\n                                        .unwrap(),\n                                    );\n                                    cosmwasm_std::SystemResult::Ok(result)\n                                }\n                            }\n                            _ =\u003e {\n                                let result = ContractResult::Err(\"Not Found\".to_string());\n                                cosmwasm_std::SystemResult::Ok(result)\n                            }\n                        }\n                    }\n                    _ =\u003e {\n                        panic!(\"Unexpected contract address: {}\", contract_addr);\n                    }\n                },\n                _ =\u003e panic!(\"Unexpected query\"),\n            }\n            // mock query royalty info\n        });\n        let res = instantiate_contract(deps.as_mut(), msg).unwrap();\n        assert_eq!(0, res.messages.len());\n        deps\n    }\n\n    // we will instantiate a contract with account \"owner\" but admin is \"owner\"\n    fn instantiate_contract(deps: DepsMut, msg: InstantiateMsg) -\u003e Result\u003cResponse, ContractError\u003e {\n        let info = mock_info(\"owner\", \u0026coins(1000, \"uaura\"));\n        instantiate(deps, mock_env(), info, msg)\n    }\n\n    #[test]\n    fn proper_initialization() {\n        let deps = mock_deps();\n        // query config\n        let res = query(deps.as_ref(), mock_env(), QueryMsg::TokenInfo {}).unwrap();\n        let token_info: TokenInfoResponse = from_binary(\u0026res).unwrap();\n\n        assert_eq!(\"Cafe Token\".to_string(), token_info.name);\n        assert_eq!(\"CAFE\".to_string(), token_info.symbol);\n        assert_eq!(6, token_info.decimals);\n        assert_eq!(Uint128::from(0u128), token_info.total_supply);\n    }\n\n    #[test]\n    fn proper_initialization_with_no_minter_data() {\n        let msg = InstantiateMsg {\n            name: \"Cafe Token\".to_string(),\n            symbol: \"CAFE\".to_string(),\n            decimals: 6,\n            initial_balances: vec![],\n            mint: None, // no minter data\n        };\n        let mut deps = mock_deps();\n\n        let res = instantiate_contract(deps.as_mut(), msg);\n        assert!(res.is_ok());\n    }\n\n\n    mod execute_contract {\n        use super::*;\n        // Checking Minting works\n        fn create_mint_msg(\n            deps: DepsMut,\n            sender: \u0026str,\n            recipient: \u0026str,\n            amount: Uint128,\n        ) -\u003e Result\u003cResponse, ContractError\u003e {\n            let msg = ExecuteMsg::Mint {\n                recipient: recipient.to_string(),\n                amount,\n            };\n            let info = mock_info(sender, \u0026coins(1000, \"uaura\"));\n            execute(deps, mock_env(), info, msg)\n        }\n\n        #[test]\n        fn proper_execute_mint() {\n            let mut deps = mock_deps();\n            let response = create_mint_msg(\n                deps.as_mut(), \n                ADMIN, \n                USER_1,\n                Uint128::from(10u128));\n            \n            println!(\"Response: {:?}\", \u0026response);\n            assert!(response.is_ok());\n\n        }\n    }\n\n}","traces":[],"covered":0,"coverable":0},{"path":["/","Users","haitran","AURA-NETWORK","smart-contracts-halotrade-zone","contracts","halo-token","src","lib.rs"],"content":"pub mod contract;\npub mod env_setup;\npub mod integration_test;","traces":[],"covered":0,"coverable":0},{"path":["/","Users","haitran","AURA-NETWORK","smart-contracts-halotrade-zone","packages","bignumber","src","lib.rs"],"content":"mod math;\n\npub use crate::math::{Decimal256, Uint256};\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","haitran","AURA-NETWORK","smart-contracts-halotrade-zone","packages","bignumber","src","math.rs"],"content":"use schemars::JsonSchema;\nuse serde::{de, ser, Deserialize, Deserializer, Serialize};\nuse std::convert::TryFrom;\nuse std::fmt::{self, Write};\nuse std::ops;\nuse std::str::FromStr;\n\nuse bigint::U256;\nuse cosmwasm_std::{Decimal, StdError, Uint128};\n\n/// A fixed-point decimal value with 18 fractional digits, i.e. Decimal256(1_000_000_000_000_000_000) == 1.0\n/// The greatest possible value that can be represented is 115792089237316195423570985008687907853269984665640564039457.584007913129639935 (which is (2^128 - 1) / 10^18)\n#[derive(Copy, Clone, Default, Debug, PartialEq, Eq, PartialOrd, Ord, JsonSchema)]\npub struct Decimal256(#[schemars(with = \"String\")] pub U256);\n\nimpl Decimal256 {\n    pub const MAX: Decimal256 = Decimal256(U256::MAX);\n    pub const DECIMAL_FRACTIONAL: U256 = U256([1_000_000_000_000_000_000u64, 0, 0, 0]);\n\n    /// Create a 1.0 Decimal256\n    pub const fn one() -\u003e Decimal256 {\n        Decimal256(Decimal256::DECIMAL_FRACTIONAL)\n    }\n\n    /// Create a 0.0 Decimal256\n    pub const fn zero() -\u003e Decimal256 {\n        Decimal256(U256([0, 0, 0, 0]))\n    }\n\n    /// Convert x% into Decimal256\n    pub fn percent(x: u64) -\u003e Decimal256 {\n        Decimal256(U256::from(x) * U256::from(10_000_000_000_000_000u64))\n    }\n\n    /// Convert permille (x/1000) into Decimal256\n    pub fn permille(x: u64) -\u003e Decimal256 {\n        Decimal256(U256::from(x) * U256::from(1_000_000_000_000_000u64))\n    }\n\n    /// Returns the ratio (nominator / denominator) as a Decimal256\n    pub fn from_ratio\u003cA: Into\u003cU256\u003e, B: Into\u003cU256\u003e\u003e(nominator: A, denominator: B) -\u003e Decimal256 {\n        let nominator: U256 = nominator.into();\n        let denominator: U256 = denominator.into();\n        if denominator.is_zero() {\n            panic!(\"Denominator must not be zero\");\n        }\n\n        Decimal256(nominator * Decimal256::DECIMAL_FRACTIONAL / denominator)\n    }\n\n    pub fn from_uint256\u003cA: Into\u003cUint256\u003e\u003e(val: A) -\u003e Decimal256 {\n        let num: Uint256 = val.into();\n        Decimal256(num.0 * Decimal256::DECIMAL_FRACTIONAL)\n    }\n\n    pub fn is_zero(\u0026self) -\u003e bool {\n        self.0.is_zero()\n    }\n}\n\nimpl From\u003cDecimal\u003e for Decimal256 {\n    fn from(val: Decimal) -\u003e Self {\n        Decimal256::from_str(\u0026val.to_string()).unwrap()\n    }\n}\n\nimpl From\u003cDecimal256\u003e for Decimal {\n    fn from(n: Decimal256) -\u003e Self {\n        let U256(ref arr) = n.0;\n        assert!(arr[2] == 0u64);\n        assert!(arr[3] == 0u64);\n        Decimal::from_str(\u0026n.to_string()).unwrap()\n    }\n}\n\nimpl FromStr for Decimal256 {\n    type Err = StdError;\n\n    /// Converts the decimal string to a Decimal256\n    /// Possible inputs: \"1.23\", \"1\", \"000012\", \"1.123000000\"\n    /// Disallowed: \"\", \".23\"\n    ///\n    /// This never performs any kind of rounding.\n    /// More than 18 fractional digits, even zeros, result in an error.\n    fn from_str(input: \u0026str) -\u003e Result\u003cSelf, Self::Err\u003e {\n        let parts: Vec\u003c\u0026str\u003e = input.split('.').collect();\n        match parts.len() {\n            1 =\u003e {\n                let whole = U256::from_dec_str(parts[0])\n                    .map_err(|_| StdError::generic_err(\"Error parsing whole\"))?;\n\n                let whole_as_atomics = whole * Decimal256::DECIMAL_FRACTIONAL;\n                Ok(Decimal256(whole_as_atomics))\n            }\n            2 =\u003e {\n                let whole = U256::from_dec_str(parts[0])\n                    .map_err(|_| StdError::generic_err(\"Error parsing whole\"))?;\n                let fractional = U256::from_dec_str(parts[1])\n                    .map_err(|_| StdError::generic_err(\"Error parsing fractional\"))?;\n                let exp = (18usize.checked_sub(parts[1].len())).ok_or_else(|| {\n                    StdError::generic_err(\"Cannot parse more than 18 fractional digits\")\n                })?;\n                let fractional_factor = U256::from(10).pow(exp.into());\n\n                let whole_as_atomics = whole * Decimal256::DECIMAL_FRACTIONAL;\n                let atomics = whole_as_atomics + fractional * fractional_factor;\n                Ok(Decimal256(atomics))\n            }\n            _ =\u003e Err(StdError::generic_err(\"Unexpected number of dots\")),\n        }\n    }\n}\n\nimpl fmt::Display for Decimal256 {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        let whole = (self.0) / Decimal256::DECIMAL_FRACTIONAL;\n        let fractional = (self.0) % Decimal256::DECIMAL_FRACTIONAL;\n\n        if fractional.is_zero() {\n            write!(f, \"{}\", whole)\n        } else {\n            let fractional_string = fractional.to_string();\n            let fractional_string = \"0\".repeat(18 - fractional_string.len()) + \u0026fractional_string;\n\n            f.write_str(\u0026whole.to_string())?;\n            f.write_char('.')?;\n            f.write_str(fractional_string.trim_end_matches('0'))?;\n\n            Ok(())\n        }\n    }\n}\n\nimpl ops::Add for Decimal256 {\n    type Output = Self;\n\n    fn add(self, rhs: Self) -\u003e Self {\n        Decimal256(self.0 + rhs.0)\n    }\n}\n\nimpl ops::AddAssign for Decimal256 {\n    fn add_assign(\u0026mut self, rhs: Self) {\n        self.0 = self.0 + rhs.0;\n    }\n}\n\nimpl ops::Sub for Decimal256 {\n    type Output = Self;\n\n    fn sub(self, rhs: Self) -\u003e Self {\n        assert!(self.0 \u003e= rhs.0);\n        Decimal256(self.0 - rhs.0)\n    }\n}\n\nimpl ops::Mul for Decimal256 {\n    type Output = Self;\n\n    fn mul(self, rhs: Self) -\u003e Self {\n        Decimal256(self.0 * rhs.0 / Decimal256::DECIMAL_FRACTIONAL)\n    }\n}\n\nimpl ops::Div for Decimal256 {\n    type Output = Self;\n\n    fn div(self, rhs: Self) -\u003e Self {\n        assert!(!rhs.is_zero());\n\n        Decimal256(self.0 * Decimal256::DECIMAL_FRACTIONAL / rhs.0)\n    }\n}\n\n/// Serializes as a decimal string\nimpl Serialize for Decimal256 {\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: ser::Serializer,\n    {\n        serializer.serialize_str(\u0026self.to_string())\n    }\n}\n\n/// Deserializes as a base64 string\nimpl\u003c'de\u003e Deserialize\u003c'de\u003e for Decimal256 {\n    fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cDecimal256, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        deserializer.deserialize_str(Decimal256Visitor)\n    }\n}\n\nstruct Decimal256Visitor;\n\nimpl\u003c'de\u003e de::Visitor\u003c'de\u003e for Decimal256Visitor {\n    type Value = Decimal256;\n\n    fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        formatter.write_str(\"string-encoded decimal\")\n    }\n\n    fn visit_str\u003cE\u003e(self, v: \u0026str) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: de::Error,\n    {\n        match Decimal256::from_str(v) {\n            Ok(d) =\u003e Ok(d),\n            Err(e) =\u003e Err(E::custom(format!(\"Error parsing decimal '{}': {}\", v, e))),\n        }\n    }\n}\n\n//*** Uint256 ***/\n#[derive(Copy, Clone, Default, Debug, PartialEq, Eq, PartialOrd, Ord, JsonSchema)]\npub struct Uint256(#[schemars(with = \"String\")] pub U256);\n\nimpl Uint256 {\n    /// Creates a Uint256(0)\n    pub const fn zero() -\u003e Self {\n        Uint256(U256([0, 0, 0, 0]))\n    }\n\n    /// Create a 1.0 Decimal256\n    pub const fn one() -\u003e Self {\n        Uint256(U256([1, 0, 0, 0]))\n    }\n\n    pub fn is_zero(\u0026self) -\u003e bool {\n        self.0.is_zero()\n    }\n}\n\nimpl From\u003cU256\u003e for Uint256 {\n    fn from(val: U256) -\u003e Self {\n        Uint256(val)\n    }\n}\n\nimpl From\u003cUint256\u003e for U256 {\n    fn from(val: Uint256) -\u003e Self {\n        val.0\n    }\n}\n\n#[inline(always)]\nfn split_u128(a: u128) -\u003e (u64, u64) {\n    ((a \u003e\u003e 64) as _, (a \u0026 0xFFFFFFFFFFFFFFFF) as _)\n}\n\nimpl From\u003cUint128\u003e for Uint256 {\n    fn from(val: Uint128) -\u003e Self {\n        Uint256::from(val.u128())\n    }\n}\n\nimpl From\u003cu128\u003e for Uint256 {\n    fn from(val: u128) -\u003e Self {\n        let (hi, low) = split_u128(val);\n        Uint256(U256([low, hi, 0, 0]))\n    }\n}\n\nimpl From\u003cu64\u003e for Uint256 {\n    fn from(val: u64) -\u003e Self {\n        Uint256(val.into())\n    }\n}\n\nimpl TryFrom\u003c\u0026str\u003e for Uint256 {\n    type Error = StdError;\n\n    fn try_from(val: \u0026str) -\u003e Result\u003cSelf, Self::Error\u003e {\n        match U256::from_dec_str(val) {\n            Ok(u) =\u003e Ok(Uint256(u)),\n            Err(_e) =\u003e Err(StdError::generic_err(format!(\"invalid Uint256 '{}'\", val))),\n        }\n    }\n}\n\nimpl FromStr for Uint256 {\n    type Err = StdError;\n\n    fn from_str(input: \u0026str) -\u003e Result\u003cSelf, Self::Err\u003e {\n        let number =\n            U256::from_dec_str(input).map_err(|_| StdError::generic_err(\"Error parsing number\"))?;\n        Ok(Uint256(number))\n    }\n}\n\nimpl From\u003cUint256\u003e for String {\n    fn from(n: Uint256) -\u003e Self {\n        n.0.to_string()\n    }\n}\n\nimpl From\u003cUint256\u003e for u128 {\n    fn from(n: Uint256) -\u003e Self {\n        let U256(ref arr) = n.0;\n        assert!(arr[2] == 0u64);\n        assert!(arr[3] == 0u64);\n\n        let (hi, low) = (arr[1], arr[0]);\n        ((hi as u128) \u003c\u003c 64) + (low as u128)\n    }\n}\n\nimpl From\u003cUint256\u003e for Uint128 {\n    fn from(n: Uint256) -\u003e Self {\n        let num: u128 = n.into();\n        Uint128::from(num)\n    }\n}\n\nimpl fmt::Display for Uint256 {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n\nimpl ops::Add for Uint256 {\n    type Output = Self;\n\n    fn add(self, rhs: Self) -\u003e Self {\n        Uint256(self.0 + rhs.0)\n    }\n}\n\nimpl ops::AddAssign for Uint256 {\n    fn add_assign(\u0026mut self, other: Self) {\n        self.0 = self.0 + other.0;\n    }\n}\n\nimpl ops::Sub for Uint256 {\n    type Output = Self;\n\n    fn sub(self, rhs: Self) -\u003e Self::Output {\n        assert!(self.0 \u003e= rhs.0);\n        Uint256(self.0 - rhs.0)\n    }\n}\n\nimpl ops::Mul\u003cUint256\u003e for Uint256 {\n    type Output = Self;\n\n    #[allow(clippy::suspicious_arithmetic_impl)]\n    fn mul(self, rhs: Uint256) -\u003e Self::Output {\n        // 0*a and b*0 is always 0\n        if self.is_zero() || rhs.is_zero() {\n            return Uint256::zero();\n        }\n\n        Uint256(self.0 * rhs.0)\n    }\n}\n\n/// Both d*u and u*d with d: Decimal256 and u: Uint256 returns an Uint256. There is no\n/// specific reason for this decision other than the initial use cases we have. If you\n/// need a Decimal256 result for the same calculation, use Decimal256(d*u) or Decimal256(u*d).\nimpl ops::Mul\u003cDecimal256\u003e for Uint256 {\n    type Output = Self;\n\n    #[allow(clippy::suspicious_arithmetic_impl)]\n    fn mul(self, rhs: Decimal256) -\u003e Self::Output {\n        // 0*a and b*0 is always 0\n        if self.is_zero() || rhs.is_zero() {\n            return Uint256::zero();\n        }\n\n        self.multiply_ratio(rhs.0, Decimal256::DECIMAL_FRACTIONAL)\n    }\n}\n\nimpl ops::Div\u003cDecimal256\u003e for Uint256 {\n    type Output = Self;\n\n    fn div(self, rhs: Decimal256) -\u003e Self::Output {\n        assert!(!rhs.is_zero());\n\n        if self.is_zero() {\n            return Uint256::zero();\n        }\n\n        self.multiply_ratio(Decimal256::DECIMAL_FRACTIONAL, rhs.0)\n    }\n}\n\nimpl ops::Mul\u003cUint256\u003e for Decimal256 {\n    type Output = Uint256;\n\n    fn mul(self, rhs: Uint256) -\u003e Self::Output {\n        rhs * self\n    }\n}\n\nimpl Uint256 {\n    /// returns self * nom / denom\n    pub fn multiply_ratio\u003cA: Into\u003cU256\u003e, B: Into\u003cU256\u003e\u003e(\u0026self, nom: A, denom: B) -\u003e Uint256 {\n        let nominator: U256 = nom.into();\n        let denominator: U256 = denom.into();\n        if denominator.is_zero() {\n            panic!(\"Denominator must not be zero\");\n        }\n\n        // TODO: minimize rounding that takes place (using gcd algorithm)\n        let val = self.0 * nominator / denominator;\n        Uint256::from(val)\n    }\n}\n\n/// Serializes as a base64 string\nimpl Serialize for Uint256 {\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: ser::Serializer,\n    {\n        serializer.serialize_str(\u0026self.to_string())\n    }\n}\n\n/// Deserializes as a base64 string\nimpl\u003c'de\u003e Deserialize\u003c'de\u003e for Uint256 {\n    fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cUint256, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        deserializer.deserialize_str(Uint256Visitor)\n    }\n}\n\nstruct Uint256Visitor;\n\nimpl\u003c'de\u003e de::Visitor\u003c'de\u003e for Uint256Visitor {\n    type Value = Uint256;\n\n    fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        formatter.write_str(\"string-encoded integer\")\n    }\n\n    fn visit_str\u003cE\u003e(self, v: \u0026str) -\u003e Result\u003cSelf::Value, E\u003e\n    where\n        E: de::Error,\n    {\n        match U256::from_dec_str(v) {\n            Ok(u) =\u003e Ok(Uint256(u)),\n            Err(_e) =\u003e Err(E::custom(format!(\"invalid Uint256 '{}'\", v))),\n        }\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n    use cosmwasm_std::{from_slice, to_vec, StdResult};\n    use std::convert::TryInto;\n\n    #[test]\n    fn decimal_one() {\n        let value = Decimal256::one();\n        assert_eq!(value.0, Decimal256::DECIMAL_FRACTIONAL);\n    }\n\n    #[test]\n    fn decimal_zero() {\n        let value = Decimal256::zero();\n        assert_eq!(value.0, U256::zero());\n    }\n\n    #[test]\n    fn decimal_percent() {\n        let value = Decimal256::percent(50);\n        assert_eq!(value.0, Decimal256::DECIMAL_FRACTIONAL / 2.into());\n    }\n\n    #[test]\n    fn decimal_permille() {\n        let value = Decimal256::permille(125);\n        assert_eq!(value.0, Decimal256::DECIMAL_FRACTIONAL / 8.into());\n    }\n\n    #[test]\n    fn decimal_from_ratio_works() {\n        // 1.0\n        assert_eq!(Decimal256::from_ratio(1, 1), Decimal256::one());\n        assert_eq!(Decimal256::from_ratio(53, 53), Decimal256::one());\n        assert_eq!(Decimal256::from_ratio(125, 125), Decimal256::one());\n\n        // 1.5\n        assert_eq!(Decimal256::from_ratio(3, 2), Decimal256::percent(150));\n        assert_eq!(Decimal256::from_ratio(150, 100), Decimal256::percent(150));\n        assert_eq!(Decimal256::from_ratio(333, 222), Decimal256::percent(150));\n\n        // 0.125\n        assert_eq!(Decimal256::from_ratio(1, 8), Decimal256::permille(125));\n        assert_eq!(Decimal256::from_ratio(125, 1000), Decimal256::permille(125));\n\n        // 1/3 (result floored)\n        assert_eq!(\n            Decimal256::from_ratio(1, 3),\n            Decimal256(333_333_333_333_333_333u64.into())\n        );\n\n        // 2/3 (result floored)\n        assert_eq!(\n            Decimal256::from_ratio(2, 3),\n            Decimal256(666_666_666_666_666_666u64.into())\n        );\n    }\n\n    #[test]\n    #[should_panic(expected = \"Denominator must not be zero\")]\n    fn decimal_from_ratio_panics_for_zero_denominator() {\n        Decimal256::from_ratio(1, 0);\n    }\n\n    #[test]\n    fn decimal_from_str_works() {\n        // Integers\n        assert_eq!(Decimal256::from_str(\"\").unwrap(), Decimal256::percent(0));\n        assert_eq!(Decimal256::from_str(\"0\").unwrap(), Decimal256::percent(0));\n        assert_eq!(Decimal256::from_str(\"1\").unwrap(), Decimal256::percent(100));\n        assert_eq!(Decimal256::from_str(\"5\").unwrap(), Decimal256::percent(500));\n        assert_eq!(\n            Decimal256::from_str(\"42\").unwrap(),\n            Decimal256::percent(4200)\n        );\n        assert_eq!(Decimal256::from_str(\"000\").unwrap(), Decimal256::percent(0));\n        assert_eq!(\n            Decimal256::from_str(\"001\").unwrap(),\n            Decimal256::percent(100)\n        );\n        assert_eq!(\n            Decimal256::from_str(\"005\").unwrap(),\n            Decimal256::percent(500)\n        );\n        assert_eq!(\n            Decimal256::from_str(\"0042\").unwrap(),\n            Decimal256::percent(4200)\n        );\n\n        // Decimal256s\n        assert_eq!(\n            Decimal256::from_str(\"1.\").unwrap(),\n            Decimal256::percent(100)\n        );\n        assert_eq!(\n            Decimal256::from_str(\"1.0\").unwrap(),\n            Decimal256::percent(100)\n        );\n        assert_eq!(\n            Decimal256::from_str(\"1.5\").unwrap(),\n            Decimal256::percent(150)\n        );\n        assert_eq!(\n            Decimal256::from_str(\"0.5\").unwrap(),\n            Decimal256::percent(50)\n        );\n        assert_eq!(\n            Decimal256::from_str(\"0.123\").unwrap(),\n            Decimal256::permille(123)\n        );\n\n        assert_eq!(\n            Decimal256::from_str(\"40.00\").unwrap(),\n            Decimal256::percent(4000)\n        );\n        assert_eq!(\n            Decimal256::from_str(\"04.00\").unwrap(),\n            Decimal256::percent(400)\n        );\n        assert_eq!(\n            Decimal256::from_str(\"00.40\").unwrap(),\n            Decimal256::percent(40)\n        );\n        assert_eq!(\n            Decimal256::from_str(\"00.04\").unwrap(),\n            Decimal256::percent(4)\n        );\n\n        // Can handle 18 fractional digits\n        assert_eq!(\n            Decimal256::from_str(\"7.123456789012345678\").unwrap(),\n            Decimal256(7123456789012345678u64.into())\n        );\n        assert_eq!(\n            Decimal256::from_str(\"7.999999999999999999\").unwrap(),\n            Decimal256(7999999999999999999u64.into())\n        );\n\n        // Works for documented max value\n        assert_eq!(\n            Decimal256::from_str(\n                \"115792089237316195423570985008687907853269984665640564039457.584007913129639935\"\n            )\n            .unwrap(),\n            Decimal256::MAX\n        );\n    }\n\n    #[test]\n    fn decimal_from_str_errors_for_broken_whole_part() {\n        match Decimal256::from_str(\" \").unwrap_err() {\n            StdError::GenericErr { msg, .. } =\u003e assert_eq!(msg, \"Error parsing whole\"),\n            e =\u003e panic!(\"Unexpected error: {:?}\", e),\n        }\n\n        match Decimal256::from_str(\"-1\").unwrap_err() {\n            StdError::GenericErr { msg, .. } =\u003e assert_eq!(msg, \"Error parsing whole\"),\n            e =\u003e panic!(\"Unexpected error: {:?}\", e),\n        }\n    }\n\n    #[test]\n    fn decimal_from_str_errors_for_broken_fractinal_part() {\n        match Decimal256::from_str(\"1. \").unwrap_err() {\n            StdError::GenericErr { msg, .. } =\u003e assert_eq!(msg, \"Error parsing fractional\"),\n            e =\u003e panic!(\"Unexpected error: {:?}\", e),\n        }\n\n        match Decimal256::from_str(\"1.e\").unwrap_err() {\n            StdError::GenericErr { msg, .. } =\u003e assert_eq!(msg, \"Error parsing fractional\"),\n            e =\u003e panic!(\"Unexpected error: {:?}\", e),\n        }\n\n        match Decimal256::from_str(\"1.2e3\").unwrap_err() {\n            StdError::GenericErr { msg, .. } =\u003e assert_eq!(msg, \"Error parsing fractional\"),\n            e =\u003e panic!(\"Unexpected error: {:?}\", e),\n        }\n    }\n\n    #[test]\n    fn decimal_from_str_errors_for_more_than_18_fractional_digits() {\n        match Decimal256::from_str(\"7.1234567890123456789\").unwrap_err() {\n            StdError::GenericErr { msg, .. } =\u003e {\n                assert_eq!(msg, \"Cannot parse more than 18 fractional digits\")\n            }\n            e =\u003e panic!(\"Unexpected error: {:?}\", e),\n        }\n\n        // No special rules for trailing zeros. This could be changed but adds gas cost for the happy path.\n        match Decimal256::from_str(\"7.1230000000000000000\").unwrap_err() {\n            StdError::GenericErr { msg, .. } =\u003e {\n                assert_eq!(msg, \"Cannot parse more than 18 fractional digits\")\n            }\n            e =\u003e panic!(\"Unexpected error: {:?}\", e),\n        }\n    }\n\n    #[test]\n    fn decimal_from_str_errors_for_invalid_number_of_dots() {\n        match Decimal256::from_str(\"1.2.3\").unwrap_err() {\n            StdError::GenericErr { msg, .. } =\u003e assert_eq!(msg, \"Unexpected number of dots\"),\n            e =\u003e panic!(\"Unexpected error: {:?}\", e),\n        }\n\n        match Decimal256::from_str(\"1.2.3.4\").unwrap_err() {\n            StdError::GenericErr { msg, .. } =\u003e assert_eq!(msg, \"Unexpected number of dots\"),\n            e =\u003e panic!(\"Unexpected error: {:?}\", e),\n        }\n    }\n\n    #[test]\n    #[should_panic(expected = \"arithmetic operation overflow\")]\n    fn decimal_from_str_errors_for_more_than_max_value_integer_part() {\n        let _ =\n            Decimal256::from_str(\"115792089237316195423570985008687907853269984665640564039458\");\n    }\n\n    #[test]\n    #[should_panic(expected = \"arithmetic operation overflow\")]\n    fn decimal_from_str_errors_for_more_than_max_value_integer_part_with_decimal() {\n        let _ =\n            Decimal256::from_str(\"115792089237316195423570985008687907853269984665640564039458.0\");\n    }\n    #[test]\n    #[should_panic(expected = \"arithmetic operation overflow\")]\n    fn decimal_from_str_errors_for_more_than_max_value_decimal_part() {\n        let _ = Decimal256::from_str(\n            \"115792089237316195423570985008687907853269984665640564039457.584007913129639936\",\n        );\n    }\n\n    #[test]\n    fn decimal_is_zero_works() {\n        assert!(Decimal256::zero().is_zero());\n        assert!(Decimal256::percent(0).is_zero());\n        assert!(Decimal256::permille(0).is_zero());\n\n        assert!(!Decimal256::one().is_zero());\n        assert!(!Decimal256::percent(123).is_zero());\n        assert!(!Decimal256::permille(1234).is_zero());\n    }\n\n    #[test]\n    fn decimal_add() {\n        let value = Decimal256::one() + Decimal256::percent(50); // 1.5\n        assert_eq!(\n            value.0,\n            Decimal256::DECIMAL_FRACTIONAL * U256::from(3) / U256::from(2)\n        );\n    }\n\n    #[test]\n    fn decimal_sub() {\n        assert_eq!(\n            Decimal256::percent(50),\n            Decimal256::one() - Decimal256::percent(50)\n        );\n    }\n\n    #[test]\n    fn decimal_mul() {\n        assert_eq!(\n            Decimal256::percent(25),\n            Decimal256::percent(50) * Decimal256::percent(50)\n        );\n    }\n\n    #[test]\n    fn decimal_div() {\n        assert_eq!(\n            Decimal256::one() + Decimal256::one(),\n            Decimal256::percent(50) / Decimal256::percent(25)\n        );\n    }\n\n    #[test]\n    fn decimal_to_string() {\n        // Integers\n        assert_eq!(Decimal256::zero().to_string(), \"0\");\n        assert_eq!(Decimal256::one().to_string(), \"1\");\n        assert_eq!(Decimal256::percent(500).to_string(), \"5\");\n\n        // Decimal256s\n        assert_eq!(Decimal256::percent(125).to_string(), \"1.25\");\n        assert_eq!(Decimal256::percent(42638).to_string(), \"426.38\");\n        assert_eq!(Decimal256::percent(1).to_string(), \"0.01\");\n        assert_eq!(Decimal256::permille(987).to_string(), \"0.987\");\n\n        assert_eq!(Decimal256(1u64.into()).to_string(), \"0.000000000000000001\");\n        assert_eq!(Decimal256(10u64.into()).to_string(), \"0.00000000000000001\");\n        assert_eq!(Decimal256(100u64.into()).to_string(), \"0.0000000000000001\");\n        assert_eq!(Decimal256(1000u64.into()).to_string(), \"0.000000000000001\");\n        assert_eq!(Decimal256(10000u64.into()).to_string(), \"0.00000000000001\");\n        assert_eq!(Decimal256(100000u64.into()).to_string(), \"0.0000000000001\");\n        assert_eq!(Decimal256(1000000u64.into()).to_string(), \"0.000000000001\");\n        assert_eq!(Decimal256(10000000u64.into()).to_string(), \"0.00000000001\");\n        assert_eq!(Decimal256(100000000u64.into()).to_string(), \"0.0000000001\");\n        assert_eq!(Decimal256(1000000000u64.into()).to_string(), \"0.000000001\");\n        assert_eq!(Decimal256(10000000000u64.into()).to_string(), \"0.00000001\");\n        assert_eq!(Decimal256(100000000000u64.into()).to_string(), \"0.0000001\");\n        assert_eq!(Decimal256(10000000000000u64.into()).to_string(), \"0.00001\");\n        assert_eq!(Decimal256(100000000000000u64.into()).to_string(), \"0.0001\");\n        assert_eq!(Decimal256(1000000000000000u64.into()).to_string(), \"0.001\");\n        assert_eq!(Decimal256(10000000000000000u64.into()).to_string(), \"0.01\");\n        assert_eq!(Decimal256(100000000000000000u64.into()).to_string(), \"0.1\");\n    }\n\n    #[test]\n    fn decimal_serialize() {\n        assert_eq!(to_vec(\u0026Decimal256::zero()).unwrap(), br#\"\"0\"\"#);\n        assert_eq!(to_vec(\u0026Decimal256::one()).unwrap(), br#\"\"1\"\"#);\n        assert_eq!(to_vec(\u0026Decimal256::percent(8)).unwrap(), br#\"\"0.08\"\"#);\n        assert_eq!(to_vec(\u0026Decimal256::percent(87)).unwrap(), br#\"\"0.87\"\"#);\n        assert_eq!(to_vec(\u0026Decimal256::percent(876)).unwrap(), br#\"\"8.76\"\"#);\n        assert_eq!(to_vec(\u0026Decimal256::percent(8765)).unwrap(), br#\"\"87.65\"\"#);\n    }\n\n    #[test]\n    fn decimal_deserialize() {\n        assert_eq!(\n            from_slice::\u003cDecimal256\u003e(br#\"\"0\"\"#).unwrap(),\n            Decimal256::zero()\n        );\n        assert_eq!(\n            from_slice::\u003cDecimal256\u003e(br#\"\"1\"\"#).unwrap(),\n            Decimal256::one()\n        );\n        assert_eq!(\n            from_slice::\u003cDecimal256\u003e(br#\"\"000\"\"#).unwrap(),\n            Decimal256::zero()\n        );\n        assert_eq!(\n            from_slice::\u003cDecimal256\u003e(br#\"\"001\"\"#).unwrap(),\n            Decimal256::one()\n        );\n\n        assert_eq!(\n            from_slice::\u003cDecimal256\u003e(br#\"\"0.08\"\"#).unwrap(),\n            Decimal256::percent(8)\n        );\n        assert_eq!(\n            from_slice::\u003cDecimal256\u003e(br#\"\"0.87\"\"#).unwrap(),\n            Decimal256::percent(87)\n        );\n        assert_eq!(\n            from_slice::\u003cDecimal256\u003e(br#\"\"8.76\"\"#).unwrap(),\n            Decimal256::percent(876)\n        );\n        assert_eq!(\n            from_slice::\u003cDecimal256\u003e(br#\"\"87.65\"\"#).unwrap(),\n            Decimal256::percent(8765)\n        );\n    }\n\n    #[test]\n    fn to_and_from_uint256() {\n        let a: Uint256 = 12345u64.into();\n        assert_eq!(U256::from(12345), a.0);\n        assert_eq!(\"12345\", a.to_string());\n\n        let a: Uint256 = \"34567\".try_into().unwrap();\n        assert_eq!(U256::from(34567), a.0);\n        assert_eq!(\"34567\", a.to_string());\n\n        let a: StdResult\u003cUint256\u003e = \"1.23\".try_into();\n        assert!(a.is_err());\n    }\n\n    #[test]\n    fn uint256_is_zero_works() {\n        assert!(Uint256::zero().is_zero());\n        assert!(Uint256::from(0u64).is_zero());\n\n        assert!(!Uint256::from(1u64).is_zero());\n        assert!(!Uint256::from(123u64).is_zero());\n    }\n\n    #[test]\n    fn uint256_json() {\n        let orig = Uint256::from(1234567890987654321u64);\n        let serialized = to_vec(\u0026orig).unwrap();\n        assert_eq!(serialized.as_slice(), b\"\\\"1234567890987654321\\\"\");\n        let parsed: Uint256 = from_slice(\u0026serialized).unwrap();\n        assert_eq!(parsed, orig);\n    }\n\n    #[test]\n    fn uint256_compare() {\n        let a = Uint256::from(12345u64);\n        let b = Uint256::from(23456u64);\n\n        assert!(a \u003c b);\n        assert!(b \u003e a);\n        assert_eq!(a, Uint256::from(12345u64));\n    }\n\n    #[test]\n    fn uint256_math() {\n        let a = Uint256::from(12345u64);\n        let b = Uint256::from(23456u64);\n\n        // test + and - for valid values\n        assert_eq!(a + b, Uint256::from(35801u64));\n        assert_eq!(b - a, Uint256::from(11111u64));\n\n        // test +=\n        let mut c = Uint256::from(300000u64);\n        c += b;\n        assert_eq!(c, Uint256::from(323456u64));\n    }\n    #[test]\n    #[should_panic]\n    fn uint256_math_sub_underflow() {\n        let _ = Uint256::from(12345u64) - Uint256::from(23456u64);\n    }\n\n    #[test]\n    #[should_panic]\n    fn uint256_math_overflow_panics() {\n        // almost_max is 2^256 - 10\n        let almost_max = Uint256::from(U256([\n            18446744073709551615,\n            18446744073709551615,\n            18446744073709551615,\n            18446744073709551615,\n        ]));\n        let _ = almost_max + Uint256::from(12u64);\n    }\n\n    #[test]\n    // in this test the Decimal256 is on the right\n    fn uint256_decimal_multiply() {\n        // a*b\n        let left = Uint256::from(300u64);\n        let right = Decimal256::one() + Decimal256::percent(50); // 1.5\n        assert_eq!(left * right, Uint256::from(450u64));\n\n        // a*0\n        let left = Uint256::from(300u64);\n        let right = Decimal256::zero();\n        assert_eq!(left * right, Uint256::from(0u64));\n\n        // 0*a\n        let left = Uint256::zero();\n        let right = Decimal256::one() + Decimal256::percent(50); // 1.5\n        assert_eq!(left * right, Uint256::zero());\n    }\n\n    #[test]\n    fn u256_multiply_ratio_works() {\n        let base = Uint256::from(500u64);\n\n        // factor 1/1\n        assert_eq!(base.multiply_ratio(1, 1), Uint256::from(500u64));\n        assert_eq!(base.multiply_ratio(3, 3), Uint256::from(500u64));\n        assert_eq!(base.multiply_ratio(654321, 654321), Uint256::from(500u64));\n\n        // factor 3/2\n        assert_eq!(base.multiply_ratio(3, 2), Uint256::from(750u64));\n        assert_eq!(base.multiply_ratio(333333, 222222), Uint256::from(750u64));\n\n        // factor 2/3 (integer devision always floors the result)\n        assert_eq!(base.multiply_ratio(2, 3), Uint256::from(333u64));\n        assert_eq!(base.multiply_ratio(222222, 333333), Uint256::from(333u64));\n\n        // factor 5/6 (integer devision always floors the result)\n        assert_eq!(base.multiply_ratio(5, 6), Uint256::from(416u64));\n        assert_eq!(base.multiply_ratio(100, 120), Uint256::from(416u64));\n    }\n\n    #[test]\n    fn u256_from_u128() {\n        assert_eq!(Uint256::from(100u64), Uint256::from(100u128));\n        let num = Uint256::from(1_000_000_000_000_000_000_000_000u128);\n        assert_eq!(num.to_string(), \"1000000000000000000000000\");\n    }\n\n    #[test]\n    #[should_panic(expected = \"Denominator must not be zero\")]\n    fn u256_multiply_ratio_panics_for_zero_denominator() {\n        Uint256::from(500u64).multiply_ratio(1, 0);\n    }\n\n    #[test]\n    fn u256_zero_one() {\n        assert_eq!(Uint256::zero().0, U256::zero());\n        assert_eq!(Uint256::one().0, U256::one());\n    }\n\n    #[test]\n    fn u256_into_u128() {\n        let val: u128 = Uint256::from(1234556700000000000999u128).into();\n        assert_eq!(val, 1234556700000000000999u128);\n    }\n\n    #[test]\n    #[should_panic]\n    fn u256_into_u128_panics_for_overflow() {\n        let _: u128 = Uint256::from_str(\"2134982317498312749832174923184732198471983247\")\n            .unwrap()\n            .into();\n    }\n\n    #[test]\n    // in this test the Decimal256 is on the left\n    fn decimal_uint256_multiply() {\n        // a*b\n        let left = Decimal256::one() + Decimal256::percent(50); // 1.5\n        let right = Uint256::from(300u64);\n        assert_eq!(left * right, Uint256::from(450u64));\n\n        // 0*a\n        let left = Decimal256::zero();\n        let right = Uint256::from(300u64);\n        assert_eq!(left * right, Uint256::from(0u64));\n\n        // a*0\n        let left = Decimal256::one() + Decimal256::percent(50); // 1.5\n        let right = Uint256::from(0u64);\n        assert_eq!(left * right, Uint256::from(0u64));\n    }\n}\n","traces":[{"line":21,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":47},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":47},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":43},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":43},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":43},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":43},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":48},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":84},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":84},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":81},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":90},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":37},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":37},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":37},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":37},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":53},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":53},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":68},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":68},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":70},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":70},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":67},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":67},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":70},"fn_name":null},{"line":260,"address":[],"length":0,"stats":{"Line":70},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":70},"fn_name":null},{"line":266,"address":[],"length":0,"stats":{"Line":39},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":39},"fn_name":null},{"line":274,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":275,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":285,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":286,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":287,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":288,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":293,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":294,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":299,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":300,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":302,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":304,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":305,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":310,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":311,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":312,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":317,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":318,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":325,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":326,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":331,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":332,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":339,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":340,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":341,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":349,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":350,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":351,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":352,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":355,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":366,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":367,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":368,"address":[],"length":0,"stats":{"Line":55},"fn_name":null},{"line":369,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":372,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":379,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":380,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":382,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":383,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":386,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":393,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":394,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":400,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":401,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":402,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":403,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":404,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":407,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":408,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":409,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":415,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":419,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":425,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":429,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":438,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":439,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":442,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":446,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":447,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":448,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":142,"coverable":159},{"path":["/","Users","haitran","AURA-NETWORK","smart-contracts-halotrade-zone","packages","haloswap","examples","schema.rs"],"content":"use std::env::current_dir;\nuse std::fs::create_dir_all;\n\nuse cosmwasm_schema::{export_schema, remove_schemas, schema_for};\n\nuse haloswap::asset::{Asset, AssetInfo, PairInfo};\n\nfn main() {\n    let mut out_dir = current_dir().unwrap();\n    out_dir.push(\"schema\");\n    create_dir_all(\u0026out_dir).unwrap();\n    remove_schemas(\u0026out_dir).unwrap();\n\n    export_schema(\u0026schema_for!(PairInfo), \u0026out_dir);\n    export_schema(\u0026schema_for!(Asset), \u0026out_dir);\n    export_schema(\u0026schema_for!(AssetInfo), \u0026out_dir);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","haitran","AURA-NETWORK","smart-contracts-halotrade-zone","packages","haloswap","src","asset.rs"],"content":"use cosmwasm_schema::cw_serde;\nuse std::fmt;\n\nuse crate::querier::{query_balance, query_native_decimals, query_token_balance, query_token_info};\nuse cosmwasm_std::{\n    to_binary, Addr, Api, BankMsg, CanonicalAddr, Coin, CosmosMsg, MessageInfo, QuerierWrapper,\n    StdError, StdResult, SubMsg, Uint128, WasmMsg,\n};\nuse cw20::Cw20ExecuteMsg;\n\n#[cw_serde]\npub struct Asset {\n    pub info: AssetInfo,\n    pub amount: Uint128,\n}\n\nimpl fmt::Display for Asset {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        write!(f, \"{}{}\", self.amount, self.info)\n    }\n}\n\nimpl Asset {\n    pub fn is_native_token(\u0026self) -\u003e bool {\n        self.info.is_native_token()\n    }\n\n    pub fn into_msg(self, recipient: Addr) -\u003e StdResult\u003cCosmosMsg\u003e {\n        let amount = self.amount;\n\n        match \u0026self.info {\n            AssetInfo::Token { contract_addr } =\u003e Ok(CosmosMsg::Wasm(WasmMsg::Execute {\n                contract_addr: contract_addr.to_string(),\n                msg: to_binary(\u0026Cw20ExecuteMsg::Transfer {\n                    recipient: recipient.to_string(),\n                    amount,\n                })?,\n                funds: vec![],\n            })),\n            AssetInfo::NativeToken { denom } =\u003e Ok(CosmosMsg::Bank(BankMsg::Send {\n                to_address: recipient.to_string(),\n                amount: vec![Coin {\n                    amount: self.amount,\n                    denom: denom.to_string(),\n                }],\n            })),\n        }\n    }\n\n    pub fn into_submsg(self, recipient: Addr) -\u003e StdResult\u003cSubMsg\u003e {\n        Ok(SubMsg::new(self.into_msg(recipient)?))\n    }\n\n    pub fn assert_sent_native_token_balance(\u0026self, message_info: \u0026MessageInfo) -\u003e StdResult\u003c()\u003e {\n        if let AssetInfo::NativeToken { denom } = \u0026self.info {\n            match message_info.funds.iter().find(|x| x.denom == *denom) {\n                Some(coin) =\u003e {\n                    if self.amount == coin.amount {\n                        Ok(())\n                    } else {\n                        Err(StdError::generic_err(\"Native token balance mismatch between the argument and the transferred\"))\n                    }\n                }\n                None =\u003e {\n                    if self.amount.is_zero() {\n                        Ok(())\n                    } else {\n                        Err(StdError::generic_err(\"Native token balance mismatch between the argument and the transferred\"))\n                    }\n                }\n            }\n        } else {\n            Ok(())\n        }\n    }\n\n    pub fn to_raw(\u0026self, api: \u0026dyn Api) -\u003e StdResult\u003cAssetRaw\u003e {\n        Ok(AssetRaw {\n            info: match \u0026self.info {\n                AssetInfo::NativeToken { denom } =\u003e AssetInfoRaw::NativeToken {\n                    denom: denom.to_string(),\n                },\n                AssetInfo::Token { contract_addr } =\u003e AssetInfoRaw::Token {\n                    contract_addr: api.addr_canonicalize(contract_addr.as_str())?,\n                },\n            },\n            amount: self.amount,\n        })\n    }\n}\n\n#[cw_serde]\npub struct CreatePairRequirements {\n    pub whitelist: Vec\u003cAddr\u003e,\n    pub first_asset_minimum: Uint128,\n    pub second_asset_minimum: Uint128,\n}\n\n/// AssetInfo contract_addr is usually passed from the cw20 hook\n/// so we can trust the contract_addr is properly validated.\n#[cw_serde]\npub enum AssetInfo {\n    Token { contract_addr: String },\n    NativeToken { denom: String },\n}\n\nimpl fmt::Display for AssetInfo {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        match self {\n            AssetInfo::NativeToken { denom } =\u003e write!(f, \"{}\", denom),\n            AssetInfo::Token { contract_addr } =\u003e write!(f, \"{}\", contract_addr),\n        }\n    }\n}\n\nimpl AssetInfo {\n    pub fn to_raw(\u0026self, api: \u0026dyn Api) -\u003e StdResult\u003cAssetInfoRaw\u003e {\n        match self {\n            AssetInfo::NativeToken { denom } =\u003e Ok(AssetInfoRaw::NativeToken {\n                denom: denom.to_string(),\n            }),\n            AssetInfo::Token { contract_addr } =\u003e Ok(AssetInfoRaw::Token {\n                contract_addr: api.addr_canonicalize(contract_addr.as_str())?,\n            }),\n        }\n    }\n\n    pub fn is_native_token(\u0026self) -\u003e bool {\n        match self {\n            AssetInfo::NativeToken { .. } =\u003e true,\n            AssetInfo::Token { .. } =\u003e false,\n        }\n    }\n    pub fn query_pool(\n        \u0026self,\n        querier: \u0026QuerierWrapper,\n        api: \u0026dyn Api,\n        pool_addr: Addr,\n    ) -\u003e StdResult\u003cUint128\u003e {\n        match self {\n            AssetInfo::Token { contract_addr, .. } =\u003e query_token_balance(\n                querier,\n                api.addr_validate(contract_addr.as_str())?,\n                pool_addr,\n            ),\n            AssetInfo::NativeToken { denom, .. } =\u003e {\n                query_balance(querier, pool_addr, denom.to_string())\n            }\n        }\n    }\n\n    pub fn equal(\u0026self, asset: \u0026AssetInfo) -\u003e bool {\n        match self {\n            AssetInfo::Token { contract_addr, .. } =\u003e {\n                let self_contract_addr = contract_addr;\n                match asset {\n                    AssetInfo::Token { contract_addr, .. } =\u003e self_contract_addr == contract_addr,\n                    AssetInfo::NativeToken { .. } =\u003e false,\n                }\n            }\n            AssetInfo::NativeToken { denom, .. } =\u003e {\n                let self_denom = denom;\n                match asset {\n                    AssetInfo::Token { .. } =\u003e false,\n                    AssetInfo::NativeToken { denom, .. } =\u003e self_denom == denom,\n                }\n            }\n        }\n    }\n\n    pub fn query_decimals(\u0026self, account_addr: Addr, querier: \u0026QuerierWrapper) -\u003e StdResult\u003cu8\u003e {\n        match self {\n            AssetInfo::NativeToken { denom } =\u003e {\n                query_native_decimals(querier, account_addr, denom.to_string())\n            }\n            AssetInfo::Token { contract_addr } =\u003e {\n                let token_info = query_token_info(querier, Addr::unchecked(contract_addr))?;\n                Ok(token_info.decimals)\n            }\n        }\n    }\n}\n\n#[cw_serde]\npub struct AssetRaw {\n    pub info: AssetInfoRaw,\n    pub amount: Uint128,\n}\n\nimpl AssetRaw {\n    pub fn to_normal(\u0026self, api: \u0026dyn Api) -\u003e StdResult\u003cAsset\u003e {\n        Ok(Asset {\n            info: match \u0026self.info {\n                AssetInfoRaw::NativeToken { denom } =\u003e AssetInfo::NativeToken {\n                    denom: denom.to_string(),\n                },\n                AssetInfoRaw::Token { contract_addr } =\u003e AssetInfo::Token {\n                    contract_addr: api.addr_humanize(contract_addr)?.to_string(),\n                },\n            },\n            amount: self.amount,\n        })\n    }\n}\n\n#[cw_serde]\npub enum AssetInfoRaw {\n    Token { contract_addr: CanonicalAddr },\n    NativeToken { denom: String },\n}\n\nimpl AssetInfoRaw {\n    pub fn to_normal(\u0026self, api: \u0026dyn Api) -\u003e StdResult\u003cAssetInfo\u003e {\n        match self {\n            AssetInfoRaw::NativeToken { denom } =\u003e Ok(AssetInfo::NativeToken {\n                denom: denom.to_string(),\n            }),\n            AssetInfoRaw::Token { contract_addr } =\u003e Ok(AssetInfo::Token {\n                contract_addr: api.addr_humanize(contract_addr)?.to_string(),\n            }),\n        }\n    }\n\n    pub fn as_bytes(\u0026self) -\u003e \u0026[u8] {\n        match self {\n            AssetInfoRaw::NativeToken { denom } =\u003e denom.as_bytes(),\n            AssetInfoRaw::Token { contract_addr } =\u003e contract_addr.as_slice(),\n        }\n    }\n\n    pub fn equal(\u0026self, asset: \u0026AssetInfoRaw) -\u003e bool {\n        match self {\n            AssetInfoRaw::Token { contract_addr, .. } =\u003e {\n                let self_contract_addr = contract_addr;\n                match asset {\n                    AssetInfoRaw::Token { contract_addr, .. } =\u003e {\n                        self_contract_addr == contract_addr\n                    }\n                    AssetInfoRaw::NativeToken { .. } =\u003e false,\n                }\n            }\n            AssetInfoRaw::NativeToken { denom, .. } =\u003e {\n                let self_denom = denom;\n                match asset {\n                    AssetInfoRaw::Token { .. } =\u003e false,\n                    AssetInfoRaw::NativeToken { denom, .. } =\u003e self_denom == denom,\n                }\n            }\n        }\n    }\n}\n\n// We define a custom struct for each query response\n#[cw_serde]\npub struct PairInfo {\n    pub asset_infos: [AssetInfo; 2],\n    pub contract_addr: String,\n    pub liquidity_token: String,\n    pub asset_decimals: [u8; 2],\n    pub requirements: CreatePairRequirements,\n}\n\n#[cw_serde]\npub struct PairInfoRaw {\n    pub asset_infos: [AssetInfoRaw; 2],\n    pub contract_addr: CanonicalAddr,\n    pub liquidity_token: CanonicalAddr,\n    pub asset_decimals: [u8; 2],\n    pub requirements: CreatePairRequirements,\n}\n\nimpl PairInfoRaw {\n    pub fn to_normal(\u0026self, api: \u0026dyn Api) -\u003e StdResult\u003cPairInfo\u003e {\n        Ok(PairInfo {\n            liquidity_token: api.addr_humanize(\u0026self.liquidity_token)?.to_string(),\n            contract_addr: api.addr_humanize(\u0026self.contract_addr)?.to_string(),\n            asset_infos: [\n                self.asset_infos[0].to_normal(api)?,\n                self.asset_infos[1].to_normal(api)?,\n            ],\n            asset_decimals: self.asset_decimals,\n            requirements: self.requirements.clone(),\n        })\n    }\n\n    pub fn query_pools(\n        \u0026self,\n        querier: \u0026QuerierWrapper,\n        api: \u0026dyn Api,\n        contract_addr: Addr,\n    ) -\u003e StdResult\u003c[Asset; 2]\u003e {\n        let info_0: AssetInfo = self.asset_infos[0].to_normal(api)?;\n        let info_1: AssetInfo = self.asset_infos[1].to_normal(api)?;\n        Ok([\n            Asset {\n                amount: info_0.query_pool(querier, api, contract_addr.clone())?,\n                info: info_0,\n            },\n            Asset {\n                amount: info_1.query_pool(querier, api, contract_addr)?,\n                info: info_1,\n            },\n        ])\n    }\n}\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":64},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":64},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":34},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":39},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":39},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":38},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":273,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":274,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":275,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":278,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":279,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":281,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":282,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":286,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":292,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":293,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":296,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":297,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":299,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":300,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":16},"fn_name":null}],"covered":125,"coverable":126},{"path":["/","Users","haitran","AURA-NETWORK","smart-contracts-halotrade-zone","packages","haloswap","src","factory.rs"],"content":"use cosmwasm_schema::{cw_serde, QueryResponses};\n\nuse crate::asset::{AssetInfo, PairInfo, CreatePairRequirements};\n\n#[cw_serde]\npub struct InstantiateMsg {\n    /// Pair contract code ID, which is used to\n    pub pair_code_id: u64,\n    pub token_code_id: u64,\n}\n\n#[cw_serde]\npub enum ExecuteMsg {\n    /// UpdateConfig update relevant code IDs\n    UpdateConfig {\n        owner: Option\u003cString\u003e,\n        token_code_id: Option\u003cu64\u003e,\n        pair_code_id: Option\u003cu64\u003e,\n    },\n    /// CreatePair instantiates pair contract\n    CreatePair {\n        /// Asset infos\n        asset_infos: [AssetInfo; 2],\n        /// The requiments to create a pair\n        requirements: CreatePairRequirements,\n    },\n    AddNativeTokenDecimals {\n        denom: String,\n        decimals: u8,\n    },\n    MigratePair {\n        contract: String,\n        code_id: Option\u003cu64\u003e,\n    },\n}\n\n#[cw_serde]\n#[derive(QueryResponses)]\npub enum QueryMsg {\n    #[returns(ConfigResponse)]\n    Config {},\n    #[returns(PairInfo)]\n    Pair {\n        asset_infos: [AssetInfo; 2],\n    },\n    #[returns(PairsResponse)]\n    Pairs {\n        start_after: Option\u003c[AssetInfo; 2]\u003e,\n        limit: Option\u003cu32\u003e,\n    },\n    #[returns(NativeTokenDecimalsResponse)]\n    NativeTokenDecimals {\n        denom: String,\n    },\n}\n\n// We define a custom struct for each query response\n#[cw_serde]\npub struct ConfigResponse {\n    pub owner: String,\n    pub pair_code_id: u64,\n    pub token_code_id: u64,\n}\n\n/// We currently take no arguments for migrations\n#[cw_serde]\npub struct MigrateMsg {}\n\n// We define a custom struct for each query response\n#[cw_serde]\npub struct PairsResponse {\n    pub pairs: Vec\u003cPairInfo\u003e,\n}\n\n#[cw_serde]\npub struct NativeTokenDecimalsResponse {\n    pub decimals: u8,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","haitran","AURA-NETWORK","smart-contracts-halotrade-zone","packages","haloswap","src","lib.rs"],"content":"pub mod asset;\npub mod factory;\npub mod pair;\npub mod querier;\npub mod router;\npub mod token;\n\n#[cfg(not(target_arch = \"wasm32\"))]\npub mod mock_querier;\n\n#[cfg(test)]\nmod testing;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","haitran","AURA-NETWORK","smart-contracts-halotrade-zone","packages","haloswap","src","mock_querier.rs"],"content":"use cosmwasm_std::testing::{MockApi, MockQuerier, MockStorage, MOCK_CONTRACT_ADDR};\nuse cosmwasm_std::{\n    from_binary, from_slice, to_binary, Coin, ContractResult, Empty, OwnedDeps, Querier,\n    QuerierResult, QueryRequest, SystemError, SystemResult, Uint128, WasmQuery, Addr,\n};\nuse std::collections::HashMap;\nuse std::marker::PhantomData;\nuse std::panic;\n\nuse crate::asset::{AssetInfo, PairInfo, CreatePairRequirements};\nuse crate::factory::{NativeTokenDecimalsResponse, QueryMsg as FactoryQueryMsg};\nuse crate::pair::QueryMsg as PairQueryMsg;\nuse crate::pair::{ReverseSimulationResponse, SimulationResponse};\nuse cw20::{BalanceResponse as Cw20BalanceResponse, Cw20QueryMsg, TokenInfoResponse};\n\nuse std::iter::FromIterator;\n\n/// mock_dependencies is a drop-in replacement for cosmwasm_std::testing::mock_dependencies\n/// this uses our CustomQuerier.\npub fn mock_dependencies(\n    contract_balance: \u0026[Coin],\n) -\u003e OwnedDeps\u003cMockStorage, MockApi, WasmMockQuerier\u003e {\n    let custom_querier: WasmMockQuerier =\n        WasmMockQuerier::new(MockQuerier::new(\u0026[(MOCK_CONTRACT_ADDR, contract_balance)]));\n\n    OwnedDeps {\n        storage: MockStorage::default(),\n        api: MockApi::default(),\n        querier: custom_querier,\n        custom_query_type: PhantomData,\n    }\n}\n\npub struct WasmMockQuerier {\n    base: MockQuerier,\n    token_querier: TokenQuerier,\n    halo_factory_querier: HaloFactoryQuerier,\n}\n\n#[derive(Clone, Default)]\npub struct TokenQuerier {\n    // this lets us iterate over all pairs that match the first string\n    balances: HashMap\u003cString, HashMap\u003cString, Uint128\u003e\u003e,\n}\n\nimpl TokenQuerier {\n    pub fn new(balances: \u0026[(\u0026String, \u0026[(\u0026String, \u0026Uint128)])]) -\u003e Self {\n        TokenQuerier {\n            balances: balances_to_map(balances),\n        }\n    }\n}\n\npub(crate) fn balances_to_map(\n    balances: \u0026[(\u0026String, \u0026[(\u0026String, \u0026Uint128)])],\n) -\u003e HashMap\u003cString, HashMap\u003cString, Uint128\u003e\u003e {\n    let mut balances_map: HashMap\u003cString, HashMap\u003cString, Uint128\u003e\u003e = HashMap::new();\n    for (contract_addr, balances) in balances.iter() {\n        let mut contract_balances_map: HashMap\u003cString, Uint128\u003e = HashMap::new();\n        for (addr, balance) in balances.iter() {\n            contract_balances_map.insert(addr.to_string(), **balance);\n        }\n\n        balances_map.insert(contract_addr.to_string(), contract_balances_map);\n    }\n    balances_map\n}\n\n#[derive(Clone, Default)]\npub struct HaloFactoryQuerier {\n    pairs: HashMap\u003cString, PairInfo\u003e,\n    native_token_decimals: HashMap\u003cString, u8\u003e,\n}\n\nimpl HaloFactoryQuerier {\n    pub fn new(pairs: \u0026[(\u0026String, \u0026PairInfo)], native_token_decimals: \u0026[(String, u8)]) -\u003e Self {\n        HaloFactoryQuerier {\n            pairs: pairs_to_map(pairs),\n            native_token_decimals: native_token_decimals_to_map(native_token_decimals),\n        }\n    }\n}\n\npub(crate) fn pairs_to_map(pairs: \u0026[(\u0026String, \u0026PairInfo)]) -\u003e HashMap\u003cString, PairInfo\u003e {\n    let mut pairs_map: HashMap\u003cString, PairInfo\u003e = HashMap::new();\n    for (key, pair) in pairs.iter() {\n        let mut sort_key: Vec\u003cchar\u003e = key.chars().collect();\n        sort_key.sort_by(|a, b| b.cmp(a));\n        pairs_map.insert(String::from_iter(sort_key.iter()), (**pair).clone());\n    }\n    pairs_map\n}\n\npub(crate) fn native_token_decimals_to_map(\n    native_token_decimals: \u0026[(String, u8)],\n) -\u003e HashMap\u003cString, u8\u003e {\n    let mut native_token_decimals_map: HashMap\u003cString, u8\u003e = HashMap::new();\n\n    for (denom, decimals) in native_token_decimals.iter() {\n        native_token_decimals_map.insert(denom.to_string(), *decimals);\n    }\n    native_token_decimals_map\n}\n\nimpl Querier for WasmMockQuerier {\n    fn raw_query(\u0026self, bin_request: \u0026[u8]) -\u003e QuerierResult {\n        // MockQuerier doesn't support Custom, so we ignore it completely here\n        let request: QueryRequest\u003cEmpty\u003e = match from_slice(bin_request) {\n            Ok(v) =\u003e v,\n            Err(e) =\u003e {\n                return SystemResult::Err(SystemError::InvalidRequest {\n                    error: format!(\"Parsing query request: {}\", e),\n                    request: bin_request.into(),\n                })\n            }\n        };\n        self.handle_query(\u0026request)\n    }\n}\n\nimpl WasmMockQuerier {\n    pub fn handle_query(\u0026self, request: \u0026QueryRequest\u003cEmpty\u003e) -\u003e QuerierResult {\n        match \u0026request {\n            QueryRequest::Wasm(WasmQuery::Smart { contract_addr, msg }) =\u003e match from_binary(msg) {\n                Ok(FactoryQueryMsg::Pair { asset_infos }) =\u003e {\n                    let key = [asset_infos[0].to_string(), asset_infos[1].to_string()].join(\"\");\n                    let mut sort_key: Vec\u003cchar\u003e = key.chars().collect();\n                    sort_key.sort_by(|a, b| b.cmp(a));\n                    match self\n                        .halo_factory_querier\n                        .pairs\n                        .get(\u0026String::from_iter(sort_key.iter()))\n                    {\n                        Some(v) =\u003e SystemResult::Ok(ContractResult::Ok(to_binary(v).unwrap())),\n                        None =\u003e SystemResult::Err(SystemError::InvalidRequest {\n                            error: \"No pair info exists\".to_string(),\n                            request: msg.as_slice().into(),\n                        }),\n                    }\n                }\n                Ok(FactoryQueryMsg::NativeTokenDecimals { denom }) =\u003e {\n                    match self\n                        .halo_factory_querier\n                        .native_token_decimals\n                        .get(\u0026denom)\n                    {\n                        Some(decimals) =\u003e SystemResult::Ok(ContractResult::Ok(\n                            to_binary(\u0026NativeTokenDecimalsResponse {\n                                decimals: *decimals,\n                            })\n                            .unwrap(),\n                        )),\n                        None =\u003e SystemResult::Err(SystemError::InvalidRequest {\n                            error: \"No decimal info exist\".to_string(),\n                            request: msg.as_slice().into(),\n                        }),\n                    }\n                }\n                _ =\u003e match from_binary(msg) {\n                    Ok(PairQueryMsg::Pair {}) =\u003e {\n                        SystemResult::Ok(ContractResult::from(to_binary(\u0026PairInfo {\n                            asset_infos: [\n                                AssetInfo::NativeToken {\n                                    denom: \"uluna\".to_string(),\n                                },\n                                AssetInfo::NativeToken {\n                                    denom: \"uluna\".to_string(),\n                                },\n                            ],\n                            asset_decimals: [6u8, 6u8],\n                            contract_addr: \"pair0000\".to_string(),\n                            liquidity_token: \"liquidity0000\".to_string(),\n                            requirements: CreatePairRequirements {\n                                whitelist: vec![Addr::unchecked(\"deployer\")],\n                                first_asset_minimum: Uint128::zero(),\n                                second_asset_minimum: Uint128::zero(),\n                            },\n                        })))\n                    }\n                    Ok(PairQueryMsg::Simulation { offer_asset }) =\u003e {\n                        SystemResult::Ok(ContractResult::from(to_binary(\u0026SimulationResponse {\n                            return_amount: offer_asset.amount,\n                            commission_amount: Uint128::zero(),\n                            spread_amount: Uint128::zero(),\n                        })))\n                    }\n                    Ok(PairQueryMsg::ReverseSimulation { ask_asset }) =\u003e SystemResult::Ok(\n                        ContractResult::from(to_binary(\u0026ReverseSimulationResponse {\n                            offer_amount: ask_asset.amount,\n                            commission_amount: Uint128::zero(),\n                            spread_amount: Uint128::zero(),\n                        })),\n                    ),\n                    _ =\u003e match from_binary(msg).unwrap() {\n                        Cw20QueryMsg::TokenInfo {} =\u003e {\n                            let balances: \u0026HashMap\u003cString, Uint128\u003e =\n                                match self.token_querier.balances.get(contract_addr) {\n                                    Some(balances) =\u003e balances,\n                                    None =\u003e {\n                                        return SystemResult::Err(SystemError::InvalidRequest {\n                                            error: format!(\n                                                \"No balance info exists for the contract {}\",\n                                                contract_addr\n                                            ),\n                                            request: msg.as_slice().into(),\n                                        })\n                                    }\n                                };\n\n                            let mut total_supply = Uint128::zero();\n\n                            for balance in balances {\n                                total_supply += *balance.1;\n                            }\n\n                            SystemResult::Ok(ContractResult::Ok(\n                                to_binary(\u0026TokenInfoResponse {\n                                    name: \"mAAPL\".to_string(),\n                                    symbol: \"mAAPL\".to_string(),\n                                    decimals: 8,\n                                    total_supply,\n                                })\n                                .unwrap(),\n                            ))\n                        }\n                        Cw20QueryMsg::Balance { address } =\u003e {\n                            let balances: \u0026HashMap\u003cString, Uint128\u003e =\n                                match self.token_querier.balances.get(contract_addr) {\n                                    Some(balances) =\u003e balances,\n                                    None =\u003e {\n                                        return SystemResult::Err(SystemError::InvalidRequest {\n                                            error: format!(\n                                                \"No balance info exists for the contract {}\",\n                                                contract_addr\n                                            ),\n                                            request: msg.as_slice().into(),\n                                        })\n                                    }\n                                };\n\n                            let balance = match balances.get(\u0026address) {\n                                Some(v) =\u003e *v,\n                                None =\u003e {\n                                    return SystemResult::Ok(ContractResult::Ok(\n                                        to_binary(\u0026Cw20BalanceResponse {\n                                            balance: Uint128::zero(),\n                                        })\n                                        .unwrap(),\n                                    ));\n                                }\n                            };\n\n                            SystemResult::Ok(ContractResult::Ok(\n                                to_binary(\u0026Cw20BalanceResponse { balance }).unwrap(),\n                            ))\n                        }\n\n                        _ =\u003e panic!(\"DO NOT ENTER HERE\"),\n                    },\n                },\n            },\n            _ =\u003e self.base.handle_query(request),\n        }\n    }\n}\n\nimpl WasmMockQuerier {\n    pub fn new(base: MockQuerier) -\u003e Self {\n        WasmMockQuerier {\n            base,\n            token_querier: TokenQuerier::default(),\n            halo_factory_querier: HaloFactoryQuerier::default(),\n        }\n    }\n\n    // configure the mint whitelist mock querier\n    pub fn with_token_balances(\u0026mut self, balances: \u0026[(\u0026String, \u0026[(\u0026String, \u0026Uint128)])]) {\n        self.token_querier = TokenQuerier::new(balances);\n    }\n\n    // configure the halo pair\n    pub fn with_halo_factory(\n        \u0026mut self,\n        pairs: \u0026[(\u0026String, \u0026PairInfo)],\n        native_token_decimals: \u0026[(String, u8)],\n    ) {\n        self.halo_factory_querier = HaloFactoryQuerier::new(pairs, native_token_decimals);\n    }\n\n    pub fn with_balance(\u0026mut self, balances: \u0026[(\u0026String, Vec\u003cCoin\u003e)]) {\n        for (addr, balance) in balances {\n            self.base.update_balance(addr.to_string(), balance.clone());\n        }\n    }\n}\n\n#[cfg(test)]\nmod mock_exception {\n    use cosmwasm_std::Binary;\n\n    use super::*;\n\n    #[test]\n    fn raw_query_err() {\n        let deps = mock_dependencies(\u0026[]);\n        assert_eq!(\n            deps.querier.raw_query(\u0026[]),\n            SystemResult::Err(SystemError::InvalidRequest {\n                error: \"Parsing query request: Error parsing into type cosmwasm_std::query::QueryRequest\u003ccosmwasm_std::results::empty::Empty\u003e: EOF while parsing a JSON value.\".to_string(),\n                request: Binary(vec![])\n            })\n        );\n    }\n\n    #[test]\n    fn none_factory_pair_will_err() {\n        let deps = mock_dependencies(\u0026[]);\n\n        let msg = to_binary(\u0026FactoryQueryMsg::Pair {\n            asset_infos: [\n                AssetInfo::NativeToken {\n                    denom: \"uluna\".to_string(),\n                },\n                AssetInfo::NativeToken {\n                    denom: \"ulunc\".to_string(),\n                },\n            ],\n        })\n        .unwrap();\n        assert_eq!(\n            deps.querier\n                .handle_query(\u0026QueryRequest::Wasm(WasmQuery::Smart {\n                    contract_addr: \"contract0000\".to_string(),\n                    msg: msg.clone()\n                })),\n            SystemResult::Err(SystemError::InvalidRequest {\n                error: \"No pair info exists\".to_string(),\n                request: msg\n            })\n        )\n    }\n\n    #[test]\n    fn none_tokens_info_will_err() {\n        let deps = mock_dependencies(\u0026[]);\n\n        let msg = to_binary(\u0026Cw20QueryMsg::TokenInfo {}).unwrap();\n\n        assert_eq!(\n            deps.querier\n                .handle_query(\u0026QueryRequest::Wasm(WasmQuery::Smart {\n                    contract_addr: \"token0000\".to_string(),\n                    msg: msg.clone()\n                })),\n            SystemResult::Err(SystemError::InvalidRequest {\n                error: \"No balance info exists for the contract token0000\".to_string(),\n                request: msg\n            })\n        )\n    }\n\n    #[test]\n    fn none_tokens_balance_will_err() {\n        let deps = mock_dependencies(\u0026[]);\n\n        let msg = to_binary(\u0026Cw20QueryMsg::Balance {\n            address: \"address0000\".to_string(),\n        })\n        .unwrap();\n\n        assert_eq!(\n            deps.querier\n                .handle_query(\u0026QueryRequest::Wasm(WasmQuery::Smart {\n                    contract_addr: \"token0000\".to_string(),\n                    msg: msg.clone()\n                })),\n            SystemResult::Err(SystemError::InvalidRequest {\n                error: \"No balance info exists for the contract token0000\".to_string(),\n                request: msg\n            })\n        )\n    }\n\n    #[test]\n    #[should_panic]\n    fn none_tokens_minter_will_panic() {\n        let deps = mock_dependencies(\u0026[]);\n\n        let msg = to_binary(\u0026Cw20QueryMsg::Minter {}).unwrap();\n\n        deps.querier\n            .handle_query(\u0026QueryRequest::Wasm(WasmQuery::Smart {\n                contract_addr: \"token0000\".to_string(),\n                msg,\n            }));\n    }\n}\n","traces":[{"line":20,"address":[],"length":0,"stats":{"Line":47},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":47},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":47},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":47},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":47},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":31},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":31},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":31},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":31},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":71},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":40},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":138},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":49},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":40},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":31},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":373},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":81},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":161},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":80},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":80},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":84},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":56},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":56},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":408},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":39},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":34},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":41},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":44},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":258,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":28},"fn_name":null},{"line":268,"address":[],"length":0,"stats":{"Line":47},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":47},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":47},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":31},"fn_name":null},{"line":278,"address":[],"length":0,"stats":{"Line":31},"fn_name":null},{"line":282,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":287,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":290,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":291,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":292,"address":[],"length":0,"stats":{"Line":9},"fn_name":null}],"covered":136,"coverable":136},{"path":["/","Users","haitran","AURA-NETWORK","smart-contracts-halotrade-zone","packages","haloswap","src","pair.rs"],"content":"use cosmwasm_schema::{cw_serde, QueryResponses};\n\nuse crate::asset::{Asset, AssetInfo, PairInfo, CreatePairRequirements};\n\nuse cosmwasm_std::{Decimal, Uint128};\nuse cw20::Cw20ReceiveMsg;\n\n#[cw_serde]\npub struct InstantiateMsg {\n    /// Asset infos\n    pub asset_infos: [AssetInfo; 2],\n    /// Token contract code id for initialization\n    pub token_code_id: u64,\n    pub asset_decimals: [u8; 2],\n    /// The requiments to the first time provide liquidity\n    pub requirements: CreatePairRequirements,\n}\n\n#[cw_serde]\npub enum ExecuteMsg {\n    Receive(Cw20ReceiveMsg),\n    /// ProvideLiquidity a user provides pool liquidity\n    ProvideLiquidity {\n        assets: [Asset; 2],\n        slippage_tolerance: Option\u003cDecimal\u003e,\n        receiver: Option\u003cString\u003e,\n    },\n    /// Swap an offer asset to the other\n    Swap {\n        offer_asset: Asset,\n        belief_price: Option\u003cDecimal\u003e,\n        max_spread: Option\u003cDecimal\u003e,\n        to: Option\u003cString\u003e,\n    },\n}\n\n#[cw_serde]\n// #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n// #[serde(rename_all = \"snake_case\")]\npub enum Cw20HookMsg {\n    /// Sell a given amount of asset\n    Swap {\n        belief_price: Option\u003cDecimal\u003e,\n        max_spread: Option\u003cDecimal\u003e,\n        to: Option\u003cString\u003e,\n    },\n    WithdrawLiquidity {},\n}\n\n#[cw_serde]\n#[derive(QueryResponses)]\npub enum QueryMsg {\n    #[returns(PairInfo)]\n    Pair {},\n    #[returns(PoolResponse)]\n    Pool {},\n    #[returns(SimulationResponse)]\n    Simulation { offer_asset: Asset },\n    #[returns(ReverseSimulationResponse)]\n    ReverseSimulation { ask_asset: Asset },\n}\n\n// We define a custom struct for each query response\n#[cw_serde]\npub struct PoolResponse {\n    pub assets: [Asset; 2],\n    pub total_share: Uint128,\n}\n\n/// SimulationResponse returns swap simulation response\n#[cw_serde]\npub struct SimulationResponse {\n    pub return_amount: Uint128,\n    pub spread_amount: Uint128,\n    pub commission_amount: Uint128,\n}\n\n/// ReverseSimulationResponse returns reverse swap simulation response\n#[cw_serde]\npub struct ReverseSimulationResponse {\n    pub offer_amount: Uint128,\n    pub spread_amount: Uint128,\n    pub commission_amount: Uint128,\n}\n\n/// We currently take no arguments for migrations\n#[cw_serde]\npub struct MigrateMsg {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","haitran","AURA-NETWORK","smart-contracts-halotrade-zone","packages","haloswap","src","querier.rs"],"content":"use crate::asset::{Asset, AssetInfo, PairInfo};\nuse crate::factory::{NativeTokenDecimalsResponse, QueryMsg as FactoryQueryMsg};\nuse crate::pair::{QueryMsg as PairQueryMsg, ReverseSimulationResponse, SimulationResponse};\n\nuse cosmwasm_std::{\n    to_binary, Addr, AllBalanceResponse, BalanceResponse, BankQuery, Coin, QuerierWrapper,\n    QueryRequest, StdResult, Uint128, WasmQuery,\n};\n\nuse cw20::{BalanceResponse as Cw20BalanceResponse, Cw20QueryMsg, TokenInfoResponse};\n\npub fn query_balance(\n    querier: \u0026QuerierWrapper,\n    account_addr: Addr,\n    denom: String,\n) -\u003e StdResult\u003cUint128\u003e {\n    // load price form the oracle\n    let balance: BalanceResponse = querier.query(\u0026QueryRequest::Bank(BankQuery::Balance {\n        address: account_addr.to_string(),\n        denom,\n    }))?;\n    Ok(balance.amount.amount)\n}\n\npub fn query_all_balances(querier: \u0026QuerierWrapper, account_addr: Addr) -\u003e StdResult\u003cVec\u003cCoin\u003e\u003e {\n    // load price form the oracle\n    let all_balances: AllBalanceResponse =\n        querier.query(\u0026QueryRequest::Bank(BankQuery::AllBalances {\n            address: account_addr.to_string(),\n        }))?;\n    Ok(all_balances.amount)\n}\n\npub fn query_token_balance(\n    querier: \u0026QuerierWrapper,\n    contract_addr: Addr,\n    account_addr: Addr,\n) -\u003e StdResult\u003cUint128\u003e {\n    let res: Cw20BalanceResponse = querier.query(\u0026QueryRequest::Wasm(WasmQuery::Smart {\n        contract_addr: contract_addr.to_string(),\n        msg: to_binary(\u0026Cw20QueryMsg::Balance {\n            address: account_addr.to_string(),\n        })?,\n    }))?;\n\n    // load balance form the token contract\n    Ok(res.balance)\n}\n\npub fn query_token_info(\n    querier: \u0026QuerierWrapper,\n    contract_addr: Addr,\n) -\u003e StdResult\u003cTokenInfoResponse\u003e {\n    let token_info: TokenInfoResponse = querier.query(\u0026QueryRequest::Wasm(WasmQuery::Smart {\n        contract_addr: contract_addr.to_string(),\n        msg: to_binary(\u0026Cw20QueryMsg::TokenInfo {})?,\n    }))?;\n\n    Ok(token_info)\n}\n\npub fn query_native_decimals(\n    querier: \u0026QuerierWrapper,\n    factory_contract: Addr,\n    denom: String,\n) -\u003e StdResult\u003cu8\u003e {\n    let res: NativeTokenDecimalsResponse =\n        querier.query(\u0026QueryRequest::Wasm(WasmQuery::Smart {\n            contract_addr: factory_contract.to_string(),\n            msg: to_binary(\u0026FactoryQueryMsg::NativeTokenDecimals { denom })?,\n        }))?;\n    Ok(res.decimals)\n}\n\npub fn query_pair_info(\n    querier: \u0026QuerierWrapper,\n    factory_contract: Addr,\n    asset_infos: \u0026[AssetInfo; 2],\n) -\u003e StdResult\u003cPairInfo\u003e {\n    querier.query(\u0026QueryRequest::Wasm(WasmQuery::Smart {\n        contract_addr: factory_contract.to_string(),\n        msg: to_binary(\u0026FactoryQueryMsg::Pair {\n            asset_infos: asset_infos.clone(),\n        })?,\n    }))\n}\n\npub fn simulate(\n    querier: \u0026QuerierWrapper,\n    pair_contract: Addr,\n    offer_asset: \u0026Asset,\n) -\u003e StdResult\u003cSimulationResponse\u003e {\n    querier.query(\u0026QueryRequest::Wasm(WasmQuery::Smart {\n        contract_addr: pair_contract.to_string(),\n        msg: to_binary(\u0026PairQueryMsg::Simulation {\n            offer_asset: offer_asset.clone(),\n        })?,\n    }))\n}\n\npub fn reverse_simulate(\n    querier: \u0026QuerierWrapper,\n    pair_contract: Addr,\n    ask_asset: \u0026Asset,\n) -\u003e StdResult\u003cReverseSimulationResponse\u003e {\n    querier.query(\u0026QueryRequest::Wasm(WasmQuery::Smart {\n        contract_addr: pair_contract.to_string(),\n        msg: to_binary(\u0026PairQueryMsg::ReverseSimulation {\n            ask_asset: ask_asset.clone(),\n        })?,\n    }))\n}\n\npub fn query_pair_info_from_pair(\n    querier: \u0026QuerierWrapper,\n    pair_contract: Addr,\n) -\u003e StdResult\u003cPairInfo\u003e {\n    let pair_info: PairInfo = querier.query(\u0026QueryRequest::Wasm(WasmQuery::Smart {\n        contract_addr: pair_contract.to_string(),\n        msg: to_binary(\u0026PairQueryMsg::Pair {})?,\n    }))?;\n\n    Ok(pair_info)\n}\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":54},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":40,"coverable":40},{"path":["/","Users","haitran","AURA-NETWORK","smart-contracts-halotrade-zone","packages","haloswap","src","router.rs"],"content":"use cosmwasm_schema::{cw_serde, QueryResponses};\nuse cosmwasm_std::Uint128;\nuse cw20::Cw20ReceiveMsg;\n\nuse crate::asset::AssetInfo;\n\n#[cw_serde]\npub struct InstantiateMsg {\n    pub halo_factory: String,\n}\n\n#[cw_serde]\npub enum SwapOperation {\n    HaloSwap {\n        offer_asset_info: AssetInfo,\n        ask_asset_info: AssetInfo,\n    },\n}\n\nimpl SwapOperation {\n    pub fn get_target_asset_info(\u0026self) -\u003e AssetInfo {\n        match self {\n            SwapOperation::HaloSwap { ask_asset_info, .. } =\u003e ask_asset_info.clone(),\n        }\n    }\n}\n\n#[cw_serde]\npub enum ExecuteMsg {\n    Receive(Cw20ReceiveMsg),\n    /// Execute multiple BuyOperation\n    ExecuteSwapOperations {\n        operations: Vec\u003cSwapOperation\u003e,\n        minimum_receive: Option\u003cUint128\u003e,\n        to: Option\u003cString\u003e,\n    },\n\n    /// Internal use\n    /// Swap all offer tokens to ask token\n    ExecuteSwapOperation {\n        operation: SwapOperation,\n        to: Option\u003cString\u003e,\n    },\n    /// Internal use\n    /// Check the swap amount is exceed minimum_receive\n    AssertMinimumReceive {\n        asset_info: AssetInfo,\n        prev_balance: Uint128,\n        minimum_receive: Uint128,\n        receiver: String,\n    },\n}\n\n#[cw_serde]\npub enum Cw20HookMsg {\n    ExecuteSwapOperations {\n        operations: Vec\u003cSwapOperation\u003e,\n        minimum_receive: Option\u003cUint128\u003e,\n        to: Option\u003cString\u003e,\n    },\n}\n\n#[cw_serde]\n#[derive(QueryResponses)]\npub enum QueryMsg {\n    #[returns(ConfigResponse)]\n    Config {},\n    #[returns(SimulateSwapOperationsResponse)]\n    SimulateSwapOperations {\n        offer_amount: Uint128,\n        operations: Vec\u003cSwapOperation\u003e,\n    },\n    #[returns(SimulateSwapOperationsResponse)]\n    ReverseSimulateSwapOperations {\n        ask_amount: Uint128,\n        operations: Vec\u003cSwapOperation\u003e,\n    },\n}\n\n// We define a custom struct for each query response\n#[cw_serde]\npub struct ConfigResponse {\n    pub halo_factory: String,\n}\n\n// We define a custom struct for each query response\n#[cw_serde]\npub struct SimulateSwapOperationsResponse {\n    pub amount: Uint128,\n}\n\n/// We currently take no arguments for migrations\n#[cw_serde]\npub struct MigrateMsg {}\n","traces":[{"line":21,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":3},"fn_name":null}],"covered":3,"coverable":3},{"path":["/","Users","haitran","AURA-NETWORK","smart-contracts-halotrade-zone","packages","haloswap","src","testing.rs"],"content":"use crate::asset::{Asset, AssetInfo, AssetInfoRaw, AssetRaw, PairInfo, CreatePairRequirements};\nuse crate::mock_querier::mock_dependencies;\nuse crate::querier::{\n    query_all_balances, query_balance, query_pair_info, query_token_balance, query_token_info,\n};\n\nuse cosmwasm_std::testing::MOCK_CONTRACT_ADDR;\nuse cosmwasm_std::{\n    coin, to_binary, Addr, Api, BankMsg, Coin, CosmosMsg, MessageInfo, StdError, SubMsg, Uint128,\n    WasmMsg,\n};\nuse cw20::Cw20ExecuteMsg;\n\n#[test]\nfn token_balance_querier() {\n    let mut deps = mock_dependencies(\u0026[]);\n\n    deps.querier.with_token_balances(\u0026[(\n        \u0026\"liquidity0000\".to_string(),\n        \u0026[(\u0026MOCK_CONTRACT_ADDR.to_string(), \u0026Uint128::from(123u128))],\n    )]);\n\n    assert_eq!(\n        Uint128::from(123u128),\n        query_token_balance(\n            \u0026deps.as_ref().querier,\n            Addr::unchecked(\"liquidity0000\"),\n            Addr::unchecked(MOCK_CONTRACT_ADDR),\n        )\n        .unwrap()\n    );\n}\n\n#[test]\nfn balance_querier() {\n    let deps = mock_dependencies(\u0026[Coin {\n        denom: \"uusd\".to_string(),\n        amount: Uint128::from(200u128),\n    }]);\n\n    assert_eq!(\n        query_balance(\n            \u0026deps.as_ref().querier,\n            Addr::unchecked(MOCK_CONTRACT_ADDR),\n            \"uusd\".to_string()\n        )\n        .unwrap(),\n        Uint128::from(200u128)\n    );\n}\n\n#[test]\nfn all_balances_querier() {\n    let deps = mock_dependencies(\u0026[\n        Coin {\n            denom: \"uusd\".to_string(),\n            amount: Uint128::from(200u128),\n        },\n        Coin {\n            denom: \"ukrw\".to_string(),\n            amount: Uint128::from(300u128),\n        },\n    ]);\n\n    assert_eq!(\n        query_all_balances(\u0026deps.as_ref().querier, Addr::unchecked(MOCK_CONTRACT_ADDR),).unwrap(),\n        vec![\n            Coin {\n                denom: \"uusd\".to_string(),\n                amount: Uint128::from(200u128),\n            },\n            Coin {\n                denom: \"ukrw\".to_string(),\n                amount: Uint128::from(300u128),\n            }\n        ]\n    );\n}\n\n#[test]\nfn supply_querier() {\n    let mut deps = mock_dependencies(\u0026[]);\n\n    deps.querier.with_token_balances(\u0026[(\n        \u0026\"liquidity0000\".to_string(),\n        \u0026[\n            (\u0026MOCK_CONTRACT_ADDR.to_string(), \u0026Uint128::from(123u128)),\n            (\u0026\"addr00000\".to_string(), \u0026Uint128::from(123u128)),\n            (\u0026\"addr00001\".to_string(), \u0026Uint128::from(123u128)),\n            (\u0026\"addr00002\".to_string(), \u0026Uint128::from(123u128)),\n        ],\n    )]);\n\n    assert_eq!(\n        query_token_info(\u0026deps.as_ref().querier, Addr::unchecked(\"liquidity0000\"))\n            .unwrap()\n            .total_supply,\n        Uint128::from(492u128)\n    )\n}\n\n#[test]\nfn test_asset_info() {\n    let token_info: AssetInfo = AssetInfo::Token {\n        contract_addr: \"asset0000\".to_string(),\n    };\n    let native_token_info: AssetInfo = AssetInfo::NativeToken {\n        denom: \"uusd\".to_string(),\n    };\n\n    assert!(!token_info.equal(\u0026native_token_info));\n\n    assert!(!token_info.equal(\u0026AssetInfo::Token {\n        contract_addr: \"asset0001\".to_string(),\n    }));\n\n    assert!(token_info.equal(\u0026AssetInfo::Token {\n        contract_addr: \"asset0000\".to_string(),\n    }));\n\n    assert!(native_token_info.is_native_token());\n    assert!(!token_info.is_native_token());\n\n    let mut deps = mock_dependencies(\u0026[Coin {\n        denom: \"uusd\".to_string(),\n        amount: Uint128::from(123u128),\n    }]);\n    deps.querier.with_token_balances(\u0026[(\n        \u0026\"asset0000\".to_string(),\n        \u0026[\n            (\u0026MOCK_CONTRACT_ADDR.to_string(), \u0026Uint128::from(123u128)),\n            (\u0026\"addr00000\".to_string(), \u0026Uint128::from(123u128)),\n            (\u0026\"addr00001\".to_string(), \u0026Uint128::from(123u128)),\n            (\u0026\"addr00002\".to_string(), \u0026Uint128::from(123u128)),\n        ],\n    )]);\n\n    assert_eq!(\n        token_info\n            .query_pool(\n                \u0026deps.as_ref().querier,\n                deps.as_ref().api,\n                Addr::unchecked(MOCK_CONTRACT_ADDR)\n            )\n            .unwrap(),\n        Uint128::from(123u128)\n    );\n    assert_eq!(\n        native_token_info\n            .query_pool(\n                \u0026deps.as_ref().querier,\n                deps.as_ref().api,\n                Addr::unchecked(MOCK_CONTRACT_ADDR)\n            )\n            .unwrap(),\n        Uint128::from(123u128)\n    );\n}\n\n#[test]\nfn test_asset() {\n    let mut deps = mock_dependencies(\u0026[Coin {\n        denom: \"uusd\".to_string(),\n        amount: Uint128::from(123u128),\n    }]);\n\n    deps.querier.with_token_balances(\u0026[(\n        \u0026\"asset0000\".to_string(),\n        \u0026[\n            (\u0026MOCK_CONTRACT_ADDR.to_string(), \u0026Uint128::from(123u128)),\n            (\u0026\"addr00000\".to_string(), \u0026Uint128::from(123u128)),\n            (\u0026\"addr00001\".to_string(), \u0026Uint128::from(123u128)),\n            (\u0026\"addr00002\".to_string(), \u0026Uint128::from(123u128)),\n        ],\n    )]);\n\n    let token_asset = Asset {\n        amount: Uint128::from(123123u128),\n        info: AssetInfo::Token {\n            contract_addr: \"asset0000\".to_string(),\n        },\n    };\n\n    let native_token_asset = Asset {\n        amount: Uint128::from(123123u128),\n        info: AssetInfo::NativeToken {\n            denom: \"uusd\".to_string(),\n        },\n    };\n\n    assert_eq!(\n        token_asset\n            .clone()\n            .into_msg(Addr::unchecked(\"addr0000\"))\n            .unwrap(),\n        CosmosMsg::Wasm(WasmMsg::Execute {\n            contract_addr: \"asset0000\".to_string(),\n            msg: to_binary(\u0026Cw20ExecuteMsg::Transfer {\n                recipient: \"addr0000\".to_string(),\n                amount: Uint128::from(123123u128),\n            })\n            .unwrap(),\n            funds: vec![],\n        })\n    );\n\n    assert_eq!(\n        token_asset\n            .into_submsg(Addr::unchecked(\"addr0000\"))\n            .unwrap(),\n        SubMsg::new(CosmosMsg::Wasm(WasmMsg::Execute {\n            contract_addr: \"asset0000\".to_string(),\n            msg: to_binary(\u0026Cw20ExecuteMsg::Transfer {\n                recipient: \"addr0000\".to_string(),\n                amount: Uint128::from(123123u128),\n            })\n            .unwrap(),\n            funds: vec![],\n        }))\n    );\n\n    assert_eq!(\n        native_token_asset\n            .into_msg(Addr::unchecked(\"addr0000\"))\n            .unwrap(),\n        CosmosMsg::Bank(BankMsg::Send {\n            to_address: \"addr0000\".to_string(),\n            amount: vec![Coin {\n                denom: \"uusd\".to_string(),\n                amount: Uint128::from(123123u128),\n            }]\n        })\n    );\n}\n\n#[test]\nfn test_assert_sent_native_token_balance() {\n    // zero asset\n    let message_info = MessageInfo {\n        funds: vec![],\n        sender: Addr::unchecked(\"addr0000\"),\n    };\n\n    let zero_asset = Asset {\n        amount: Uint128::zero(),\n        info: AssetInfo::NativeToken {\n            denom: \"uluna\".to_string(),\n        },\n    };\n\n    assert_eq!(\n        zero_asset.assert_sent_native_token_balance(\u0026message_info),\n        Ok(())\n    );\n\n    // invalid message_info\n    let message_info = MessageInfo {\n        funds: vec![coin(123, \"uluna\")],\n        sender: Addr::unchecked(\"addr0000\"),\n    };\n\n    let invalid_amount_asset = Asset {\n        amount: Uint128::from(1u8),\n        info: AssetInfo::NativeToken {\n            denom: \"uluna\".to_string(),\n        },\n    };\n\n    assert_eq!(\n        invalid_amount_asset.assert_sent_native_token_balance(\u0026message_info),\n        Err(StdError::generic_err(\n            \"Native token balance mismatch between the argument and the transferred\"\n        ))\n    );\n\n    let invalid_amount_asset = Asset {\n        amount: Uint128::from(1u8),\n        info: AssetInfo::NativeToken {\n            denom: \"ulunc\".to_string(),\n        },\n    };\n\n    assert_eq!(\n        invalid_amount_asset.assert_sent_native_token_balance(\u0026message_info),\n        Err(StdError::generic_err(\n            \"Native token balance mismatch between the argument and the transferred\"\n        ))\n    )\n}\n\n#[test]\nfn test_asset_to_raw() {\n    let deps = mock_dependencies(\u0026[]);\n    let native_asset = Asset {\n        amount: Uint128::from(1u128),\n        info: AssetInfo::NativeToken {\n            denom: \"uluna\".to_string(),\n        },\n    };\n\n    let native_asset_to_raw = native_asset.to_raw(\u0026deps.api).unwrap();\n\n    assert_eq!(\n        native_asset_to_raw,\n        AssetRaw {\n            amount: Uint128::from(1u128),\n            info: AssetInfoRaw::NativeToken {\n                denom: \"uluna\".to_string()\n            }\n        }\n    );\n\n    assert_eq!(\n        native_asset_to_raw.to_normal(\u0026deps.api).unwrap(),\n        native_asset\n    );\n\n    let token_asset = Asset {\n        amount: Uint128::from(1u128),\n        info: AssetInfo::Token {\n            contract_addr: \"contract0000\".to_string(),\n        },\n    };\n\n    let token_asset_to_raw = token_asset.to_raw(\u0026deps.api).unwrap();\n\n    assert_eq!(\n        token_asset_to_raw,\n        AssetRaw {\n            amount: Uint128::from(1u128),\n            info: AssetInfoRaw::Token {\n                contract_addr: deps.api.addr_canonicalize(\"contract0000\").unwrap()\n            }\n        }\n    );\n\n    assert_eq!(\n        token_asset_to_raw.to_normal(\u0026deps.api).unwrap(),\n        token_asset\n    )\n}\n\n#[test]\nfn test_asset_info_raw_equal() {\n    let native_asset_info_raw = AssetInfoRaw::NativeToken {\n        denom: \"uluna\".to_string(),\n    };\n\n    assert!(native_asset_info_raw.equal(\u0026AssetInfoRaw::NativeToken {\n        denom: \"uluna\".to_string()\n    }));\n\n    assert!(!native_asset_info_raw.equal(\u0026AssetInfoRaw::NativeToken {\n        denom: \"ulunc\".to_string()\n    }));\n\n    let deps = mock_dependencies(\u0026[]);\n    assert!(!native_asset_info_raw.equal(\u0026AssetInfoRaw::Token {\n        contract_addr: deps.api.addr_canonicalize(\"contract0000\").unwrap()\n    }));\n\n    let token_asset_info_raw = AssetInfoRaw::Token {\n        contract_addr: deps.api.addr_canonicalize(\"contract0000\").unwrap(),\n    };\n    assert!(token_asset_info_raw.equal(\u0026AssetInfoRaw::Token {\n        contract_addr: deps.api.addr_canonicalize(\"contract0000\").unwrap()\n    }));\n\n    assert!(!token_asset_info_raw.equal(\u0026AssetInfoRaw::Token {\n        contract_addr: deps.api.addr_canonicalize(\"contract000\").unwrap()\n    }));\n\n    assert!(!token_asset_info_raw.equal(\u0026AssetInfoRaw::NativeToken {\n        denom: \"uluna\".to_string()\n    }));\n}\n\n#[test]\nfn query_halo_pair_contract() {\n    let mut deps = mock_dependencies(\u0026[]);\n\n    deps.querier.with_halo_factory(\n        \u0026[(\n            \u0026\"asset0000uusd\".to_string(),\n            \u0026PairInfo {\n                asset_infos: [\n                    AssetInfo::Token {\n                        contract_addr: \"asset0000\".to_string(),\n                    },\n                    AssetInfo::NativeToken {\n                        denom: \"uusd\".to_string(),\n                    },\n                ],\n                contract_addr: \"pair0000\".to_string(),\n                liquidity_token: \"liquidity0000\".to_string(),\n                asset_decimals: [6u8, 6u8],\n                requirements: CreatePairRequirements {\n                    whitelist: vec![Addr::unchecked(\"deployer\")],\n                    first_asset_minimum: Uint128::zero(),\n                    second_asset_minimum: Uint128::zero(),\n                },\n            },\n        )],\n        \u0026[(\"uusd\".to_string(), 6u8)],\n    );\n\n    let pair_info: PairInfo = query_pair_info(\n        \u0026deps.as_ref().querier,\n        Addr::unchecked(MOCK_CONTRACT_ADDR),\n        \u0026[\n            AssetInfo::Token {\n                contract_addr: \"asset0000\".to_string(),\n            },\n            AssetInfo::NativeToken {\n                denom: \"uusd\".to_string(),\n            },\n        ],\n    )\n    .unwrap();\n\n    assert_eq!(pair_info.contract_addr, Addr::unchecked(\"pair0000\"),);\n    assert_eq!(pair_info.liquidity_token, Addr::unchecked(\"liquidity0000\"),);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","haitran","AURA-NETWORK","smart-contracts-halotrade-zone","packages","haloswap","src","token.rs"],"content":"use cosmwasm_schema::cw_serde;\n\nuse cosmwasm_std::{StdError, StdResult, Uint128};\nuse cw20::{Cw20Coin, MinterResponse};\n\n/// TokenContract InstantiateMsg\n#[cw_serde]\npub struct InstantiateMsg {\n    pub name: String,\n    pub symbol: String,\n    pub decimals: u8,\n    pub initial_balances: Vec\u003cCw20Coin\u003e,\n    pub mint: Option\u003cMinterResponse\u003e,\n}\n\nimpl InstantiateMsg {\n    pub fn get_cap(\u0026self) -\u003e Option\u003cUint128\u003e {\n        self.mint.as_ref().and_then(|v| v.cap)\n    }\n\n    pub fn validate(\u0026self) -\u003e StdResult\u003c()\u003e {\n        // Check name, symbol, decimals\n        if !is_valid_name(\u0026self.name) {\n            return Err(StdError::generic_err(\n                \"Name is not in the expected format (3-50 UTF-8 bytes)\",\n            ));\n        }\n        if !is_valid_symbol(\u0026self.symbol) {\n            return Err(StdError::generic_err(\n                \"Ticker symbol is not in expected format [a-zA-Z\\\\-]{3,12}\",\n            ));\n        }\n        if self.decimals \u003e 18 {\n            return Err(StdError::generic_err(\"Decimals must not exceed 18\"));\n        }\n        Ok(())\n    }\n}\n\nfn is_valid_name(name: \u0026str) -\u003e bool {\n    let bytes = name.as_bytes();\n    if bytes.len() \u003c 3 || bytes.len() \u003e 50 {\n        return false;\n    }\n    true\n}\n\nfn is_valid_symbol(symbol: \u0026str) -\u003e bool {\n    let bytes = symbol.as_bytes();\n    if bytes.len() \u003c 3 || bytes.len() \u003e 12 {\n        return false;\n    }\n    for byte in bytes.iter() {\n        if (*byte != 45) \u0026\u0026 (*byte \u003c 65 || *byte \u003e 90) \u0026\u0026 (*byte \u003c 97 || *byte \u003e 122) {\n            return false;\n        }\n    }\n    true\n}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n\n    #[test]\n    fn get_cap() {\n        let msg = InstantiateMsg {\n            decimals: 6u8,\n            initial_balances: vec![],\n            mint: Some(MinterResponse {\n                cap: Some(Uint128::from(1u128)),\n                minter: \"minter0000\".to_string(),\n            }),\n            name: \"test_token\".to_string(),\n            symbol: \"TNT\".to_string(),\n        };\n\n        assert_eq!(msg.get_cap(), Some(Uint128::from(1u128)))\n    }\n\n    #[test]\n    fn validate() {\n        let valid_msg = InstantiateMsg {\n            decimals: 6u8,\n            initial_balances: vec![],\n            mint: Some(MinterResponse {\n                cap: Some(Uint128::from(1u128)),\n                minter: \"minter0000\".to_string(),\n            }),\n            name: \"test_token\".to_string(),\n            symbol: \"TNT\".to_string(),\n        };\n\n        assert_eq!(valid_msg.validate(), Ok(()));\n\n        let name_invalid_msg = InstantiateMsg {\n            decimals: 6u8,\n            initial_balances: vec![],\n            mint: Some(MinterResponse {\n                cap: Some(Uint128::from(1u128)),\n                minter: \"minter0000\".to_string(),\n            }),\n            name: \"a\".to_string(),\n            symbol: \"TNT\".to_string(),\n        };\n\n        assert_eq!(\n            name_invalid_msg.validate(),\n            Err(StdError::generic_err(\n                \"Name is not in the expected format (3-50 UTF-8 bytes)\",\n            ))\n        );\n\n        let symbol_invalid_msg = InstantiateMsg {\n            decimals: 6u8,\n            initial_balances: vec![],\n            mint: Some(MinterResponse {\n                cap: Some(Uint128::from(1u128)),\n                minter: \"minter0000\".to_string(),\n            }),\n            name: \"test_token\".to_string(),\n            symbol: \"TN\".to_string(),\n        };\n\n        assert_eq!(\n            symbol_invalid_msg.validate(),\n            Err(StdError::generic_err(\n                \"Ticker symbol is not in expected format [a-zA-Z\\\\-]{3,12}\",\n            ))\n        );\n\n        let decimal_invalid_msg = InstantiateMsg {\n            decimals: 20u8,\n            initial_balances: vec![],\n            mint: Some(MinterResponse {\n                cap: Some(Uint128::from(1u128)),\n                minter: \"minter0000\".to_string(),\n            }),\n            name: \"test_token\".to_string(),\n            symbol: \"TNT\".to_string(),\n        };\n\n        assert_eq!(\n            decimal_invalid_msg.validate(),\n            Err(StdError::generic_err(\"Decimals must not exceed 18\"))\n        );\n    }\n}\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":38},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":90},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":8},"fn_name":null}],"covered":25,"coverable":26}]};
    </script>
    <script crossorigin>/** @license React v16.13.1
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';(function(d,r){"object"===typeof exports&&"undefined"!==typeof module?r(exports):"function"===typeof define&&define.amd?define(["exports"],r):(d=d||self,r(d.React={}))})(this,function(d){function r(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function w(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function da(){}function L(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function ea(a,b,c){var g,e={},fa=null,d=null;if(null!=b)for(g in void 0!==b.ref&&(d=b.ref),void 0!==b.key&&(fa=""+b.key),b)ha.call(b,g)&&!ia.hasOwnProperty(g)&&(e[g]=b[g]);var h=arguments.length-2;if(1===h)e.children=c;else if(1<h){for(var k=Array(h),f=0;f<h;f++)k[f]=arguments[f+2];e.children=k}if(a&&a.defaultProps)for(g in h=a.defaultProps,
h)void 0===e[g]&&(e[g]=h[g]);return{$$typeof:x,type:a,key:fa,ref:d,props:e,_owner:M.current}}function va(a,b){return{$$typeof:x,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function N(a){return"object"===typeof a&&null!==a&&a.$$typeof===x}function wa(a){var b={"=":"=0",":":"=2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}function ja(a,b,c,g){if(C.length){var e=C.pop();e.result=a;e.keyPrefix=b;e.func=c;e.context=g;e.count=0;return e}return{result:a,keyPrefix:b,func:c,
context:g,count:0}}function ka(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>C.length&&C.push(a)}function O(a,b,c,g){var e=typeof a;if("undefined"===e||"boolean"===e)a=null;var d=!1;if(null===a)d=!0;else switch(e){case "string":case "number":d=!0;break;case "object":switch(a.$$typeof){case x:case xa:d=!0}}if(d)return c(g,a,""===b?"."+P(a,0):b),1;d=0;b=""===b?".":b+":";if(Array.isArray(a))for(var f=0;f<a.length;f++){e=a[f];var h=b+P(e,f);d+=O(e,h,c,g)}else if(null===a||
"object"!==typeof a?h=null:(h=la&&a[la]||a["@@iterator"],h="function"===typeof h?h:null),"function"===typeof h)for(a=h.call(a),f=0;!(e=a.next()).done;)e=e.value,h=b+P(e,f++),d+=O(e,h,c,g);else if("object"===e)throw c=""+a,Error(r(31,"[object Object]"===c?"object with keys {"+Object.keys(a).join(", ")+"}":c,""));return d}function Q(a,b,c){return null==a?0:O(a,"",b,c)}function P(a,b){return"object"===typeof a&&null!==a&&null!=a.key?wa(a.key):b.toString(36)}function ya(a,b,c){a.func.call(a.context,b,
a.count++)}function za(a,b,c){var g=a.result,e=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?R(a,g,c,function(a){return a}):null!=a&&(N(a)&&(a=va(a,e+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(ma,"$&/")+"/")+c)),g.push(a))}function R(a,b,c,g,e){var d="";null!=c&&(d=(""+c).replace(ma,"$&/")+"/");b=ja(b,d,g,e);Q(a,za,b);ka(b)}function t(){var a=na.current;if(null===a)throw Error(r(321));return a}function S(a,b){var c=a.length;a.push(b);a:for(;;){var g=c-1>>>1,e=a[g];if(void 0!==
e&&0<D(e,b))a[g]=b,a[c]=e,c=g;else break a}}function n(a){a=a[0];return void 0===a?null:a}function E(a){var b=a[0];if(void 0!==b){var c=a.pop();if(c!==b){a[0]=c;a:for(var g=0,e=a.length;g<e;){var d=2*(g+1)-1,f=a[d],h=d+1,k=a[h];if(void 0!==f&&0>D(f,c))void 0!==k&&0>D(k,f)?(a[g]=k,a[h]=c,g=h):(a[g]=f,a[d]=c,g=d);else if(void 0!==k&&0>D(k,c))a[g]=k,a[h]=c,g=h;else break a}}return b}return null}function D(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}function F(a){for(var b=n(u);null!==
b;){if(null===b.callback)E(u);else if(b.startTime<=a)E(u),b.sortIndex=b.expirationTime,S(p,b);else break;b=n(u)}}function T(a){y=!1;F(a);if(!v)if(null!==n(p))v=!0,z(U);else{var b=n(u);null!==b&&G(T,b.startTime-a)}}function U(a,b){v=!1;y&&(y=!1,V());H=!0;var c=m;try{F(b);for(l=n(p);null!==l&&(!(l.expirationTime>b)||a&&!W());){var g=l.callback;if(null!==g){l.callback=null;m=l.priorityLevel;var e=g(l.expirationTime<=b);b=q();"function"===typeof e?l.callback=e:l===n(p)&&E(p);F(b)}else E(p);l=n(p)}if(null!==
l)var d=!0;else{var f=n(u);null!==f&&G(T,f.startTime-b);d=!1}return d}finally{l=null,m=c,H=!1}}function oa(a){switch(a){case 1:return-1;case 2:return 250;case 5:return 1073741823;case 4:return 1E4;default:return 5E3}}var f="function"===typeof Symbol&&Symbol.for,x=f?Symbol.for("react.element"):60103,xa=f?Symbol.for("react.portal"):60106,Aa=f?Symbol.for("react.fragment"):60107,Ba=f?Symbol.for("react.strict_mode"):60108,Ca=f?Symbol.for("react.profiler"):60114,Da=f?Symbol.for("react.provider"):60109,
Ea=f?Symbol.for("react.context"):60110,Fa=f?Symbol.for("react.forward_ref"):60112,Ga=f?Symbol.for("react.suspense"):60113,Ha=f?Symbol.for("react.memo"):60115,Ia=f?Symbol.for("react.lazy"):60116,la="function"===typeof Symbol&&Symbol.iterator,pa=Object.getOwnPropertySymbols,Ja=Object.prototype.hasOwnProperty,Ka=Object.prototype.propertyIsEnumerable,I=function(){try{if(!Object.assign)return!1;var a=new String("abc");a[5]="de";if("5"===Object.getOwnPropertyNames(a)[0])return!1;var b={};for(a=0;10>a;a++)b["_"+
String.fromCharCode(a)]=a;if("0123456789"!==Object.getOwnPropertyNames(b).map(function(a){return b[a]}).join(""))return!1;var c={};"abcdefghijklmnopqrst".split("").forEach(function(a){c[a]=a});return"abcdefghijklmnopqrst"!==Object.keys(Object.assign({},c)).join("")?!1:!0}catch(g){return!1}}()?Object.assign:function(a,b){if(null===a||void 0===a)throw new TypeError("Object.assign cannot be called with null or undefined");var c=Object(a);for(var g,e=1;e<arguments.length;e++){var d=Object(arguments[e]);
for(var f in d)Ja.call(d,f)&&(c[f]=d[f]);if(pa){g=pa(d);for(var h=0;h<g.length;h++)Ka.call(d,g[h])&&(c[g[h]]=d[g[h]])}}return c},ca={isMounted:function(a){return!1},enqueueForceUpdate:function(a,b,c){},enqueueReplaceState:function(a,b,c,d){},enqueueSetState:function(a,b,c,d){}},ba={};w.prototype.isReactComponent={};w.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error(r(85));this.updater.enqueueSetState(this,a,b,"setState")};w.prototype.forceUpdate=
function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};da.prototype=w.prototype;f=L.prototype=new da;f.constructor=L;I(f,w.prototype);f.isPureReactComponent=!0;var M={current:null},ha=Object.prototype.hasOwnProperty,ia={key:!0,ref:!0,__self:!0,__source:!0},ma=/\/+/g,C=[],na={current:null},X;if("undefined"===typeof window||"function"!==typeof MessageChannel){var A=null,qa=null,ra=function(){if(null!==A)try{var a=q();A(!0,a);A=null}catch(b){throw setTimeout(ra,0),b;}},La=Date.now();var q=
function(){return Date.now()-La};var z=function(a){null!==A?setTimeout(z,0,a):(A=a,setTimeout(ra,0))};var G=function(a,b){qa=setTimeout(a,b)};var V=function(){clearTimeout(qa)};var W=function(){return!1};f=X=function(){}}else{var Y=window.performance,sa=window.Date,Ma=window.setTimeout,Na=window.clearTimeout;"undefined"!==typeof console&&(f=window.cancelAnimationFrame,"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"),
"function"!==typeof f&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"));if("object"===typeof Y&&"function"===typeof Y.now)q=function(){return Y.now()};else{var Oa=sa.now();q=function(){return sa.now()-Oa}}var J=!1,K=null,Z=-1,ta=5,ua=0;W=function(){return q()>=ua};f=function(){};X=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported"):
ta=0<a?Math.floor(1E3/a):5};var B=new MessageChannel,aa=B.port2;B.port1.onmessage=function(){if(null!==K){var a=q();ua=a+ta;try{K(!0,a)?aa.postMessage(null):(J=!1,K=null)}catch(b){throw aa.postMessage(null),b;}}else J=!1};z=function(a){K=a;J||(J=!0,aa.postMessage(null))};G=function(a,b){Z=Ma(function(){a(q())},b)};V=function(){Na(Z);Z=-1}}var p=[],u=[],Pa=1,l=null,m=3,H=!1,v=!1,y=!1,Qa=0;B={ReactCurrentDispatcher:na,ReactCurrentOwner:M,IsSomeRendererActing:{current:!1},assign:I};I(B,{Scheduler:{__proto__:null,
unstable_ImmediatePriority:1,unstable_UserBlockingPriority:2,unstable_NormalPriority:3,unstable_IdlePriority:5,unstable_LowPriority:4,unstable_runWithPriority:function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=m;m=a;try{return b()}finally{m=c}},unstable_next:function(a){switch(m){case 1:case 2:case 3:var b=3;break;default:b=m}var c=m;m=b;try{return a()}finally{m=c}},unstable_scheduleCallback:function(a,b,c){var d=q();if("object"===typeof c&&null!==c){var e=c.delay;
e="number"===typeof e&&0<e?d+e:d;c="number"===typeof c.timeout?c.timeout:oa(a)}else c=oa(a),e=d;c=e+c;a={id:Pa++,callback:b,priorityLevel:a,startTime:e,expirationTime:c,sortIndex:-1};e>d?(a.sortIndex=e,S(u,a),null===n(p)&&a===n(u)&&(y?V():y=!0,G(T,e-d))):(a.sortIndex=c,S(p,a),v||H||(v=!0,z(U)));return a},unstable_cancelCallback:function(a){a.callback=null},unstable_wrapCallback:function(a){var b=m;return function(){var c=m;m=b;try{return a.apply(this,arguments)}finally{m=c}}},unstable_getCurrentPriorityLevel:function(){return m},
unstable_shouldYield:function(){var a=q();F(a);var b=n(p);return b!==l&&null!==l&&null!==b&&null!==b.callback&&b.startTime<=a&&b.expirationTime<l.expirationTime||W()},unstable_requestPaint:f,unstable_continueExecution:function(){v||H||(v=!0,z(U))},unstable_pauseExecution:function(){},unstable_getFirstCallbackNode:function(){return n(p)},get unstable_now(){return q},get unstable_forceFrameRate(){return X},unstable_Profiling:null},SchedulerTracing:{__proto__:null,__interactionsRef:null,__subscriberRef:null,
unstable_clear:function(a){return a()},unstable_getCurrent:function(){return null},unstable_getThreadID:function(){return++Qa},unstable_trace:function(a,b,c){return c()},unstable_wrap:function(a){return a},unstable_subscribe:function(a){},unstable_unsubscribe:function(a){}}});d.Children={map:function(a,b,c){if(null==a)return a;var d=[];R(a,d,null,b,c);return d},forEach:function(a,b,c){if(null==a)return a;b=ja(null,null,b,c);Q(a,ya,b);ka(b)},count:function(a){return Q(a,function(){return null},null)},
toArray:function(a){var b=[];R(a,b,null,function(a){return a});return b},only:function(a){if(!N(a))throw Error(r(143));return a}};d.Component=w;d.Fragment=Aa;d.Profiler=Ca;d.PureComponent=L;d.StrictMode=Ba;d.Suspense=Ga;d.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=B;d.cloneElement=function(a,b,c){if(null===a||void 0===a)throw Error(r(267,a));var d=I({},a.props),e=a.key,f=a.ref,m=a._owner;if(null!=b){void 0!==b.ref&&(f=b.ref,m=M.current);void 0!==b.key&&(e=""+b.key);if(a.type&&a.type.defaultProps)var h=
a.type.defaultProps;for(k in b)ha.call(b,k)&&!ia.hasOwnProperty(k)&&(d[k]=void 0===b[k]&&void 0!==h?h[k]:b[k])}var k=arguments.length-2;if(1===k)d.children=c;else if(1<k){h=Array(k);for(var l=0;l<k;l++)h[l]=arguments[l+2];d.children=h}return{$$typeof:x,type:a.type,key:e,ref:f,props:d,_owner:m}};d.createContext=function(a,b){void 0===b&&(b=null);a={$$typeof:Ea,_calculateChangedBits:b,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:Da,_context:a};return a.Consumer=
a};d.createElement=ea;d.createFactory=function(a){var b=ea.bind(null,a);b.type=a;return b};d.createRef=function(){return{current:null}};d.forwardRef=function(a){return{$$typeof:Fa,render:a}};d.isValidElement=N;d.lazy=function(a){return{$$typeof:Ia,_ctor:a,_status:-1,_result:null}};d.memo=function(a,b){return{$$typeof:Ha,type:a,compare:void 0===b?null:b}};d.useCallback=function(a,b){return t().useCallback(a,b)};d.useContext=function(a,b){return t().useContext(a,b)};d.useDebugValue=function(a,b){};
d.useEffect=function(a,b){return t().useEffect(a,b)};d.useImperativeHandle=function(a,b,c){return t().useImperativeHandle(a,b,c)};d.useLayoutEffect=function(a,b){return t().useLayoutEffect(a,b)};d.useMemo=function(a,b){return t().useMemo(a,b)};d.useReducer=function(a,b,c){return t().useReducer(a,b,c)};d.useRef=function(a){return t().useRef(a)};d.useState=function(a){return t().useState(a)};d.version="16.13.1"});
</script>
    <script crossorigin>/** @license React v16.13.1
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/
'use strict';(function(I,ea){"object"===typeof exports&&"undefined"!==typeof module?ea(exports,require("react")):"function"===typeof define&&define.amd?define(["exports","react"],ea):(I=I||self,ea(I.ReactDOM={},I.React))})(this,function(I,ea){function k(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function ji(a,b,c,d,e,f,g,h,m){yb=!1;gc=null;ki.apply(li,arguments)}function mi(a,b,c,d,e,f,g,h,m){ji.apply(this,arguments);if(yb){if(yb){var n=gc;yb=!1;gc=null}else throw Error(k(198));hc||(hc=!0,pd=n)}}function lf(a,b,c){var d=a.type||"unknown-event";a.currentTarget=mf(c);mi(d,b,void 0,a);a.currentTarget=null}function nf(){if(ic)for(var a in cb){var b=cb[a],c=ic.indexOf(a);if(!(-1<c))throw Error(k(96,a));if(!jc[c]){if(!b.extractEvents)throw Error(k(97,a));jc[c]=b;c=b.eventTypes;for(var d in c){var e=
void 0;var f=c[d],g=b,h=d;if(qd.hasOwnProperty(h))throw Error(k(99,h));qd[h]=f;var m=f.phasedRegistrationNames;if(m){for(e in m)m.hasOwnProperty(e)&&of(m[e],g,h);e=!0}else f.registrationName?(of(f.registrationName,g,h),e=!0):e=!1;if(!e)throw Error(k(98,d,a));}}}}function of(a,b,c){if(db[a])throw Error(k(100,a));db[a]=b;rd[a]=b.eventTypes[c].dependencies}function pf(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];if(!cb.hasOwnProperty(c)||cb[c]!==d){if(cb[c])throw Error(k(102,c));cb[c]=
d;b=!0}}b&&nf()}function qf(a){if(a=rf(a)){if("function"!==typeof sd)throw Error(k(280));var b=a.stateNode;b&&(b=td(b),sd(a.stateNode,a.type,b))}}function sf(a){eb?fb?fb.push(a):fb=[a]:eb=a}function tf(){if(eb){var a=eb,b=fb;fb=eb=null;qf(a);if(b)for(a=0;a<b.length;a++)qf(b[a])}}function ud(){if(null!==eb||null!==fb)vd(),tf()}function uf(a,b,c){if(wd)return a(b,c);wd=!0;try{return vf(a,b,c)}finally{wd=!1,ud()}}function ni(a){if(wf.call(xf,a))return!0;if(wf.call(yf,a))return!1;if(oi.test(a))return xf[a]=
!0;yf[a]=!0;return!1}function pi(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}function qi(a,b,c,d){if(null===b||"undefined"===typeof b||pi(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function L(a,
b,c,d,e,f){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f}function xd(a,b,c,d){var e=E.hasOwnProperty(b)?E[b]:null;var f=null!==e?0===e.type:d?!1:!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1]?!1:!0;f||(qi(b,c,e,d)&&(c=null),d||null===e?ni(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,
d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c))))}function zb(a){if(null===a||"object"!==typeof a)return null;a=zf&&a[zf]||a["@@iterator"];return"function"===typeof a?a:null}function ri(a){if(-1===a._status){a._status=0;var b=a._ctor;b=b();a._result=b;b.then(function(b){0===a._status&&(b=b.default,a._status=1,a._result=b)},function(b){0===a._status&&(a._status=2,a._result=b)})}}function na(a){if(null==a)return null;
if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case Ma:return"Fragment";case gb:return"Portal";case kc:return"Profiler";case Af:return"StrictMode";case lc:return"Suspense";case yd:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case Bf:return"Context.Consumer";case Cf:return"Context.Provider";case zd:var b=a.render;b=b.displayName||b.name||"";return a.displayName||(""!==b?"ForwardRef("+b+")":"ForwardRef");case Ad:return na(a.type);
case Df:return na(a.render);case Ef:if(a=1===a._status?a._result:null)return na(a)}return null}function Bd(a){var b="";do{a:switch(a.tag){case 3:case 4:case 6:case 7:case 10:case 9:var c="";break a;default:var d=a._debugOwner,e=a._debugSource,f=na(a.type);c=null;d&&(c=na(d.type));d=f;f="";e?f=" (at "+e.fileName.replace(si,"")+":"+e.lineNumber+")":c&&(f=" (created by "+c+")");c="\n    in "+(d||"Unknown")+f}b+=c;a=a.return}while(a);return b}function va(a){switch(typeof a){case "boolean":case "number":case "object":case "string":case "undefined":return a;
default:return""}}function Ff(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}function ti(a){var b=Ff(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a)}});Object.defineProperty(a,
b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=null;delete a[b]}}}}function mc(a){a._valueTracker||(a._valueTracker=ti(a))}function Gf(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=Ff(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Cd(a,b){var c=b.checked;return M({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=
c?c:a._wrapperState.initialChecked})}function Hf(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=va(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function If(a,b){b=b.checked;null!=b&&xd(a,"checked",b,!1)}function Dd(a,b){If(a,b);var c=va(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c}else a.value!==
""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?Ed(a,b.type,c):b.hasOwnProperty("defaultValue")&&Ed(a,b.type,va(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}function Jf(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=
b);a.defaultValue=b}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c)}function Ed(a,b,c){if("number"!==b||a.ownerDocument.activeElement!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}function ui(a){var b="";ea.Children.forEach(a,function(a){null!=a&&(b+=a)});return b}function Fd(a,b){a=M({children:void 0},b);if(b=ui(b.children))a.children=b;return a}function hb(a,b,c,d){a=a.options;if(b){b={};
for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+va(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}function Gd(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(k(91));return M({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}
function Kf(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(k(92));if(Array.isArray(c)){if(!(1>=c.length))throw Error(k(93));c=c[0]}b=c}null==b&&(b="");c=b}a._wrapperState={initialValue:va(c)}}function Lf(a,b){var c=va(b.value),d=va(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d)}function Mf(a,b){b=a.textContent;b===a._wrapperState.initialValue&&""!==
b&&null!==b&&(a.value=b)}function Nf(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Hd(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?Nf(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}function nc(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}function oc(a){if(Id[a])return Id[a];
if(!ib[a])return a;var b=ib[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Of)return Id[a]=b[c];return a}function Jd(a){var b=Pf.get(a);void 0===b&&(b=new Map,Pf.set(a,b));return b}function Na(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.effectTag&1026)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function Qf(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function Rf(a){if(Na(a)!==
a)throw Error(k(188));}function vi(a){var b=a.alternate;if(!b){b=Na(a);if(null===b)throw Error(k(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return Rf(e),a;if(f===d)return Rf(e),b;f=f.sibling}throw Error(k(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=
f.child;h;){if(h===c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(k(189));}}if(c.alternate!==d)throw Error(k(190));}if(3!==c.tag)throw Error(k(188));return c.stateNode.current===c?a:b}function Sf(a){a=vi(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child.return=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}}return null}function jb(a,b){if(null==
b)throw Error(k(30));if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}function Kd(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a)}function pc(a){null!==a&&(Ab=jb(Ab,a));a=Ab;Ab=null;if(a){Kd(a,wi);if(Ab)throw Error(k(95));if(hc)throw a=pd,hc=!1,pd=null,a;}}function Ld(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:
a}function Tf(a){if(!wa)return!1;a="on"+a;var b=a in document;b||(b=document.createElement("div"),b.setAttribute(a,"return;"),b="function"===typeof b[a]);return b}function Uf(a){a.topLevelType=null;a.nativeEvent=null;a.targetInst=null;a.ancestors.length=0;10>qc.length&&qc.push(a)}function Vf(a,b,c,d){if(qc.length){var e=qc.pop();e.topLevelType=a;e.eventSystemFlags=d;e.nativeEvent=b;e.targetInst=c;return e}return{topLevelType:a,eventSystemFlags:d,nativeEvent:b,targetInst:c,ancestors:[]}}function Wf(a){var b=
a.targetInst,c=b;do{if(!c){a.ancestors.push(c);break}var d=c;if(3===d.tag)d=d.stateNode.containerInfo;else{for(;d.return;)d=d.return;d=3!==d.tag?null:d.stateNode.containerInfo}if(!d)break;b=c.tag;5!==b&&6!==b||a.ancestors.push(c);c=Bb(d)}while(c);for(c=0;c<a.ancestors.length;c++){b=a.ancestors[c];var e=Ld(a.nativeEvent);d=a.topLevelType;var f=a.nativeEvent,g=a.eventSystemFlags;0===c&&(g|=64);for(var h=null,m=0;m<jc.length;m++){var n=jc[m];n&&(n=n.extractEvents(d,b,f,e,g))&&(h=jb(h,n))}pc(h)}}function Md(a,
b,c){if(!c.has(a)){switch(a){case "scroll":Cb(b,"scroll",!0);break;case "focus":case "blur":Cb(b,"focus",!0);Cb(b,"blur",!0);c.set("blur",null);c.set("focus",null);break;case "cancel":case "close":Tf(a)&&Cb(b,a,!0);break;case "invalid":case "submit":case "reset":break;default:-1===Db.indexOf(a)&&w(a,b)}c.set(a,null)}}function xi(a,b){var c=Jd(b);Nd.forEach(function(a){Md(a,b,c)});yi.forEach(function(a){Md(a,b,c)})}function Od(a,b,c,d,e){return{blockedOn:a,topLevelType:b,eventSystemFlags:c|32,nativeEvent:e,
container:d}}function Xf(a,b){switch(a){case "focus":case "blur":xa=null;break;case "dragenter":case "dragleave":ya=null;break;case "mouseover":case "mouseout":za=null;break;case "pointerover":case "pointerout":Eb.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":Fb.delete(b.pointerId)}}function Gb(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a=Od(b,c,d,e,f),null!==b&&(b=Hb(b),null!==b&&Yf(b)),a;a.eventSystemFlags|=d;return a}function zi(a,b,c,d,e){switch(b){case "focus":return xa=
Gb(xa,a,b,c,d,e),!0;case "dragenter":return ya=Gb(ya,a,b,c,d,e),!0;case "mouseover":return za=Gb(za,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;Eb.set(f,Gb(Eb.get(f)||null,a,b,c,d,e));return!0;case "gotpointercapture":return f=e.pointerId,Fb.set(f,Gb(Fb.get(f)||null,a,b,c,d,e)),!0}return!1}function Ai(a){var b=Bb(a.target);if(null!==b){var c=Na(b);if(null!==c)if(b=c.tag,13===b){if(b=Qf(c),null!==b){a.blockedOn=b;Pd(a.priority,function(){Bi(c)});return}}else if(3===b&&c.stateNode.hydrate){a.blockedOn=
3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}function rc(a){if(null!==a.blockedOn)return!1;var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);if(null!==b){var c=Hb(b);null!==c&&Yf(c);a.blockedOn=b;return!1}return!0}function Zf(a,b,c){rc(a)&&c.delete(b)}function Ci(){for(Rd=!1;0<fa.length;){var a=fa[0];if(null!==a.blockedOn){a=Hb(a.blockedOn);null!==a&&Di(a);break}var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);null!==b?a.blockedOn=b:fa.shift()}null!==
xa&&rc(xa)&&(xa=null);null!==ya&&rc(ya)&&(ya=null);null!==za&&rc(za)&&(za=null);Eb.forEach(Zf);Fb.forEach(Zf)}function Ib(a,b){a.blockedOn===b&&(a.blockedOn=null,Rd||(Rd=!0,$f(ag,Ci)))}function bg(a){if(0<fa.length){Ib(fa[0],a);for(var b=1;b<fa.length;b++){var c=fa[b];c.blockedOn===a&&(c.blockedOn=null)}}null!==xa&&Ib(xa,a);null!==ya&&Ib(ya,a);null!==za&&Ib(za,a);b=function(b){return Ib(b,a)};Eb.forEach(b);Fb.forEach(b);for(b=0;b<Jb.length;b++)c=Jb[b],c.blockedOn===a&&(c.blockedOn=null);for(;0<Jb.length&&
(b=Jb[0],null===b.blockedOn);)Ai(b),null===b.blockedOn&&Jb.shift()}function Sd(a,b){for(var c=0;c<a.length;c+=2){var d=a[c],e=a[c+1],f="on"+(e[0].toUpperCase()+e.slice(1));f={phasedRegistrationNames:{bubbled:f,captured:f+"Capture"},dependencies:[d],eventPriority:b};Td.set(d,b);cg.set(d,f);dg[e]=f}}function w(a,b){Cb(b,a,!1)}function Cb(a,b,c){var d=Td.get(b);switch(void 0===d?2:d){case 0:d=Ei.bind(null,b,1,a);break;case 1:d=Fi.bind(null,b,1,a);break;default:d=sc.bind(null,b,1,a)}c?a.addEventListener(b,
d,!0):a.addEventListener(b,d,!1)}function Ei(a,b,c,d){Oa||vd();var e=sc,f=Oa;Oa=!0;try{eg(e,a,b,c,d)}finally{(Oa=f)||ud()}}function Fi(a,b,c,d){Gi(Hi,sc.bind(null,a,b,c,d))}function sc(a,b,c,d){if(tc)if(0<fa.length&&-1<Nd.indexOf(a))a=Od(null,a,b,c,d),fa.push(a);else{var e=Qd(a,b,c,d);if(null===e)Xf(a,d);else if(-1<Nd.indexOf(a))a=Od(e,a,b,c,d),fa.push(a);else if(!zi(e,a,b,c,d)){Xf(a,d);a=Vf(a,d,null,b);try{uf(Wf,a)}finally{Uf(a)}}}}function Qd(a,b,c,d){c=Ld(d);c=Bb(c);if(null!==c){var e=Na(c);if(null===
e)c=null;else{var f=e.tag;if(13===f){c=Qf(e);if(null!==c)return c;c=null}else if(3===f){if(e.stateNode.hydrate)return 3===e.tag?e.stateNode.containerInfo:null;c=null}else e!==c&&(c=null)}}a=Vf(a,d,c,b);try{uf(Wf,a)}finally{Uf(a)}return null}function fg(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||Kb.hasOwnProperty(a)&&Kb[a]?(""+b).trim():b+"px"}function gg(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=fg(c,b[c],d);"float"===
c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}function Ud(a,b){if(b){if(Ii[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(k(137,a,""));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(k(60));if(!("object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML))throw Error(k(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(k(62,""));}}function Vd(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;
default:return!0}}function oa(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=Jd(a);b=rd[b];for(var d=0;d<b.length;d++)Md(b[d],a,c)}function uc(){}function Wd(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}function hg(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function ig(a,b){var c=hg(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,
offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=hg(c)}}function jg(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?jg(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}function kg(){for(var a=window,b=Wd();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=Wd(a.document)}return b}
function Xd(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}function lg(a,b){switch(a){case "button":case "input":case "select":case "textarea":return!!b.autoFocus}return!1}function Yd(a,b){return"textarea"===a||"option"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&
null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}function kb(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break}return a}function mg(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if(c===ng||c===Zd||c===$d){if(0===b)return a;b--}else c===og&&b++}a=a.previousSibling}return null}function Bb(a){var b=a[Aa];if(b)return b;for(var c=a.parentNode;c;){if(b=c[Lb]||c[Aa]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=mg(a);null!==
a;){if(c=a[Aa])return c;a=mg(a)}return b}a=c;c=a.parentNode}return null}function Hb(a){a=a[Aa]||a[Lb];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function Pa(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(k(33));}function ae(a){return a[vc]||null}function pa(a){do a=a.return;while(a&&5!==a.tag);return a?a:null}function pg(a,b){var c=a.stateNode;if(!c)return null;var d=td(c);if(!d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=
!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&"function"!==typeof c)throw Error(k(231,b,typeof c));return c}function qg(a,b,c){if(b=pg(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a)}function Ji(a){if(a&&a.dispatchConfig.phasedRegistrationNames){for(var b=a._targetInst,c=[];b;)c.push(b),b=pa(b);for(b=c.length;0<b--;)qg(c[b],
"captured",a);for(b=0;b<c.length;b++)qg(c[b],"bubbled",a)}}function be(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=pg(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a))}function Ki(a){a&&a.dispatchConfig.registrationName&&be(a._targetInst,null,a)}function lb(a){Kd(a,Ji)}function rg(){if(wc)return wc;var a,b=ce,c=b.length,d,e="value"in Ba?Ba.value:Ba.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=
c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return wc=e.slice(a,1<d?1-d:void 0)}function xc(){return!0}function yc(){return!1}function R(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?xc:yc;this.isPropagationStopped=yc;return this}function Li(a,b,c,d){if(this.eventPool.length){var e=
this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}function Mi(a){if(!(a instanceof this))throw Error(k(279));a.destructor();10>this.eventPool.length&&this.eventPool.push(a)}function sg(a){a.eventPool=[];a.getPooled=Li;a.release=Mi}function tg(a,b){switch(a){case "keyup":return-1!==Ni.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "blur":return!0;default:return!1}}function ug(a){a=a.detail;return"object"===typeof a&&"data"in
a?a.data:null}function Oi(a,b){switch(a){case "compositionend":return ug(b);case "keypress":if(32!==b.which)return null;vg=!0;return wg;case "textInput":return a=b.data,a===wg&&vg?null:a;default:return null}}function Pi(a,b){if(mb)return"compositionend"===a||!de&&tg(a,b)?(a=rg(),wc=ce=Ba=null,mb=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;
case "compositionend":return xg&&"ko"!==b.locale?null:b.data;default:return null}}function yg(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!Qi[a.type]:"textarea"===b?!0:!1}function zg(a,b,c){a=R.getPooled(Ag.change,a,b,c);a.type="change";sf(c);lb(a);return a}function Ri(a){pc(a)}function zc(a){var b=Pa(a);if(Gf(b))return a}function Si(a,b){if("change"===a)return b}function Bg(){Mb&&(Mb.detachEvent("onpropertychange",Cg),Nb=Mb=null)}function Cg(a){if("value"===a.propertyName&&
zc(Nb))if(a=zg(Nb,a,Ld(a)),Oa)pc(a);else{Oa=!0;try{ee(Ri,a)}finally{Oa=!1,ud()}}}function Ti(a,b,c){"focus"===a?(Bg(),Mb=b,Nb=c,Mb.attachEvent("onpropertychange",Cg)):"blur"===a&&Bg()}function Ui(a,b){if("selectionchange"===a||"keyup"===a||"keydown"===a)return zc(Nb)}function Vi(a,b){if("click"===a)return zc(b)}function Wi(a,b){if("input"===a||"change"===a)return zc(b)}function Xi(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Yi[a])?!!b[a]:!1}function fe(a){return Xi}
function Zi(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}function Ob(a,b){if(Qa(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++)if(!$i.call(b,c[d])||!Qa(a[c[d]],b[c[d]]))return!1;return!0}function Dg(a,b){var c=b.window===b?b.document:9===b.nodeType?b:b.ownerDocument;if(ge||null==nb||nb!==Wd(c))return null;c=nb;"selectionStart"in c&&Xd(c)?c={start:c.selectionStart,
end:c.selectionEnd}:(c=(c.ownerDocument&&c.ownerDocument.defaultView||window).getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset});return Pb&&Ob(Pb,c)?null:(Pb=c,a=R.getPooled(Eg.select,he,a,b),a.type="select",a.target=nb,lb(a),a)}function Ac(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function q(a,b){0>ob||(a.current=ie[ob],ie[ob]=null,ob--)}function y(a,b,c){ob++;
ie[ob]=a.current;a.current=b}function pb(a,b){var c=a.type.contextTypes;if(!c)return Ca;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function N(a){a=a.childContextTypes;return null!==a&&void 0!==a}function Fg(a,b,c){if(B.current!==Ca)throw Error(k(168));y(B,b);y(G,c)}
function Gg(a,b,c){var d=a.stateNode;a=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in a))throw Error(k(108,na(b)||"Unknown",e));return M({},c,{},d)}function Bc(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Ca;Ra=B.current;y(B,a);y(G,G.current);return!0}function Hg(a,b,c){var d=a.stateNode;if(!d)throw Error(k(169));c?(a=Gg(a,b,Ra),d.__reactInternalMemoizedMergedChildContext=a,q(G),q(B),y(B,a)):q(G);y(G,c)}function Cc(){switch(aj()){case Dc:return 99;
case Ig:return 98;case Jg:return 97;case Kg:return 96;case Lg:return 95;default:throw Error(k(332));}}function Mg(a){switch(a){case 99:return Dc;case 98:return Ig;case 97:return Jg;case 96:return Kg;case 95:return Lg;default:throw Error(k(332));}}function Da(a,b){a=Mg(a);return bj(a,b)}function Ng(a,b,c){a=Mg(a);return je(a,b,c)}function Og(a){null===qa?(qa=[a],Ec=je(Dc,Pg)):qa.push(a);return Qg}function ha(){if(null!==Ec){var a=Ec;Ec=null;Rg(a)}Pg()}function Pg(){if(!ke&&null!==qa){ke=!0;var a=0;
try{var b=qa;Da(99,function(){for(;a<b.length;a++){var c=b[a];do c=c(!0);while(null!==c)}});qa=null}catch(c){throw null!==qa&&(qa=qa.slice(a+1)),je(Dc,ha),c;}finally{ke=!1}}}function Fc(a,b,c){c/=10;return 1073741821-(((1073741821-a+b/10)/c|0)+1)*c}function aa(a,b){if(a&&a.defaultProps){b=M({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c])}return b}function le(){Gc=qb=Hc=null}function me(a){var b=Ic.current;q(Ic);a.type._context._currentValue=b}function Sg(a,b){for(;null!==a;){var c=
a.alternate;if(a.childExpirationTime<b)a.childExpirationTime=b,null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);else if(null!==c&&c.childExpirationTime<b)c.childExpirationTime=b;else break;a=a.return}}function rb(a,b){Hc=a;Gc=qb=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(a.expirationTime>=b&&(ia=!0),a.firstContext=null)}function W(a,b){if(Gc!==a&&!1!==b&&0!==b){if("number"!==typeof b||1073741823===b)Gc=a,b=1073741823;b={context:a,observedBits:b,next:null};if(null===qb){if(null===
Hc)throw Error(k(308));qb=b;Hc.dependencies={expirationTime:0,firstContext:b,responders:null}}else qb=qb.next=b}return a._currentValue}function ne(a){a.updateQueue={baseState:a.memoizedState,baseQueue:null,shared:{pending:null},effects:null}}function oe(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,baseQueue:a.baseQueue,shared:a.shared,effects:a.effects})}function Ea(a,b){a={expirationTime:a,suspenseConfig:b,tag:Tg,payload:null,callback:null,next:null};return a.next=
a}function Fa(a,b){a=a.updateQueue;if(null!==a){a=a.shared;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}}function Ug(a,b){var c=a.alternate;null!==c&&oe(c,a);a=a.updateQueue;c=a.baseQueue;null===c?(a.baseQueue=b.next=b,b.next=b):(b.next=c.next,c.next=b)}function Qb(a,b,c,d){var e=a.updateQueue;Ga=!1;var f=e.baseQueue,g=e.shared.pending;if(null!==g){if(null!==f){var h=f.next;f.next=g.next;g.next=h}f=g;e.shared.pending=null;h=a.alternate;null!==h&&(h=h.updateQueue,null!==h&&
(h.baseQueue=g))}if(null!==f){h=f.next;var m=e.baseState,n=0,k=null,ba=null,l=null;if(null!==h){var p=h;do{g=p.expirationTime;if(g<d){var t={expirationTime:p.expirationTime,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null};null===l?(ba=l=t,k=m):l=l.next=t;g>n&&(n=g)}else{null!==l&&(l=l.next={expirationTime:1073741823,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null});Vg(g,p.suspenseConfig);a:{var q=a,r=p;g=b;t=c;switch(r.tag){case 1:q=
r.payload;if("function"===typeof q){m=q.call(t,m,g);break a}m=q;break a;case 3:q.effectTag=q.effectTag&-4097|64;case Tg:q=r.payload;g="function"===typeof q?q.call(t,m,g):q;if(null===g||void 0===g)break a;m=M({},m,g);break a;case Jc:Ga=!0}}null!==p.callback&&(a.effectTag|=32,g=e.effects,null===g?e.effects=[p]:g.push(p))}p=p.next;if(null===p||p===h)if(g=e.shared.pending,null===g)break;else p=f.next=g.next,g.next=h,e.baseQueue=f=g,e.shared.pending=null}while(1)}null===l?k=m:l.next=ba;e.baseState=k;e.baseQueue=
l;Kc(n);a.expirationTime=n;a.memoizedState=m}}function Wg(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=e;e=c;if("function"!==typeof d)throw Error(k(191,d));d.call(e)}}}function Lc(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:M({},b,c);a.memoizedState=c;0===a.expirationTime&&(a.updateQueue.baseState=c)}function Xg(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,
f,g):b.prototype&&b.prototype.isPureReactComponent?!Ob(c,d)||!Ob(e,f):!0}function Yg(a,b,c){var d=!1,e=Ca;var f=b.contextType;"object"===typeof f&&null!==f?f=W(f):(e=N(b)?Ra:B.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?pb(a,e):Ca);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Mc;a.stateNode=b;b._reactInternalFiber=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}function Zg(a,
b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Mc.enqueueReplaceState(b,b.state,null)}function pe(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=$g;ne(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=W(f):(f=N(b)?Ra:B.current,e.context=pb(a,f));Qb(a,c,e,d);e.state=a.memoizedState;f=b.getDerivedStateFromProps;
"function"===typeof f&&(Lc(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||(b=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Mc.enqueueReplaceState(e,e.state,null),Qb(a,c,e,d),e.state=a.memoizedState);"function"===
typeof e.componentDidMount&&(a.effectTag|=4)}function Rb(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(k(309));var d=c.stateNode}if(!d)throw Error(k(147,a));var e=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===e)return b.ref;b=function(a){var b=d.refs;b===$g&&(b=d.refs={});null===a?delete b[e]:b[e]=a};b._stringRef=e;return b}if("string"!==typeof a)throw Error(k(284));if(!c._owner)throw Error(k(290,
a));}return a}function Nc(a,b){if("textarea"!==a.type)throw Error(k(31,"[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,""));}function ah(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,
b),b=b.sibling;return a}function e(a,b){a=Sa(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=qe(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function m(a,b,c,d){if(null!==b&&b.elementType===c.type)return d=e(b,c.props),d.ref=Rb(a,b,c),d.return=a,d;d=Oc(c.type,
c.key,c.props,null,a.mode,d);d.ref=Rb(a,b,c);d.return=a;return d}function n(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=re(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function l(a,b,c,d,f){if(null===b||7!==b.tag)return b=Ha(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function ba(a,b,c){if("string"===typeof b||"number"===typeof b)return b=qe(""+b,a.mode,c),b.return=a,b;if("object"===
typeof b&&null!==b){switch(b.$$typeof){case Pc:return c=Oc(b.type,b.key,b.props,null,a.mode,c),c.ref=Rb(a,null,b),c.return=a,c;case gb:return b=re(b,a.mode,c),b.return=a,b}if(Qc(b)||zb(b))return b=Ha(b,a.mode,c,null),b.return=a,b;Nc(a,b)}return null}function p(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case Pc:return c.key===e?c.type===Ma?l(a,b,c.props.children,d,e):m(a,b,c,
d):null;case gb:return c.key===e?n(a,b,c,d):null}if(Qc(c)||zb(c))return null!==e?null:l(a,b,c,d,null);Nc(a,c)}return null}function t(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case Pc:return a=a.get(null===d.key?c:d.key)||null,d.type===Ma?l(b,a,d.props.children,e,d.key):m(b,a,d,e);case gb:return a=a.get(null===d.key?c:d.key)||null,n(b,a,d,e)}if(Qc(d)||zb(d))return a=a.get(c)||null,l(b,a,d,e,null);
Nc(b,d)}return null}function q(e,g,h,m){for(var n=null,k=null,l=g,r=g=0,C=null;null!==l&&r<h.length;r++){l.index>r?(C=l,l=null):C=l.sibling;var O=p(e,l,h[r],m);if(null===O){null===l&&(l=C);break}a&&l&&null===O.alternate&&b(e,l);g=f(O,g,r);null===k?n=O:k.sibling=O;k=O;l=C}if(r===h.length)return c(e,l),n;if(null===l){for(;r<h.length;r++)l=ba(e,h[r],m),null!==l&&(g=f(l,g,r),null===k?n=l:k.sibling=l,k=l);return n}for(l=d(e,l);r<h.length;r++)C=t(l,e,r,h[r],m),null!==C&&(a&&null!==C.alternate&&l.delete(null===
C.key?r:C.key),g=f(C,g,r),null===k?n=C:k.sibling=C,k=C);a&&l.forEach(function(a){return b(e,a)});return n}function w(e,g,h,n){var m=zb(h);if("function"!==typeof m)throw Error(k(150));h=m.call(h);if(null==h)throw Error(k(151));for(var l=m=null,r=g,C=g=0,O=null,v=h.next();null!==r&&!v.done;C++,v=h.next()){r.index>C?(O=r,r=null):O=r.sibling;var q=p(e,r,v.value,n);if(null===q){null===r&&(r=O);break}a&&r&&null===q.alternate&&b(e,r);g=f(q,g,C);null===l?m=q:l.sibling=q;l=q;r=O}if(v.done)return c(e,r),m;
if(null===r){for(;!v.done;C++,v=h.next())v=ba(e,v.value,n),null!==v&&(g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);return m}for(r=d(e,r);!v.done;C++,v=h.next())v=t(r,e,C,v.value,n),null!==v&&(a&&null!==v.alternate&&r.delete(null===v.key?C:v.key),g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);a&&r.forEach(function(a){return b(e,a)});return m}return function(a,d,f,h){var m="object"===typeof f&&null!==f&&f.type===Ma&&null===f.key;m&&(f=f.props.children);var n="object"===typeof f&&null!==f;if(n)switch(f.$$typeof){case Pc:a:{n=
f.key;for(m=d;null!==m;){if(m.key===n){switch(m.tag){case 7:if(f.type===Ma){c(a,m.sibling);d=e(m,f.props.children);d.return=a;a=d;break a}break;default:if(m.elementType===f.type){c(a,m.sibling);d=e(m,f.props);d.ref=Rb(a,m,f);d.return=a;a=d;break a}}c(a,m);break}else b(a,m);m=m.sibling}f.type===Ma?(d=Ha(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Oc(f.type,f.key,f.props,null,a.mode,h),h.ref=Rb(a,d,f),h.return=a,a=h)}return g(a);case gb:a:{for(m=f.key;null!==d;){if(d.key===m)if(4===d.tag&&d.stateNode.containerInfo===
f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=re(f,a.mode,h);d.return=a;a=d}return g(a)}if("string"===typeof f||"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):(c(a,d),d=qe(f,a.mode,h),d.return=a,a=d),g(a);if(Qc(f))return q(a,d,f,h);if(zb(f))return w(a,d,f,h);n&&Nc(a,f);if("undefined"===typeof f&&!m)switch(a.tag){case 1:case 0:throw a=
a.type,Error(k(152,a.displayName||a.name||"Component"));}return c(a,d)}}function Ta(a){if(a===Sb)throw Error(k(174));return a}function se(a,b){y(Tb,b);y(Ub,a);y(ja,Sb);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:Hd(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=Hd(b,a)}q(ja);y(ja,b)}function tb(a){q(ja);q(Ub);q(Tb)}function bh(a){Ta(Tb.current);var b=Ta(ja.current);var c=Hd(b,a.type);b!==c&&(y(Ub,a),y(ja,c))}function te(a){Ub.current===
a&&(q(ja),q(Ub))}function Rc(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||c.data===$d||c.data===Zd))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.effectTag&64))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}function ue(a,b){return{responder:a,props:b}}
function S(){throw Error(k(321));}function ve(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!Qa(a[c],b[c]))return!1;return!0}function we(a,b,c,d,e,f){Ia=f;z=b;b.memoizedState=null;b.updateQueue=null;b.expirationTime=0;Sc.current=null===a||null===a.memoizedState?dj:ej;a=c(d,e);if(b.expirationTime===Ia){f=0;do{b.expirationTime=0;if(!(25>f))throw Error(k(301));f+=1;J=K=null;b.updateQueue=null;Sc.current=fj;a=c(d,e)}while(b.expirationTime===Ia)}Sc.current=Tc;b=null!==K&&null!==K.next;
Ia=0;J=K=z=null;Uc=!1;if(b)throw Error(k(300));return a}function ub(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===J?z.memoizedState=J=a:J=J.next=a;return J}function vb(){if(null===K){var a=z.alternate;a=null!==a?a.memoizedState:null}else a=K.next;var b=null===J?z.memoizedState:J.next;if(null!==b)J=b,K=a;else{if(null===a)throw Error(k(310));K=a;a={memoizedState:K.memoizedState,baseState:K.baseState,baseQueue:K.baseQueue,queue:K.queue,next:null};null===J?z.memoizedState=
J=a:J=J.next=a}return J}function Ua(a,b){return"function"===typeof b?b(a):b}function Vc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=K,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){e=e.next;d=d.baseState;var h=g=f=null,m=e;do{var n=m.expirationTime;if(n<Ia){var l={expirationTime:m.expirationTime,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,
next:null};null===h?(g=h=l,f=d):h=h.next=l;n>z.expirationTime&&(z.expirationTime=n,Kc(n))}else null!==h&&(h=h.next={expirationTime:1073741823,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,next:null}),Vg(n,m.suspenseConfig),d=m.eagerReducer===a?m.eagerState:a(d,m.action);m=m.next}while(null!==m&&m!==e);null===h?f=d:h.next=g;Qa(d,b.memoizedState)||(ia=!0);b.memoizedState=d;b.baseState=f;b.baseQueue=h;c.lastRenderedState=d}return[b.memoizedState,
c.dispatch]}function Wc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);Qa(f,b.memoizedState)||(ia=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}function xe(a){var b=ub();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a=b.queue={pending:null,dispatch:null,lastRenderedReducer:Ua,
lastRenderedState:a};a=a.dispatch=ch.bind(null,z,a);return[b.memoizedState,a]}function ye(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=z.updateQueue;null===b?(b={lastEffect:null},z.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function dh(a){return vb().memoizedState}function ze(a,b,c,d){var e=ub();z.effectTag|=a;e.memoizedState=ye(1|b,c,void 0,void 0===d?null:d)}function Ae(a,b,c,d){var e=vb();
d=void 0===d?null:d;var f=void 0;if(null!==K){var g=K.memoizedState;f=g.destroy;if(null!==d&&ve(d,g.deps)){ye(b,c,f,d);return}}z.effectTag|=a;e.memoizedState=ye(1|b,c,f,d)}function eh(a,b){return ze(516,4,a,b)}function Xc(a,b){return Ae(516,4,a,b)}function fh(a,b){return Ae(4,2,a,b)}function gh(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function hh(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;
return Ae(4,2,gh.bind(null,b,a),c)}function Be(a,b){}function ih(a,b){ub().memoizedState=[a,void 0===b?null:b];return a}function Yc(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];c.memoizedState=[a,b];return a}function jh(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function Ce(a,b,c){var d=Cc();Da(98>d?98:d,function(){a(!0)});Da(97<d?97:d,function(){var d=
X.suspense;X.suspense=void 0===b?null:b;try{a(!1),c()}finally{X.suspense=d}})}function ch(a,b,c){var d=ka(),e=Vb.suspense;d=Va(d,a,e);e={expirationTime:d,suspenseConfig:e,action:c,eagerReducer:null,eagerState:null,next:null};var f=b.pending;null===f?e.next=e:(e.next=f.next,f.next=e);b.pending=e;f=a.alternate;if(a===z||null!==f&&f===z)Uc=!0,e.expirationTime=Ia,z.expirationTime=Ia;else{if(0===a.expirationTime&&(null===f||0===f.expirationTime)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,
h=f(g,c);e.eagerReducer=f;e.eagerState=h;if(Qa(h,g))return}catch(m){}finally{}Ja(a,d)}}function kh(a,b){var c=la(5,null,null,0);c.elementType="DELETED";c.type="DELETED";c.stateNode=b;c.return=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}function lh(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?
null:b,null!==b?(a.stateNode=b,!0):!1;case 13:return!1;default:return!1}}function De(a){if(Wa){var b=Ka;if(b){var c=b;if(!lh(a,b)){b=kb(c.nextSibling);if(!b||!lh(a,b)){a.effectTag=a.effectTag&-1025|2;Wa=!1;ra=a;return}kh(ra,c)}ra=a;Ka=kb(b.firstChild)}else a.effectTag=a.effectTag&-1025|2,Wa=!1,ra=a}}function mh(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;ra=a}function Zc(a){if(a!==ra)return!1;if(!Wa)return mh(a),Wa=!0,!1;var b=a.type;if(5!==a.tag||"head"!==b&&"body"!==
b&&!Yd(b,a.memoizedProps))for(b=Ka;b;)kh(a,b),b=kb(b.nextSibling);mh(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(k(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if(c===og){if(0===b){Ka=kb(a.nextSibling);break a}b--}else c!==ng&&c!==Zd&&c!==$d||b++}a=a.nextSibling}Ka=null}}else Ka=ra?kb(a.stateNode.nextSibling):null;return!0}function Ee(){Ka=ra=null;Wa=!1}function T(a,b,c,d){b.child=null===a?Fe(b,null,c,d):wb(b,a.child,c,d)}function nh(a,
b,c,d,e){c=c.render;var f=b.ref;rb(b,e);d=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,d,e);return b.child}function oh(a,b,c,d,e,f){if(null===a){var g=c.type;if("function"===typeof g&&!Ge(g)&&void 0===g.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=g,ph(a,b,g,d,e,f);a=Oc(c.type,null,d,null,b.mode,f);a.ref=b.ref;a.return=b;return b.child=a}g=a.child;if(e<
f&&(e=g.memoizedProps,c=c.compare,c=null!==c?c:Ob,c(e,d)&&a.ref===b.ref))return sa(a,b,f);b.effectTag|=1;a=Sa(g,d);a.ref=b.ref;a.return=b;return b.child=a}function ph(a,b,c,d,e,f){return null!==a&&Ob(a.memoizedProps,d)&&a.ref===b.ref&&(ia=!1,e<f)?(b.expirationTime=a.expirationTime,sa(a,b,f)):He(a,b,c,d,f)}function qh(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.effectTag|=128}function He(a,b,c,d,e){var f=N(c)?Ra:B.current;f=pb(b,f);rb(b,e);c=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=
a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,c,e);return b.child}function rh(a,b,c,d,e){if(N(c)){var f=!0;Bc(b)}else f=!1;rb(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),Yg(b,c,d),pe(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var m=g.context,n=c.contextType;"object"===typeof n&&null!==n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n));var l=c.getDerivedStateFromProps,k="function"===
typeof l||"function"===typeof g.getSnapshotBeforeUpdate;k||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n);Ga=!1;var p=b.memoizedState;g.state=p;Qb(b,d,g,e);m=b.memoizedState;h!==d||p!==m||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),m=b.memoizedState),(h=Ga||Xg(b,c,h,d,p,m,n))?(k||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&
g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===typeof g.componentDidMount&&(b.effectTag|=4)):("function"===typeof g.componentDidMount&&(b.effectTag|=4),b.memoizedProps=d,b.memoizedState=m),g.props=d,g.state=m,g.context=n,d=h):("function"===typeof g.componentDidMount&&(b.effectTag|=4),d=!1)}else g=b.stateNode,oe(a,b),h=b.memoizedProps,g.props=b.type===b.elementType?h:aa(b.type,h),m=g.context,n=c.contextType,"object"===typeof n&&null!==
n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n)),l=c.getDerivedStateFromProps,(k="function"===typeof l||"function"===typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n),Ga=!1,m=b.memoizedState,g.state=m,Qb(b,d,g,e),p=b.memoizedState,h!==d||m!==p||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),p=b.memoizedState),(l=Ga||Xg(b,c,h,d,m,p,n))?(k||"function"!==typeof g.UNSAFE_componentWillUpdate&&
"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,p,n),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,p,n)),"function"===typeof g.componentDidUpdate&&(b.effectTag|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.effectTag|=256)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===
a.memoizedState||(b.effectTag|=256),b.memoizedProps=d,b.memoizedState=p),g.props=d,g.state=p,g.context=n,d=l):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=256),d=!1);return Ie(a,b,c,d,f,e)}function Ie(a,b,c,d,e,f){qh(a,b);var g=0!==(b.effectTag&64);if(!d&&!g)return e&&Hg(b,c,!1),sa(a,b,f);d=b.stateNode;gj.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?
null:d.render();b.effectTag|=1;null!==a&&g?(b.child=wb(b,a.child,null,f),b.child=wb(b,null,h,f)):T(a,b,h,f);b.memoizedState=d.state;e&&Hg(b,c,!0);return b.child}function sh(a){var b=a.stateNode;b.pendingContext?Fg(a,b.pendingContext,b.pendingContext!==b.context):b.context&&Fg(a,b.context,!1);se(a,b.containerInfo)}function th(a,b,c){var d=b.mode,e=b.pendingProps,f=D.current,g=!1,h;(h=0!==(b.effectTag&64))||(h=0!==(f&2)&&(null===a||null!==a.memoizedState));h?(g=!0,b.effectTag&=-65):null!==a&&null===
a.memoizedState||void 0===e.fallback||!0===e.unstable_avoidThisFallback||(f|=1);y(D,f&1);if(null===a){void 0!==e.fallback&&De(b);if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;b.memoizedState=Je;b.child=e;return c}d=e.children;b.memoizedState=null;return b.child=Fe(b,null,d,c)}if(null!==a.memoizedState){a=a.child;d=a.sibling;if(g){e=e.fallback;
c=Sa(a,a.pendingProps);c.return=b;if(0===(b.mode&2)&&(g=null!==b.memoizedState?b.child.child:b.child,g!==a.child))for(c.child=g;null!==g;)g.return=c,g=g.sibling;d=Sa(d,e);d.return=b;c.sibling=d;c.childExpirationTime=0;b.memoizedState=Je;b.child=c;return d}c=wb(b,a.child,e.children,c);b.memoizedState=null;return b.child=c}a=a.child;if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;e.child=a;null!==a&&(a.return=e);if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==
a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;c.effectTag|=2;e.childExpirationTime=0;b.memoizedState=Je;b.child=e;return c}b.memoizedState=null;return b.child=wb(b,a,e.children,c)}function uh(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);Sg(a.return,b)}function Ke(a,b,c,d,e,f){var g=a.memoizedState;null===g?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailExpiration:0,tailMode:e,
lastEffect:f}:(g.isBackwards=b,g.rendering=null,g.renderingStartTime=0,g.last=d,g.tail=c,g.tailExpiration=0,g.tailMode=e,g.lastEffect=f)}function vh(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;T(a,b,d.children,c);d=D.current;if(0!==(d&2))d=d&1|2,b.effectTag|=64;else{if(null!==a&&0!==(a.effectTag&64))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&uh(a,c);else if(19===a.tag)uh(a,c);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===
a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}y(D,d);if(0===(b.mode&2))b.memoizedState=null;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===Rc(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);Ke(b,!1,e,c,f,b.lastEffect);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===Rc(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}Ke(b,
!0,c,null,f,b.lastEffect);break;case "together":Ke(b,!1,null,null,void 0,b.lastEffect);break;default:b.memoizedState=null}return b.child}function sa(a,b,c){null!==a&&(b.dependencies=a.dependencies);var d=b.expirationTime;0!==d&&Kc(d);if(b.childExpirationTime<c)return null;if(null!==a&&b.child!==a.child)throw Error(k(153));if(null!==b.child){a=b.child;c=Sa(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Sa(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}
function $c(a,b){switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}function hj(a,b,c){var d=b.pendingProps;switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:return N(b.type)&&(q(G),q(B)),
null;case 3:return tb(),q(G),q(B),c=b.stateNode,c.pendingContext&&(c.context=c.pendingContext,c.pendingContext=null),null!==a&&null!==a.child||!Zc(b)||(b.effectTag|=4),wh(b),null;case 5:te(b);c=Ta(Tb.current);var e=b.type;if(null!==a&&null!=b.stateNode)ij(a,b,e,d,c),a.ref!==b.ref&&(b.effectTag|=128);else{if(!d){if(null===b.stateNode)throw Error(k(166));return null}a=Ta(ja.current);if(Zc(b)){d=b.stateNode;e=b.type;var f=b.memoizedProps;d[Aa]=b;d[vc]=f;switch(e){case "iframe":case "object":case "embed":w("load",
d);break;case "video":case "audio":for(a=0;a<Db.length;a++)w(Db[a],d);break;case "source":w("error",d);break;case "img":case "image":case "link":w("error",d);w("load",d);break;case "form":w("reset",d);w("submit",d);break;case "details":w("toggle",d);break;case "input":Hf(d,f);w("invalid",d);oa(c,"onChange");break;case "select":d._wrapperState={wasMultiple:!!f.multiple};w("invalid",d);oa(c,"onChange");break;case "textarea":Kf(d,f),w("invalid",d),oa(c,"onChange")}Ud(e,f);a=null;for(var g in f)if(f.hasOwnProperty(g)){var h=
f[g];"children"===g?"string"===typeof h?d.textContent!==h&&(a=["children",h]):"number"===typeof h&&d.textContent!==""+h&&(a=["children",""+h]):db.hasOwnProperty(g)&&null!=h&&oa(c,g)}switch(e){case "input":mc(d);Jf(d,f,!0);break;case "textarea":mc(d);Mf(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&(d.onclick=uc)}c=a;b.updateQueue=c;null!==c&&(b.effectTag|=4)}else{g=9===c.nodeType?c:c.ownerDocument;"http://www.w3.org/1999/xhtml"===a&&(a=Nf(e));"http://www.w3.org/1999/xhtml"===
a?"script"===e?(a=g.createElement("div"),a.innerHTML="<script>\x3c/script>",a=a.removeChild(a.firstChild)):"string"===typeof d.is?a=g.createElement(e,{is:d.is}):(a=g.createElement(e),"select"===e&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,e);a[Aa]=b;a[vc]=d;jj(a,b,!1,!1);b.stateNode=a;g=Vd(e,d);switch(e){case "iframe":case "object":case "embed":w("load",a);h=d;break;case "video":case "audio":for(h=0;h<Db.length;h++)w(Db[h],a);h=d;break;case "source":w("error",a);
h=d;break;case "img":case "image":case "link":w("error",a);w("load",a);h=d;break;case "form":w("reset",a);w("submit",a);h=d;break;case "details":w("toggle",a);h=d;break;case "input":Hf(a,d);h=Cd(a,d);w("invalid",a);oa(c,"onChange");break;case "option":h=Fd(a,d);break;case "select":a._wrapperState={wasMultiple:!!d.multiple};h=M({},d,{value:void 0});w("invalid",a);oa(c,"onChange");break;case "textarea":Kf(a,d);h=Gd(a,d);w("invalid",a);oa(c,"onChange");break;default:h=d}Ud(e,h);var m=h;for(f in m)if(m.hasOwnProperty(f)){var n=
m[f];"style"===f?gg(a,n):"dangerouslySetInnerHTML"===f?(n=n?n.__html:void 0,null!=n&&xh(a,n)):"children"===f?"string"===typeof n?("textarea"!==e||""!==n)&&Wb(a,n):"number"===typeof n&&Wb(a,""+n):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(db.hasOwnProperty(f)?null!=n&&oa(c,f):null!=n&&xd(a,f,n,g))}switch(e){case "input":mc(a);Jf(a,d,!1);break;case "textarea":mc(a);Mf(a);break;case "option":null!=d.value&&a.setAttribute("value",""+va(d.value));break;case "select":a.multiple=
!!d.multiple;c=d.value;null!=c?hb(a,!!d.multiple,c,!1):null!=d.defaultValue&&hb(a,!!d.multiple,d.defaultValue,!0);break;default:"function"===typeof h.onClick&&(a.onclick=uc)}lg(e,d)&&(b.effectTag|=4)}null!==b.ref&&(b.effectTag|=128)}return null;case 6:if(a&&null!=b.stateNode)kj(a,b,a.memoizedProps,d);else{if("string"!==typeof d&&null===b.stateNode)throw Error(k(166));c=Ta(Tb.current);Ta(ja.current);Zc(b)?(c=b.stateNode,d=b.memoizedProps,c[Aa]=b,c.nodeValue!==d&&(b.effectTag|=4)):(c=(9===c.nodeType?
c:c.ownerDocument).createTextNode(d),c[Aa]=b,b.stateNode=c)}return null;case 13:q(D);d=b.memoizedState;if(0!==(b.effectTag&64))return b.expirationTime=c,b;c=null!==d;d=!1;null===a?void 0!==b.memoizedProps.fallback&&Zc(b):(e=a.memoizedState,d=null!==e,c||null===e||(e=a.child.sibling,null!==e&&(f=b.firstEffect,null!==f?(b.firstEffect=e,e.nextEffect=f):(b.firstEffect=b.lastEffect=e,e.nextEffect=null),e.effectTag=8)));if(c&&!d&&0!==(b.mode&2))if(null===a&&!0!==b.memoizedProps.unstable_avoidThisFallback||
0!==(D.current&1))F===Xa&&(F=ad);else{if(F===Xa||F===ad)F=bd;0!==Xb&&null!==U&&(Ya(U,P),yh(U,Xb))}if(c||d)b.effectTag|=4;return null;case 4:return tb(),wh(b),null;case 10:return me(b),null;case 17:return N(b.type)&&(q(G),q(B)),null;case 19:q(D);d=b.memoizedState;if(null===d)return null;e=0!==(b.effectTag&64);f=d.rendering;if(null===f)if(e)$c(d,!1);else{if(F!==Xa||null!==a&&0!==(a.effectTag&64))for(f=b.child;null!==f;){a=Rc(f);if(null!==a){b.effectTag|=64;$c(d,!1);e=a.updateQueue;null!==e&&(b.updateQueue=
e,b.effectTag|=4);null===d.lastEffect&&(b.firstEffect=null);b.lastEffect=d.lastEffect;for(d=b.child;null!==d;)e=d,f=c,e.effectTag&=2,e.nextEffect=null,e.firstEffect=null,e.lastEffect=null,a=e.alternate,null===a?(e.childExpirationTime=0,e.expirationTime=f,e.child=null,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null):(e.childExpirationTime=a.childExpirationTime,e.expirationTime=a.expirationTime,e.child=a.child,e.memoizedProps=a.memoizedProps,e.memoizedState=a.memoizedState,
e.updateQueue=a.updateQueue,f=a.dependencies,e.dependencies=null===f?null:{expirationTime:f.expirationTime,firstContext:f.firstContext,responders:f.responders}),d=d.sibling;y(D,D.current&1|2);return b.child}f=f.sibling}}else{if(!e)if(a=Rc(f),null!==a){if(b.effectTag|=64,e=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.effectTag|=4),$c(d,!0),null===d.tail&&"hidden"===d.tailMode&&!f.alternate)return b=b.lastEffect=d.lastEffect,null!==b&&(b.nextEffect=null),null}else 2*Y()-d.renderingStartTime>d.tailExpiration&&
1<c&&(b.effectTag|=64,e=!0,$c(d,!1),b.expirationTime=b.childExpirationTime=c-1);d.isBackwards?(f.sibling=b.child,b.child=f):(c=d.last,null!==c?c.sibling=f:b.child=f,d.last=f)}return null!==d.tail?(0===d.tailExpiration&&(d.tailExpiration=Y()+500),c=d.tail,d.rendering=c,d.tail=c.sibling,d.lastEffect=b.lastEffect,d.renderingStartTime=Y(),c.sibling=null,b=D.current,y(D,e?b&1|2:b&1),c):null}throw Error(k(156,b.tag));}function lj(a,b){switch(a.tag){case 1:return N(a.type)&&(q(G),q(B)),b=a.effectTag,b&4096?
(a.effectTag=b&-4097|64,a):null;case 3:tb();q(G);q(B);b=a.effectTag;if(0!==(b&64))throw Error(k(285));a.effectTag=b&-4097|64;return a;case 5:return te(a),null;case 13:return q(D),b=a.effectTag,b&4096?(a.effectTag=b&-4097|64,a):null;case 19:return q(D),null;case 4:return tb(),null;case 10:return me(a),null;default:return null}}function Le(a,b){return{value:a,source:b,stack:Bd(b)}}function Me(a,b){var c=b.source,d=b.stack;null===d&&null!==c&&(d=Bd(c));null!==c&&na(c.type);b=b.value;null!==a&&1===a.tag&&
na(a.type);try{console.error(b)}catch(e){setTimeout(function(){throw e;})}}function mj(a,b){try{b.props=a.memoizedProps,b.state=a.memoizedState,b.componentWillUnmount()}catch(c){Za(a,c)}}function zh(a){var b=a.ref;if(null!==b)if("function"===typeof b)try{b(null)}catch(c){Za(a,c)}else b.current=null}function nj(a,b){switch(b.tag){case 0:case 11:case 15:case 22:return;case 1:if(b.effectTag&256&&null!==a){var c=a.memoizedProps,d=a.memoizedState;a=b.stateNode;b=a.getSnapshotBeforeUpdate(b.elementType===
b.type?c:aa(b.type,c),d);a.__reactInternalSnapshotBeforeUpdate=b}return;case 3:case 5:case 6:case 4:case 17:return}throw Error(k(163));}function Ah(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.destroy;c.destroy=void 0;void 0!==d&&d()}c=c.next}while(c!==b)}}function Bh(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d()}c=c.next}while(c!==b)}}function oj(a,b,c,d){switch(c.tag){case 0:case 11:case 15:case 22:Bh(3,
c);return;case 1:a=c.stateNode;c.effectTag&4&&(null===b?a.componentDidMount():(d=c.elementType===c.type?b.memoizedProps:aa(c.type,b.memoizedProps),a.componentDidUpdate(d,b.memoizedState,a.__reactInternalSnapshotBeforeUpdate)));b=c.updateQueue;null!==b&&Wg(c,b,a);return;case 3:b=c.updateQueue;if(null!==b){a=null;if(null!==c.child)switch(c.child.tag){case 5:a=c.child.stateNode;break;case 1:a=c.child.stateNode}Wg(c,b,a)}return;case 5:a=c.stateNode;null===b&&c.effectTag&4&&lg(c.type,c.memoizedProps)&&
a.focus();return;case 6:return;case 4:return;case 12:return;case 13:null===c.memoizedState&&(c=c.alternate,null!==c&&(c=c.memoizedState,null!==c&&(c=c.dehydrated,null!==c&&bg(c))));return;case 19:case 17:case 20:case 21:return}throw Error(k(163));}function Ch(a,b,c){"function"===typeof Ne&&Ne(b);switch(b.tag){case 0:case 11:case 14:case 15:case 22:a=b.updateQueue;if(null!==a&&(a=a.lastEffect,null!==a)){var d=a.next;Da(97<c?97:c,function(){var a=d;do{var c=a.destroy;if(void 0!==c){var g=b;try{c()}catch(h){Za(g,
h)}}a=a.next}while(a!==d)})}break;case 1:zh(b);c=b.stateNode;"function"===typeof c.componentWillUnmount&&mj(b,c);break;case 5:zh(b);break;case 4:Dh(a,b,c)}}function Eh(a){var b=a.alternate;a.return=null;a.child=null;a.memoizedState=null;a.updateQueue=null;a.dependencies=null;a.alternate=null;a.firstEffect=null;a.lastEffect=null;a.pendingProps=null;a.memoizedProps=null;a.stateNode=null;null!==b&&Eh(b)}function Fh(a){return 5===a.tag||3===a.tag||4===a.tag}function Gh(a){a:{for(var b=a.return;null!==
b;){if(Fh(b)){var c=b;break a}b=b.return}throw Error(k(160));}b=c.stateNode;switch(c.tag){case 5:var d=!1;break;case 3:b=b.containerInfo;d=!0;break;case 4:b=b.containerInfo;d=!0;break;default:throw Error(k(161));}c.effectTag&16&&(Wb(b,""),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c.return||Fh(c.return)){c=null;break a}c=c.return}c.sibling.return=c.return;for(c=c.sibling;5!==c.tag&&6!==c.tag&&18!==c.tag;){if(c.effectTag&2)continue b;if(null===c.child||4===c.tag)continue b;
else c.child.return=c,c=c.child}if(!(c.effectTag&2)){c=c.stateNode;break a}}d?Oe(a,c,b):Pe(a,c,b)}function Oe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=uc));else if(4!==d&&(a=a.child,null!==a))for(Oe(a,b,c),a=a.sibling;null!==a;)Oe(a,b,c),a=a.sibling}
function Pe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Pe(a,b,c),a=a.sibling;null!==a;)Pe(a,b,c),a=a.sibling}function Dh(a,b,c){for(var d=b,e=!1,f,g;;){if(!e){e=d.return;a:for(;;){if(null===e)throw Error(k(160));f=e.stateNode;switch(e.tag){case 5:g=!1;break a;case 3:f=f.containerInfo;g=!0;break a;case 4:f=f.containerInfo;g=!0;break a}e=e.return}e=!0}if(5===d.tag||6===d.tag){a:for(var h=
a,m=d,n=c,l=m;;)if(Ch(h,l,n),null!==l.child&&4!==l.tag)l.child.return=l,l=l.child;else{if(l===m)break a;for(;null===l.sibling;){if(null===l.return||l.return===m)break a;l=l.return}l.sibling.return=l.return;l=l.sibling}g?(h=f,m=d.stateNode,8===h.nodeType?h.parentNode.removeChild(m):h.removeChild(m)):f.removeChild(d.stateNode)}else if(4===d.tag){if(null!==d.child){f=d.stateNode.containerInfo;g=!0;d.child.return=d;d=d.child;continue}}else if(Ch(a,d,c),null!==d.child){d.child.return=d;d=d.child;continue}if(d===
b)break;for(;null===d.sibling;){if(null===d.return||d.return===b)return;d=d.return;4===d.tag&&(e=!1)}d.sibling.return=d.return;d=d.sibling}}function Qe(a,b){switch(b.tag){case 0:case 11:case 14:case 15:case 22:Ah(3,b);return;case 1:return;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps,e=null!==a?a.memoizedProps:d;a=b.type;var f=b.updateQueue;b.updateQueue=null;if(null!==f){c[vc]=d;"input"===a&&"radio"===d.type&&null!=d.name&&If(c,d);Vd(a,e);b=Vd(a,d);for(e=0;e<f.length;e+=2){var g=f[e],
h=f[e+1];"style"===g?gg(c,h):"dangerouslySetInnerHTML"===g?xh(c,h):"children"===g?Wb(c,h):xd(c,g,h,b)}switch(a){case "input":Dd(c,d);break;case "textarea":Lf(c,d);break;case "select":b=c._wrapperState.wasMultiple,c._wrapperState.wasMultiple=!!d.multiple,a=d.value,null!=a?hb(c,!!d.multiple,a,!1):b!==!!d.multiple&&(null!=d.defaultValue?hb(c,!!d.multiple,d.defaultValue,!0):hb(c,!!d.multiple,d.multiple?[]:"",!1))}}}return;case 6:if(null===b.stateNode)throw Error(k(162));b.stateNode.nodeValue=b.memoizedProps;
return;case 3:b=b.stateNode;b.hydrate&&(b.hydrate=!1,bg(b.containerInfo));return;case 12:return;case 13:c=b;null===b.memoizedState?d=!1:(d=!0,c=b.child,Re=Y());if(null!==c)a:for(a=c;;){if(5===a.tag)f=a.stateNode,d?(f=f.style,"function"===typeof f.setProperty?f.setProperty("display","none","important"):f.display="none"):(f=a.stateNode,e=a.memoizedProps.style,e=void 0!==e&&null!==e&&e.hasOwnProperty("display")?e.display:null,f.style.display=fg("display",e));else if(6===a.tag)a.stateNode.nodeValue=d?
"":a.memoizedProps;else if(13===a.tag&&null!==a.memoizedState&&null===a.memoizedState.dehydrated){f=a.child.sibling;f.return=a;a=f;continue}else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===c)break;for(;null===a.sibling;){if(null===a.return||a.return===c)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}Hh(b);return;case 19:Hh(b);return;case 17:return}throw Error(k(163));}function Hh(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=
new pj);b.forEach(function(b){var d=qj.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}function Ih(a,b,c){c=Ea(c,null);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){cd||(cd=!0,Se=d);Me(a,b)};return c}function Jh(a,b,c){c=Ea(c,null);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){Me(a,b);return d(e)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){"function"!==typeof d&&
(null===La?La=new Set([this]):La.add(this),Me(a,b));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}function ka(){return(p&(ca|ma))!==H?1073741821-(Y()/10|0):0!==dd?dd:dd=1073741821-(Y()/10|0)}function Va(a,b,c){b=b.mode;if(0===(b&2))return 1073741823;var d=Cc();if(0===(b&4))return 99===d?1073741823:1073741822;if((p&ca)!==H)return P;if(null!==c)a=Fc(a,c.timeoutMs|0||5E3,250);else switch(d){case 99:a=1073741823;break;case 98:a=Fc(a,150,100);break;case 97:case 96:a=
Fc(a,5E3,250);break;case 95:a=2;break;default:throw Error(k(326));}null!==U&&a===P&&--a;return a}function ed(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);var d=a.return,e=null;if(null===d&&3===a.tag)e=a.stateNode;else for(;null!==d;){c=d.alternate;d.childExpirationTime<b&&(d.childExpirationTime=b);null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);if(null===d.return&&3===d.tag){e=d.stateNode;break}d=d.return}null!==e&&
(U===e&&(Kc(b),F===bd&&Ya(e,P)),yh(e,b));return e}function fd(a){var b=a.lastExpiredTime;if(0!==b)return b;b=a.firstPendingTime;if(!Kh(a,b))return b;var c=a.lastPingedTime;a=a.nextKnownPendingLevel;a=c>a?c:a;return 2>=a&&b!==a?0:a}function V(a){if(0!==a.lastExpiredTime)a.callbackExpirationTime=1073741823,a.callbackPriority=99,a.callbackNode=Og(Te.bind(null,a));else{var b=fd(a),c=a.callbackNode;if(0===b)null!==c&&(a.callbackNode=null,a.callbackExpirationTime=0,a.callbackPriority=90);else{var d=ka();
1073741823===b?d=99:1===b||2===b?d=95:(d=10*(1073741821-b)-10*(1073741821-d),d=0>=d?99:250>=d?98:5250>=d?97:95);if(null!==c){var e=a.callbackPriority;if(a.callbackExpirationTime===b&&e>=d)return;c!==Qg&&Rg(c)}a.callbackExpirationTime=b;a.callbackPriority=d;b=1073741823===b?Og(Te.bind(null,a)):Ng(d,Lh.bind(null,a),{timeout:10*(1073741821-b)-Y()});a.callbackNode=b}}}function Lh(a,b){dd=0;if(b)return b=ka(),Ue(a,b),V(a),null;var c=fd(a);if(0!==c){b=a.callbackNode;if((p&(ca|ma))!==H)throw Error(k(327));
xb();a===U&&c===P||$a(a,c);if(null!==t){var d=p;p|=ca;var e=Mh();do try{rj();break}catch(h){Nh(a,h)}while(1);le();p=d;gd.current=e;if(F===hd)throw b=id,$a(a,c),Ya(a,c),V(a),b;if(null===t)switch(e=a.finishedWork=a.current.alternate,a.finishedExpirationTime=c,d=F,U=null,d){case Xa:case hd:throw Error(k(345));case Oh:Ue(a,2<c?2:c);break;case ad:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(1073741823===ta&&(e=Re+Ph-Y(),10<e)){if(jd){var f=a.lastPingedTime;if(0===f||f>=c){a.lastPingedTime=
c;$a(a,c);break}}f=fd(a);if(0!==f&&f!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}a.timeoutHandle=We(ab.bind(null,a),e);break}ab(a);break;case bd:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(jd&&(e=a.lastPingedTime,0===e||e>=c)){a.lastPingedTime=c;$a(a,c);break}e=fd(a);if(0!==e&&e!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}1073741823!==Yb?d=10*(1073741821-Yb)-Y():1073741823===ta?d=0:(d=10*(1073741821-ta)-5E3,e=Y(),c=10*(1073741821-c)-e,d=e-d,0>d&&(d=0),d=
(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*sj(d/1960))-d,c<d&&(d=c));if(10<d){a.timeoutHandle=We(ab.bind(null,a),d);break}ab(a);break;case Xe:if(1073741823!==ta&&null!==kd){f=ta;var g=kd;d=g.busyMinDurationMs|0;0>=d?d=0:(e=g.busyDelayMs|0,f=Y()-(10*(1073741821-f)-(g.timeoutMs|0||5E3)),d=f<=e?0:e+d-f);if(10<d){Ya(a,c);a.timeoutHandle=We(ab.bind(null,a),d);break}}ab(a);break;default:throw Error(k(329));}V(a);if(a.callbackNode===b)return Lh.bind(null,a)}}return null}function Te(a){var b=
a.lastExpiredTime;b=0!==b?b:1073741823;if((p&(ca|ma))!==H)throw Error(k(327));xb();a===U&&b===P||$a(a,b);if(null!==t){var c=p;p|=ca;var d=Mh();do try{tj();break}catch(e){Nh(a,e)}while(1);le();p=c;gd.current=d;if(F===hd)throw c=id,$a(a,b),Ya(a,b),V(a),c;if(null!==t)throw Error(k(261));a.finishedWork=a.current.alternate;a.finishedExpirationTime=b;U=null;ab(a);V(a)}return null}function uj(){if(null!==bb){var a=bb;bb=null;a.forEach(function(a,c){Ue(c,a);V(c)});ha()}}function Qh(a,b){var c=p;p|=1;try{return a(b)}finally{p=
c,p===H&&ha()}}function Rh(a,b){var c=p;p&=-2;p|=Ye;try{return a(b)}finally{p=c,p===H&&ha()}}function $a(a,b){a.finishedWork=null;a.finishedExpirationTime=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,vj(c));if(null!==t)for(c=t.return;null!==c;){var d=c;switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&(q(G),q(B));break;case 3:tb();q(G);q(B);break;case 5:te(d);break;case 4:tb();break;case 13:q(D);break;case 19:q(D);break;case 10:me(d)}c=c.return}U=a;t=Sa(a.current,null);
P=b;F=Xa;id=null;Yb=ta=1073741823;kd=null;Xb=0;jd=!1}function Nh(a,b){do{try{le();Sc.current=Tc;if(Uc)for(var c=z.memoizedState;null!==c;){var d=c.queue;null!==d&&(d.pending=null);c=c.next}Ia=0;J=K=z=null;Uc=!1;if(null===t||null===t.return)return F=hd,id=b,t=null;a:{var e=a,f=t.return,g=t,h=b;b=P;g.effectTag|=2048;g.firstEffect=g.lastEffect=null;if(null!==h&&"object"===typeof h&&"function"===typeof h.then){var m=h;if(0===(g.mode&2)){var n=g.alternate;n?(g.updateQueue=n.updateQueue,g.memoizedState=
n.memoizedState,g.expirationTime=n.expirationTime):(g.updateQueue=null,g.memoizedState=null)}var l=0!==(D.current&1),k=f;do{var p;if(p=13===k.tag){var q=k.memoizedState;if(null!==q)p=null!==q.dehydrated?!0:!1;else{var w=k.memoizedProps;p=void 0===w.fallback?!1:!0!==w.unstable_avoidThisFallback?!0:l?!1:!0}}if(p){var y=k.updateQueue;if(null===y){var r=new Set;r.add(m);k.updateQueue=r}else y.add(m);if(0===(k.mode&2)){k.effectTag|=64;g.effectTag&=-2981;if(1===g.tag)if(null===g.alternate)g.tag=17;else{var O=
Ea(1073741823,null);O.tag=Jc;Fa(g,O)}g.expirationTime=1073741823;break a}h=void 0;g=b;var v=e.pingCache;null===v?(v=e.pingCache=new wj,h=new Set,v.set(m,h)):(h=v.get(m),void 0===h&&(h=new Set,v.set(m,h)));if(!h.has(g)){h.add(g);var x=xj.bind(null,e,m,g);m.then(x,x)}k.effectTag|=4096;k.expirationTime=b;break a}k=k.return}while(null!==k);h=Error((na(g.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display."+
Bd(g))}F!==Xe&&(F=Oh);h=Le(h,g);k=f;do{switch(k.tag){case 3:m=h;k.effectTag|=4096;k.expirationTime=b;var A=Ih(k,m,b);Ug(k,A);break a;case 1:m=h;var u=k.type,B=k.stateNode;if(0===(k.effectTag&64)&&("function"===typeof u.getDerivedStateFromError||null!==B&&"function"===typeof B.componentDidCatch&&(null===La||!La.has(B)))){k.effectTag|=4096;k.expirationTime=b;var H=Jh(k,m,b);Ug(k,H);break a}}k=k.return}while(null!==k)}t=Sh(t)}catch(cj){b=cj;continue}break}while(1)}function Mh(a){a=gd.current;gd.current=
Tc;return null===a?Tc:a}function Vg(a,b){a<ta&&2<a&&(ta=a);null!==b&&a<Yb&&2<a&&(Yb=a,kd=b)}function Kc(a){a>Xb&&(Xb=a)}function tj(){for(;null!==t;)t=Th(t)}function rj(){for(;null!==t&&!yj();)t=Th(t)}function Th(a){var b=zj(a.alternate,a,P);a.memoizedProps=a.pendingProps;null===b&&(b=Sh(a));Uh.current=null;return b}function Sh(a){t=a;do{var b=t.alternate;a=t.return;if(0===(t.effectTag&2048)){b=hj(b,t,P);if(1===P||1!==t.childExpirationTime){for(var c=0,d=t.child;null!==d;){var e=d.expirationTime,
f=d.childExpirationTime;e>c&&(c=e);f>c&&(c=f);d=d.sibling}t.childExpirationTime=c}if(null!==b)return b;null!==a&&0===(a.effectTag&2048)&&(null===a.firstEffect&&(a.firstEffect=t.firstEffect),null!==t.lastEffect&&(null!==a.lastEffect&&(a.lastEffect.nextEffect=t.firstEffect),a.lastEffect=t.lastEffect),1<t.effectTag&&(null!==a.lastEffect?a.lastEffect.nextEffect=t:a.firstEffect=t,a.lastEffect=t))}else{b=lj(t);if(null!==b)return b.effectTag&=2047,b;null!==a&&(a.firstEffect=a.lastEffect=null,a.effectTag|=
2048)}b=t.sibling;if(null!==b)return b;t=a}while(null!==t);F===Xa&&(F=Xe);return null}function Ve(a){var b=a.expirationTime;a=a.childExpirationTime;return b>a?b:a}function ab(a){var b=Cc();Da(99,Aj.bind(null,a,b));return null}function Aj(a,b){do xb();while(null!==Zb);if((p&(ca|ma))!==H)throw Error(k(327));var c=a.finishedWork,d=a.finishedExpirationTime;if(null===c)return null;a.finishedWork=null;a.finishedExpirationTime=0;if(c===a.current)throw Error(k(177));a.callbackNode=null;a.callbackExpirationTime=
0;a.callbackPriority=90;a.nextKnownPendingLevel=0;var e=Ve(c);a.firstPendingTime=e;d<=a.lastSuspendedTime?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:d<=a.firstSuspendedTime&&(a.firstSuspendedTime=d-1);d<=a.lastPingedTime&&(a.lastPingedTime=0);d<=a.lastExpiredTime&&(a.lastExpiredTime=0);a===U&&(t=U=null,P=0);1<c.effectTag?null!==c.lastEffect?(c.lastEffect.nextEffect=c,e=c.firstEffect):e=c:e=c.firstEffect;if(null!==e){var f=p;p|=ma;Uh.current=null;Ze=tc;var g=kg();if(Xd(g)){if("selectionStart"in
g)var h={start:g.selectionStart,end:g.selectionEnd};else a:{h=(h=g.ownerDocument)&&h.defaultView||window;var m=h.getSelection&&h.getSelection();if(m&&0!==m.rangeCount){h=m.anchorNode;var n=m.anchorOffset,q=m.focusNode;m=m.focusOffset;try{h.nodeType,q.nodeType}catch(sb){h=null;break a}var ba=0,w=-1,y=-1,B=0,D=0,r=g,z=null;b:for(;;){for(var v;;){r!==h||0!==n&&3!==r.nodeType||(w=ba+n);r!==q||0!==m&&3!==r.nodeType||(y=ba+m);3===r.nodeType&&(ba+=r.nodeValue.length);if(null===(v=r.firstChild))break;z=r;
r=v}for(;;){if(r===g)break b;z===h&&++B===n&&(w=ba);z===q&&++D===m&&(y=ba);if(null!==(v=r.nextSibling))break;r=z;z=r.parentNode}r=v}h=-1===w||-1===y?null:{start:w,end:y}}else h=null}h=h||{start:0,end:0}}else h=null;$e={activeElementDetached:null,focusedElem:g,selectionRange:h};tc=!1;l=e;do try{Bj()}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=e;do try{for(g=a,h=b;null!==l;){var x=l.effectTag;x&16&&Wb(l.stateNode,"");if(x&128){var A=l.alternate;if(null!==A){var u=
A.ref;null!==u&&("function"===typeof u?u(null):u.current=null)}}switch(x&1038){case 2:Gh(l);l.effectTag&=-3;break;case 6:Gh(l);l.effectTag&=-3;Qe(l.alternate,l);break;case 1024:l.effectTag&=-1025;break;case 1028:l.effectTag&=-1025;Qe(l.alternate,l);break;case 4:Qe(l.alternate,l);break;case 8:n=l,Dh(g,n,h),Eh(n)}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);u=$e;A=kg();x=u.focusedElem;h=u.selectionRange;if(A!==x&&x&&x.ownerDocument&&jg(x.ownerDocument.documentElement,
x)){null!==h&&Xd(x)&&(A=h.start,u=h.end,void 0===u&&(u=A),"selectionStart"in x?(x.selectionStart=A,x.selectionEnd=Math.min(u,x.value.length)):(u=(A=x.ownerDocument||document)&&A.defaultView||window,u.getSelection&&(u=u.getSelection(),n=x.textContent.length,g=Math.min(h.start,n),h=void 0===h.end?g:Math.min(h.end,n),!u.extend&&g>h&&(n=h,h=g,g=n),n=ig(x,g),q=ig(x,h),n&&q&&(1!==u.rangeCount||u.anchorNode!==n.node||u.anchorOffset!==n.offset||u.focusNode!==q.node||u.focusOffset!==q.offset)&&(A=A.createRange(),
A.setStart(n.node,n.offset),u.removeAllRanges(),g>h?(u.addRange(A),u.extend(q.node,q.offset)):(A.setEnd(q.node,q.offset),u.addRange(A))))));A=[];for(u=x;u=u.parentNode;)1===u.nodeType&&A.push({element:u,left:u.scrollLeft,top:u.scrollTop});"function"===typeof x.focus&&x.focus();for(x=0;x<A.length;x++)u=A[x],u.element.scrollLeft=u.left,u.element.scrollTop=u.top}tc=!!Ze;$e=Ze=null;a.current=c;l=e;do try{for(x=a;null!==l;){var F=l.effectTag;F&36&&oj(x,l.alternate,l);if(F&128){A=void 0;var E=l.ref;if(null!==
E){var G=l.stateNode;switch(l.tag){case 5:A=G;break;default:A=G}"function"===typeof E?E(A):E.current=A}}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=null;Cj();p=f}else a.current=c;if(ld)ld=!1,Zb=a,$b=b;else for(l=e;null!==l;)b=l.nextEffect,l.nextEffect=null,l=b;b=a.firstPendingTime;0===b&&(La=null);1073741823===b?a===af?ac++:(ac=0,af=a):ac=0;"function"===typeof bf&&bf(c.stateNode,d);V(a);if(cd)throw cd=!1,a=Se,Se=null,a;if((p&Ye)!==H)return null;
ha();return null}function Bj(){for(;null!==l;){var a=l.effectTag;0!==(a&256)&&nj(l.alternate,l);0===(a&512)||ld||(ld=!0,Ng(97,function(){xb();return null}));l=l.nextEffect}}function xb(){if(90!==$b){var a=97<$b?97:$b;$b=90;return Da(a,Dj)}}function Dj(){if(null===Zb)return!1;var a=Zb;Zb=null;if((p&(ca|ma))!==H)throw Error(k(331));var b=p;p|=ma;for(a=a.current.firstEffect;null!==a;){try{var c=a;if(0!==(c.effectTag&512))switch(c.tag){case 0:case 11:case 15:case 22:Ah(5,c),Bh(5,c)}}catch(d){if(null===
a)throw Error(k(330));Za(a,d)}c=a.nextEffect;a.nextEffect=null;a=c}p=b;ha();return!0}function Vh(a,b,c){b=Le(c,b);b=Ih(a,b,1073741823);Fa(a,b);a=ed(a,1073741823);null!==a&&V(a)}function Za(a,b){if(3===a.tag)Vh(a,a,b);else for(var c=a.return;null!==c;){if(3===c.tag){Vh(c,a,b);break}else if(1===c.tag){var d=c.stateNode;if("function"===typeof c.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===La||!La.has(d))){a=Le(b,a);a=Jh(c,a,1073741823);Fa(c,a);c=ed(c,1073741823);null!==
c&&V(c);break}}c=c.return}}function xj(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);U===a&&P===c?F===bd||F===ad&&1073741823===ta&&Y()-Re<Ph?$a(a,P):jd=!0:Kh(a,c)&&(b=a.lastPingedTime,0!==b&&b<c||(a.lastPingedTime=c,V(a)))}function qj(a,b){var c=a.stateNode;null!==c&&c.delete(b);b=0;0===b&&(b=ka(),b=Va(b,a,null));a=ed(a,b);null!==a&&V(a)}function Ej(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return!0;try{var c=
b.inject(a);bf=function(a,e){try{b.onCommitFiberRoot(c,a,void 0,64===(a.current.effectTag&64))}catch(f){}};Ne=function(a){try{b.onCommitFiberUnmount(c,a)}catch(e){}}}catch(d){}return!0}function Fj(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=
null;this.childExpirationTime=this.expirationTime=0;this.alternate=null}function Ge(a){a=a.prototype;return!(!a||!a.isReactComponent)}function Gj(a){if("function"===typeof a)return Ge(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===zd)return 11;if(a===Ad)return 14}return 2}function Sa(a,b){var c=a.alternate;null===c?(c=la(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.effectTag=0,c.nextEffect=null,c.firstEffect=
null,c.lastEffect=null);c.childExpirationTime=a.childExpirationTime;c.expirationTime=a.expirationTime;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{expirationTime:b.expirationTime,firstContext:b.firstContext,responders:b.responders};c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}function Oc(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)Ge(a)&&(g=1);else if("string"===typeof a)g=
5;else a:switch(a){case Ma:return Ha(c.children,e,f,b);case Hj:g=8;e|=7;break;case Af:g=8;e|=1;break;case kc:return a=la(12,c,b,e|8),a.elementType=kc,a.type=kc,a.expirationTime=f,a;case lc:return a=la(13,c,b,e),a.type=lc,a.elementType=lc,a.expirationTime=f,a;case yd:return a=la(19,c,b,e),a.elementType=yd,a.expirationTime=f,a;default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case Cf:g=10;break a;case Bf:g=9;break a;case zd:g=11;break a;case Ad:g=14;break a;case Ef:g=16;d=null;break a;case Df:g=
22;break a}throw Error(k(130,null==a?a:typeof a,""));}b=la(g,c,b,e);b.elementType=a;b.type=d;b.expirationTime=f;return b}function Ha(a,b,c,d){a=la(7,a,d,b);a.expirationTime=c;return a}function qe(a,b,c){a=la(6,a,null,b);a.expirationTime=c;return a}function re(a,b,c){b=la(4,null!==a.children?a.children:[],a.key,b);b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}function Ij(a,b,c){this.tag=b;this.current=null;this.containerInfo=
a;this.pingCache=this.pendingChildren=null;this.finishedExpirationTime=0;this.finishedWork=null;this.timeoutHandle=-1;this.pendingContext=this.context=null;this.hydrate=c;this.callbackNode=null;this.callbackPriority=90;this.lastExpiredTime=this.lastPingedTime=this.nextKnownPendingLevel=this.lastSuspendedTime=this.firstSuspendedTime=this.firstPendingTime=0}function Kh(a,b){var c=a.firstSuspendedTime;a=a.lastSuspendedTime;return 0!==c&&c>=b&&a<=b}function Ya(a,b){var c=a.firstSuspendedTime,d=a.lastSuspendedTime;
c<b&&(a.firstSuspendedTime=b);if(d>b||0===c)a.lastSuspendedTime=b;b<=a.lastPingedTime&&(a.lastPingedTime=0);b<=a.lastExpiredTime&&(a.lastExpiredTime=0)}function yh(a,b){b>a.firstPendingTime&&(a.firstPendingTime=b);var c=a.firstSuspendedTime;0!==c&&(b>=c?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:b>=a.lastSuspendedTime&&(a.lastSuspendedTime=b+1),b>a.nextKnownPendingLevel&&(a.nextKnownPendingLevel=b))}function Ue(a,b){var c=a.lastExpiredTime;if(0===c||c>b)a.lastExpiredTime=b}
function md(a,b,c,d){var e=b.current,f=ka(),g=Vb.suspense;f=Va(f,e,g);a:if(c){c=c._reactInternalFiber;b:{if(Na(c)!==c||1!==c.tag)throw Error(k(170));var h=c;do{switch(h.tag){case 3:h=h.stateNode.context;break b;case 1:if(N(h.type)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}}h=h.return}while(null!==h);throw Error(k(171));}if(1===c.tag){var m=c.type;if(N(m)){c=Gg(c,m,h);break a}}c=h}else c=Ca;null===b.context?b.context=c:b.pendingContext=c;b=Ea(f,g);b.payload={element:a};d=void 0===
d?null:d;null!==d&&(b.callback=d);Fa(e,b);Ja(e,f);return f}function cf(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function Wh(a,b){a=a.memoizedState;null!==a&&null!==a.dehydrated&&a.retryTime<b&&(a.retryTime=b)}function df(a,b){Wh(a,b);(a=a.alternate)&&Wh(a,b)}function ef(a,b,c){c=null!=c&&!0===c.hydrate;var d=new Ij(a,b,c),e=la(3,null,null,2===b?7:1===b?3:0);d.current=e;e.stateNode=d;ne(e);a[Lb]=d.current;c&&0!==b&&
xi(a,9===a.nodeType?a:a.ownerDocument);this._internalRoot=d}function bc(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function Jj(a,b){b||(b=a?9===a.nodeType?a.documentElement:a.firstChild:null,b=!(!b||1!==b.nodeType||!b.hasAttribute("data-reactroot")));if(!b)for(var c;c=a.lastChild;)a.removeChild(c);return new ef(a,0,b?{hydrate:!0}:void 0)}function nd(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f._internalRoot;
if("function"===typeof e){var h=e;e=function(){var a=cf(g);h.call(a)}}md(b,g,a,e)}else{f=c._reactRootContainer=Jj(c,d);g=f._internalRoot;if("function"===typeof e){var m=e;e=function(){var a=cf(g);m.call(a)}}Rh(function(){md(b,g,a,e)})}return cf(g)}function Kj(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:gb,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}function Xh(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;
if(!bc(b))throw Error(k(200));return Kj(a,b,null,c)}if(!ea)throw Error(k(227));var ki=function(a,b,c,d,e,f,g,h,m){var n=Array.prototype.slice.call(arguments,3);try{b.apply(c,n)}catch(C){this.onError(C)}},yb=!1,gc=null,hc=!1,pd=null,li={onError:function(a){yb=!0;gc=a}},td=null,rf=null,mf=null,ic=null,cb={},jc=[],qd={},db={},rd={},wa=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),M=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.assign,
sd=null,eb=null,fb=null,ee=function(a,b){return a(b)},eg=function(a,b,c,d,e){return a(b,c,d,e)},vd=function(){},vf=ee,Oa=!1,wd=!1,Z=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Scheduler,Lj=Z.unstable_cancelCallback,ff=Z.unstable_now,$f=Z.unstable_scheduleCallback,Mj=Z.unstable_shouldYield,Yh=Z.unstable_requestPaint,Pd=Z.unstable_runWithPriority,Nj=Z.unstable_getCurrentPriorityLevel,Oj=Z.unstable_ImmediatePriority,Zh=Z.unstable_UserBlockingPriority,ag=Z.unstable_NormalPriority,Pj=Z.unstable_LowPriority,
Qj=Z.unstable_IdlePriority,oi=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,wf=Object.prototype.hasOwnProperty,yf={},xf={},E={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){E[a]=
new L(a,0,!1,a,null,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];E[b]=new L(b,1,!1,a[1],null,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){E[a]=new L(a,2,!1,a.toLowerCase(),null,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){E[a]=new L(a,2,!1,a,null,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){E[a]=
new L(a,3,!1,a.toLowerCase(),null,!1)});["checked","multiple","muted","selected"].forEach(function(a){E[a]=new L(a,3,!0,a,null,!1)});["capture","download"].forEach(function(a){E[a]=new L(a,4,!1,a,null,!1)});["cols","rows","size","span"].forEach(function(a){E[a]=new L(a,6,!1,a,null,!1)});["rowSpan","start"].forEach(function(a){E[a]=new L(a,5,!1,a.toLowerCase(),null,!1)});var gf=/[\-:]([a-z])/g,hf=function(a){return a[1].toUpperCase()};"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=
a.replace(gf,hf);E[b]=new L(b,1,!1,a,null,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/1999/xlink",!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1)});["tabIndex","crossOrigin"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!1)});E.xlinkHref=new L("xlinkHref",1,
!1,"xlink:href","http://www.w3.org/1999/xlink",!0);["src","href","action","formAction"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!0)});var da=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;da.hasOwnProperty("ReactCurrentDispatcher")||(da.ReactCurrentDispatcher={current:null});da.hasOwnProperty("ReactCurrentBatchConfig")||(da.ReactCurrentBatchConfig={suspense:null});var si=/^(.*)[\\\/]/,Q="function"===typeof Symbol&&Symbol.for,Pc=Q?Symbol.for("react.element"):60103,gb=Q?Symbol.for("react.portal"):
60106,Ma=Q?Symbol.for("react.fragment"):60107,Af=Q?Symbol.for("react.strict_mode"):60108,kc=Q?Symbol.for("react.profiler"):60114,Cf=Q?Symbol.for("react.provider"):60109,Bf=Q?Symbol.for("react.context"):60110,Hj=Q?Symbol.for("react.concurrent_mode"):60111,zd=Q?Symbol.for("react.forward_ref"):60112,lc=Q?Symbol.for("react.suspense"):60113,yd=Q?Symbol.for("react.suspense_list"):60120,Ad=Q?Symbol.for("react.memo"):60115,Ef=Q?Symbol.for("react.lazy"):60116,Df=Q?Symbol.for("react.block"):60121,zf="function"===
typeof Symbol&&Symbol.iterator,od,xh=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if("http://www.w3.org/2000/svg"!==a.namespaceURI||"innerHTML"in a)a.innerHTML=b;else{od=od||document.createElement("div");od.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=od.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}}),Wb=function(a,
b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b},ib={animationend:nc("Animation","AnimationEnd"),animationiteration:nc("Animation","AnimationIteration"),animationstart:nc("Animation","AnimationStart"),transitionend:nc("Transition","TransitionEnd")},Id={},Of={};wa&&(Of=document.createElement("div").style,"AnimationEvent"in window||(delete ib.animationend.animation,delete ib.animationiteration.animation,delete ib.animationstart.animation),"TransitionEvent"in
window||delete ib.transitionend.transition);var $h=oc("animationend"),ai=oc("animationiteration"),bi=oc("animationstart"),ci=oc("transitionend"),Db="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Pf=new ("function"===typeof WeakMap?WeakMap:Map),Ab=null,wi=function(a){if(a){var b=a._dispatchListeners,c=a._dispatchInstances;
if(Array.isArray(b))for(var d=0;d<b.length&&!a.isPropagationStopped();d++)lf(a,b[d],c[d]);else b&&lf(a,b,c);a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a)}},qc=[],Rd=!1,fa=[],xa=null,ya=null,za=null,Eb=new Map,Fb=new Map,Jb=[],Nd="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput close cancel copy cut paste click change contextmenu reset submit".split(" "),
yi="focus blur dragenter dragleave mouseover mouseout pointerover pointerout gotpointercapture lostpointercapture".split(" "),dg={},cg=new Map,Td=new Map,Rj=["abort","abort",$h,"animationEnd",ai,"animationIteration",bi,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata",
"loadstart","loadStart","lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking","seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",ci,"transitionEnd","waiting","waiting"];Sd("blur blur cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focus focus input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),
0);Sd("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1);Sd(Rj,2);(function(a,b){for(var c=0;c<a.length;c++)Td.set(a[c],b)})("change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),0);var Hi=Zh,Gi=Pd,tc=!0,Kb={animationIterationCount:!0,
borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,
strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Sj=["Webkit","ms","Moz","O"];Object.keys(Kb).forEach(function(a){Sj.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);Kb[b]=Kb[a]})});var Ii=M({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0}),ng="$",og="/$",$d="$?",Zd="$!",Ze=null,$e=null,We="function"===typeof setTimeout?setTimeout:void 0,vj="function"===
typeof clearTimeout?clearTimeout:void 0,jf=Math.random().toString(36).slice(2),Aa="__reactInternalInstance$"+jf,vc="__reactEventHandlers$"+jf,Lb="__reactContainere$"+jf,Ba=null,ce=null,wc=null;M(R.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=xc)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==
typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=xc)},persist:function(){this.isPersistent=xc},isPersistent:yc,destructor:function(){var a=this.constructor.Interface,b;for(b in a)this[b]=null;this.nativeEvent=this._targetInst=this.dispatchConfig=null;this.isPropagationStopped=this.isDefaultPrevented=yc;this._dispatchInstances=this._dispatchListeners=null}});R.Interface={type:null,target:null,currentTarget:function(){return null},eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||
Date.now()},defaultPrevented:null,isTrusted:null};R.extend=function(a){function b(){return c.apply(this,arguments)}var c=this,d=function(){};d.prototype=c.prototype;d=new d;M(d,b.prototype);b.prototype=d;b.prototype.constructor=b;b.Interface=M({},c.Interface,a);b.extend=c.extend;sg(b);return b};sg(R);var Tj=R.extend({data:null}),Uj=R.extend({data:null}),Ni=[9,13,27,32],de=wa&&"CompositionEvent"in window,cc=null;wa&&"documentMode"in document&&(cc=document.documentMode);var Vj=wa&&"TextEvent"in window&&
!cc,xg=wa&&(!de||cc&&8<cc&&11>=cc),wg=String.fromCharCode(32),ua={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["compositionend","keypress","textInput","paste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"blur compositionend keydown keypress keyup mousedown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",captured:"onCompositionStartCapture"},
dependencies:"blur compositionstart keydown keypress keyup mousedown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"blur compositionupdate keydown keypress keyup mousedown".split(" ")}},vg=!1,mb=!1,Wj={eventTypes:ua,extractEvents:function(a,b,c,d,e){var f;if(de)b:{switch(a){case "compositionstart":var g=ua.compositionStart;break b;case "compositionend":g=ua.compositionEnd;break b;case "compositionupdate":g=
ua.compositionUpdate;break b}g=void 0}else mb?tg(a,c)&&(g=ua.compositionEnd):"keydown"===a&&229===c.keyCode&&(g=ua.compositionStart);g?(xg&&"ko"!==c.locale&&(mb||g!==ua.compositionStart?g===ua.compositionEnd&&mb&&(f=rg()):(Ba=d,ce="value"in Ba?Ba.value:Ba.textContent,mb=!0)),e=Tj.getPooled(g,b,c,d),f?e.data=f:(f=ug(c),null!==f&&(e.data=f)),lb(e),f=e):f=null;(a=Vj?Oi(a,c):Pi(a,c))?(b=Uj.getPooled(ua.beforeInput,b,c,d),b.data=a,lb(b)):b=null;return null===f?b:null===b?f:[f,b]}},Qi={color:!0,date:!0,
datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0},Ag={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"blur change click focus input keydown keyup selectionchange".split(" ")}},Mb=null,Nb=null,kf=!1;wa&&(kf=Tf("input")&&(!document.documentMode||9<document.documentMode));var Xj={eventTypes:Ag,_isInputEventSupported:kf,extractEvents:function(a,b,c,d,e){e=b?Pa(b):window;var f=
e.nodeName&&e.nodeName.toLowerCase();if("select"===f||"input"===f&&"file"===e.type)var g=Si;else if(yg(e))if(kf)g=Wi;else{g=Ui;var h=Ti}else(f=e.nodeName)&&"input"===f.toLowerCase()&&("checkbox"===e.type||"radio"===e.type)&&(g=Vi);if(g&&(g=g(a,b)))return zg(g,c,d);h&&h(a,e,b);"blur"===a&&(a=e._wrapperState)&&a.controlled&&"number"===e.type&&Ed(e,"number",e.value)}},dc=R.extend({view:null,detail:null}),Yi={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"},di=0,ei=0,fi=!1,gi=!1,ec=dc.extend({screenX:null,
screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:fe,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)},movementX:function(a){if("movementX"in a)return a.movementX;var b=di;di=a.screenX;return fi?"mousemove"===a.type?a.screenX-b:0:(fi=!0,0)},movementY:function(a){if("movementY"in a)return a.movementY;var b=ei;ei=a.screenY;return gi?"mousemove"===
a.type?a.screenY-b:0:(gi=!0,0)}}),hi=ec.extend({pointerId:null,width:null,height:null,pressure:null,tangentialPressure:null,tiltX:null,tiltY:null,twist:null,pointerType:null,isPrimary:null}),fc={mouseEnter:{registrationName:"onMouseEnter",dependencies:["mouseout","mouseover"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["mouseout","mouseover"]},pointerEnter:{registrationName:"onPointerEnter",dependencies:["pointerout","pointerover"]},pointerLeave:{registrationName:"onPointerLeave",dependencies:["pointerout",
"pointerover"]}},Yj={eventTypes:fc,extractEvents:function(a,b,c,d,e){var f="mouseover"===a||"pointerover"===a,g="mouseout"===a||"pointerout"===a;if(f&&0===(e&32)&&(c.relatedTarget||c.fromElement)||!g&&!f)return null;f=d.window===d?d:(f=d.ownerDocument)?f.defaultView||f.parentWindow:window;if(g){if(g=b,b=(b=c.relatedTarget||c.toElement)?Bb(b):null,null!==b){var h=Na(b);if(b!==h||5!==b.tag&&6!==b.tag)b=null}}else g=null;if(g===b)return null;if("mouseout"===a||"mouseover"===a){var m=ec;var n=fc.mouseLeave;
var l=fc.mouseEnter;var k="mouse"}else if("pointerout"===a||"pointerover"===a)m=hi,n=fc.pointerLeave,l=fc.pointerEnter,k="pointer";a=null==g?f:Pa(g);f=null==b?f:Pa(b);n=m.getPooled(n,g,c,d);n.type=k+"leave";n.target=a;n.relatedTarget=f;c=m.getPooled(l,b,c,d);c.type=k+"enter";c.target=f;c.relatedTarget=a;d=g;k=b;if(d&&k)a:{m=d;l=k;g=0;for(a=m;a;a=pa(a))g++;a=0;for(b=l;b;b=pa(b))a++;for(;0<g-a;)m=pa(m),g--;for(;0<a-g;)l=pa(l),a--;for(;g--;){if(m===l||m===l.alternate)break a;m=pa(m);l=pa(l)}m=null}else m=
null;l=m;for(m=[];d&&d!==l;){g=d.alternate;if(null!==g&&g===l)break;m.push(d);d=pa(d)}for(d=[];k&&k!==l;){g=k.alternate;if(null!==g&&g===l)break;d.push(k);k=pa(k)}for(k=0;k<m.length;k++)be(m[k],"bubbled",n);for(k=d.length;0<k--;)be(d[k],"captured",c);return 0===(e&64)?[n]:[n,c]}},Qa="function"===typeof Object.is?Object.is:Zi,$i=Object.prototype.hasOwnProperty,Zj=wa&&"documentMode"in document&&11>=document.documentMode,Eg={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},
dependencies:"blur contextmenu dragend focus keydown keyup mousedown mouseup selectionchange".split(" ")}},nb=null,he=null,Pb=null,ge=!1,ak={eventTypes:Eg,extractEvents:function(a,b,c,d,e,f){e=f||(d.window===d?d.document:9===d.nodeType?d:d.ownerDocument);if(!(f=!e)){a:{e=Jd(e);f=rd.onSelect;for(var g=0;g<f.length;g++)if(!e.has(f[g])){e=!1;break a}e=!0}f=!e}if(f)return null;e=b?Pa(b):window;switch(a){case "focus":if(yg(e)||"true"===e.contentEditable)nb=e,he=b,Pb=null;break;case "blur":Pb=he=nb=null;
break;case "mousedown":ge=!0;break;case "contextmenu":case "mouseup":case "dragend":return ge=!1,Dg(c,d);case "selectionchange":if(Zj)break;case "keydown":case "keyup":return Dg(c,d)}return null}},bk=R.extend({animationName:null,elapsedTime:null,pseudoElement:null}),ck=R.extend({clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),dk=dc.extend({relatedTarget:null}),ek={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",
Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},fk={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",
224:"Meta"},gk=dc.extend({key:function(a){if(a.key){var b=ek[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=Ac(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?fk[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:fe,charCode:function(a){return"keypress"===a.type?Ac(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===
a.type?Ac(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),hk=ec.extend({dataTransfer:null}),ik=dc.extend({touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:fe}),jk=R.extend({propertyName:null,elapsedTime:null,pseudoElement:null}),kk=ec.extend({deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?
-a.wheelDelta:0},deltaZ:null,deltaMode:null}),lk={eventTypes:dg,extractEvents:function(a,b,c,d,e){e=cg.get(a);if(!e)return null;switch(a){case "keypress":if(0===Ac(c))return null;case "keydown":case "keyup":a=gk;break;case "blur":case "focus":a=dk;break;case "click":if(2===c.button)return null;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":a=ec;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":a=
hk;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":a=ik;break;case $h:case ai:case bi:a=bk;break;case ci:a=jk;break;case "scroll":a=dc;break;case "wheel":a=kk;break;case "copy":case "cut":case "paste":a=ck;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":a=hi;break;default:a=R}b=a.getPooled(e,b,c,d);lb(b);return b}};(function(a){if(ic)throw Error(k(101));
ic=Array.prototype.slice.call(a);nf()})("ResponderEventPlugin SimpleEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));(function(a,b,c){td=a;rf=b;mf=c})(ae,Hb,Pa);pf({SimpleEventPlugin:lk,EnterLeaveEventPlugin:Yj,ChangeEventPlugin:Xj,SelectEventPlugin:ak,BeforeInputEventPlugin:Wj});var ie=[],ob=-1,Ca={},B={current:Ca},G={current:!1},Ra=Ca,bj=Pd,je=$f,Rg=Lj,aj=Nj,Dc=Oj,Ig=Zh,Jg=ag,Kg=Pj,Lg=Qj,Qg={},yj=Mj,Cj=void 0!==Yh?Yh:function(){},qa=null,
Ec=null,ke=!1,ii=ff(),Y=1E4>ii?ff:function(){return ff()-ii},Ic={current:null},Hc=null,qb=null,Gc=null,Tg=0,Jc=2,Ga=!1,Vb=da.ReactCurrentBatchConfig,$g=(new ea.Component).refs,Mc={isMounted:function(a){return(a=a._reactInternalFiber)?Na(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;d=Va(d,a,e);e=Ea(d,e);e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueReplaceState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;
d=Va(d,a,e);e=Ea(d,e);e.tag=1;e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueForceUpdate:function(a,b){a=a._reactInternalFiber;var c=ka(),d=Vb.suspense;c=Va(c,a,d);d=Ea(c,d);d.tag=Jc;void 0!==b&&null!==b&&(d.callback=b);Fa(a,d);Ja(a,c)}},Qc=Array.isArray,wb=ah(!0),Fe=ah(!1),Sb={},ja={current:Sb},Ub={current:Sb},Tb={current:Sb},D={current:0},Sc=da.ReactCurrentDispatcher,X=da.ReactCurrentBatchConfig,Ia=0,z=null,K=null,J=null,Uc=!1,Tc={readContext:W,useCallback:S,useContext:S,
useEffect:S,useImperativeHandle:S,useLayoutEffect:S,useMemo:S,useReducer:S,useRef:S,useState:S,useDebugValue:S,useResponder:S,useDeferredValue:S,useTransition:S},dj={readContext:W,useCallback:ih,useContext:W,useEffect:eh,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ze(4,2,gh.bind(null,b,a),c)},useLayoutEffect:function(a,b){return ze(4,2,a,b)},useMemo:function(a,b){var c=ub();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=
ub();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a=d.queue={pending:null,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};a=a.dispatch=ch.bind(null,z,a);return[d.memoizedState,a]},useRef:function(a){var b=ub();a={current:a};return b.memoizedState=a},useState:xe,useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=xe(a),d=c[0],e=c[1];eh(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=
xe(!1),c=b[0];b=b[1];return[ih(Ce.bind(null,b,a),[b,a]),c]}},ej={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Vc,useRef:dh,useState:function(a){return Vc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Vc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Vc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,
b,a),[b,a]),c]}},fj={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Wc,useRef:dh,useState:function(a){return Wc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Wc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Wc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,b,a),[b,a]),c]}},ra=null,Ka=null,Wa=
!1,gj=da.ReactCurrentOwner,ia=!1,Je={dehydrated:null,retryTime:0};var jj=function(a,b,c,d){for(c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};var wh=function(a){};var ij=function(a,b,c,d,e){var f=a.memoizedProps;if(f!==d){var g=b.stateNode;Ta(ja.current);a=null;switch(c){case "input":f=
Cd(g,f);d=Cd(g,d);a=[];break;case "option":f=Fd(g,f);d=Fd(g,d);a=[];break;case "select":f=M({},f,{value:void 0});d=M({},d,{value:void 0});a=[];break;case "textarea":f=Gd(g,f);d=Gd(g,d);a=[];break;default:"function"!==typeof f.onClick&&"function"===typeof d.onClick&&(g.onclick=uc)}Ud(c,d);var h,m;c=null;for(h in f)if(!d.hasOwnProperty(h)&&f.hasOwnProperty(h)&&null!=f[h])if("style"===h)for(m in g=f[h],g)g.hasOwnProperty(m)&&(c||(c={}),c[m]="");else"dangerouslySetInnerHTML"!==h&&"children"!==h&&"suppressContentEditableWarning"!==
h&&"suppressHydrationWarning"!==h&&"autoFocus"!==h&&(db.hasOwnProperty(h)?a||(a=[]):(a=a||[]).push(h,null));for(h in d){var k=d[h];g=null!=f?f[h]:void 0;if(d.hasOwnProperty(h)&&k!==g&&(null!=k||null!=g))if("style"===h)if(g){for(m in g)!g.hasOwnProperty(m)||k&&k.hasOwnProperty(m)||(c||(c={}),c[m]="");for(m in k)k.hasOwnProperty(m)&&g[m]!==k[m]&&(c||(c={}),c[m]=k[m])}else c||(a||(a=[]),a.push(h,c)),c=k;else"dangerouslySetInnerHTML"===h?(k=k?k.__html:void 0,g=g?g.__html:void 0,null!=k&&g!==k&&(a=a||
[]).push(h,k)):"children"===h?g===k||"string"!==typeof k&&"number"!==typeof k||(a=a||[]).push(h,""+k):"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&(db.hasOwnProperty(h)?(null!=k&&oa(e,h),a||g===k||(a=[])):(a=a||[]).push(h,k))}c&&(a=a||[]).push("style",c);e=a;if(b.updateQueue=e)b.effectTag|=4}};var kj=function(a,b,c,d){c!==d&&(b.effectTag|=4)};var pj="function"===typeof WeakSet?WeakSet:Set,wj="function"===typeof WeakMap?WeakMap:Map,sj=Math.ceil,gd=da.ReactCurrentDispatcher,
Uh=da.ReactCurrentOwner,H=0,Ye=8,ca=16,ma=32,Xa=0,hd=1,Oh=2,ad=3,bd=4,Xe=5,p=H,U=null,t=null,P=0,F=Xa,id=null,ta=1073741823,Yb=1073741823,kd=null,Xb=0,jd=!1,Re=0,Ph=500,l=null,cd=!1,Se=null,La=null,ld=!1,Zb=null,$b=90,bb=null,ac=0,af=null,dd=0,Ja=function(a,b){if(50<ac)throw ac=0,af=null,Error(k(185));a=ed(a,b);if(null!==a){var c=Cc();1073741823===b?(p&Ye)!==H&&(p&(ca|ma))===H?Te(a):(V(a),p===H&&ha()):V(a);(p&4)===H||98!==c&&99!==c||(null===bb?bb=new Map([[a,b]]):(c=bb.get(a),(void 0===c||c>b)&&bb.set(a,
b)))}};var zj=function(a,b,c){var d=b.expirationTime;if(null!==a){var e=b.pendingProps;if(a.memoizedProps!==e||G.current)ia=!0;else{if(d<c){ia=!1;switch(b.tag){case 3:sh(b);Ee();break;case 5:bh(b);if(b.mode&4&&1!==c&&e.hidden)return b.expirationTime=b.childExpirationTime=1,null;break;case 1:N(b.type)&&Bc(b);break;case 4:se(b,b.stateNode.containerInfo);break;case 10:d=b.memoizedProps.value;e=b.type._context;y(Ic,e._currentValue);e._currentValue=d;break;case 13:if(null!==b.memoizedState){d=b.child.childExpirationTime;
if(0!==d&&d>=c)return th(a,b,c);y(D,D.current&1);b=sa(a,b,c);return null!==b?b.sibling:null}y(D,D.current&1);break;case 19:d=b.childExpirationTime>=c;if(0!==(a.effectTag&64)){if(d)return vh(a,b,c);b.effectTag|=64}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null);y(D,D.current);if(!d)return null}return sa(a,b,c)}ia=!1}}else ia=!1;b.expirationTime=0;switch(b.tag){case 2:d=b.type;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;e=pb(b,B.current);rb(b,c);e=we(null,
b,d,a,e,c);b.effectTag|=1;if("object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof){b.tag=1;b.memoizedState=null;b.updateQueue=null;if(N(d)){var f=!0;Bc(b)}else f=!1;b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null;ne(b);var g=d.getDerivedStateFromProps;"function"===typeof g&&Lc(b,d,g,a);e.updater=Mc;b.stateNode=e;e._reactInternalFiber=b;pe(b,d,a,c);b=Ie(null,b,d,!0,f,c)}else b.tag=0,T(null,b,e,c),b=b.child;return b;case 16:a:{e=b.elementType;null!==a&&(a.alternate=
null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;ri(e);if(1!==e._status)throw e._result;e=e._result;b.type=e;f=b.tag=Gj(e);a=aa(e,a);switch(f){case 0:b=He(null,b,e,a,c);break a;case 1:b=rh(null,b,e,a,c);break a;case 11:b=nh(null,b,e,a,c);break a;case 14:b=oh(null,b,e,aa(e.type,a),d,c);break a}throw Error(k(306,e,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),He(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),rh(a,b,d,e,c);
case 3:sh(b);d=b.updateQueue;if(null===a||null===d)throw Error(k(282));d=b.pendingProps;e=b.memoizedState;e=null!==e?e.element:null;oe(a,b);Qb(b,d,null,c);d=b.memoizedState.element;if(d===e)Ee(),b=sa(a,b,c);else{if(e=b.stateNode.hydrate)Ka=kb(b.stateNode.containerInfo.firstChild),ra=b,e=Wa=!0;if(e)for(c=Fe(b,null,d,c),b.child=c;c;)c.effectTag=c.effectTag&-3|1024,c=c.sibling;else T(a,b,d,c),Ee();b=b.child}return b;case 5:return bh(b),null===a&&De(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:
null,g=e.children,Yd(d,e)?g=null:null!==f&&Yd(d,f)&&(b.effectTag|=16),qh(a,b),b.mode&4&&1!==c&&e.hidden?(b.expirationTime=b.childExpirationTime=1,b=null):(T(a,b,g,c),b=b.child),b;case 6:return null===a&&De(b),null;case 13:return th(a,b,c);case 4:return se(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=wb(b,null,d,c):T(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),nh(a,b,d,e,c);case 7:return T(a,b,b.pendingProps,c),b.child;case 8:return T(a,
b,b.pendingProps.children,c),b.child;case 12:return T(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;g=b.memoizedProps;f=e.value;var h=b.type._context;y(Ic,h._currentValue);h._currentValue=f;if(null!==g)if(h=g.value,f=Qa(h,f)?0:("function"===typeof d._calculateChangedBits?d._calculateChangedBits(h,f):1073741823)|0,0===f){if(g.children===e.children&&!G.current){b=sa(a,b,c);break a}}else for(h=b.child,null!==h&&(h.return=b);null!==h;){var m=h.dependencies;if(null!==
m){g=h.child;for(var l=m.firstContext;null!==l;){if(l.context===d&&0!==(l.observedBits&f)){1===h.tag&&(l=Ea(c,null),l.tag=Jc,Fa(h,l));h.expirationTime<c&&(h.expirationTime=c);l=h.alternate;null!==l&&l.expirationTime<c&&(l.expirationTime=c);Sg(h.return,c);m.expirationTime<c&&(m.expirationTime=c);break}l=l.next}}else g=10===h.tag?h.type===b.type?null:h.child:h.child;if(null!==g)g.return=h;else for(g=h;null!==g;){if(g===b){g=null;break}h=g.sibling;if(null!==h){h.return=g.return;g=h;break}g=g.return}h=
g}T(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,f=b.pendingProps,d=f.children,rb(b,c),e=W(e,f.unstable_observedBits),d=d(e),b.effectTag|=1,T(a,b,d,c),b.child;case 14:return e=b.type,f=aa(e,b.pendingProps),f=aa(e.type,f),oh(a,b,e,f,d,c);case 15:return ph(a,b,b.type,b.pendingProps,d,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),b.tag=1,N(d)?(a=!0,Bc(b)):a=!1,rb(b,c),Yg(b,d,e),pe(b,d,e,c),Ie(null,
b,d,!0,a,c);case 19:return vh(a,b,c)}throw Error(k(156,b.tag));};var bf=null,Ne=null,la=function(a,b,c,d){return new Fj(a,b,c,d)};ef.prototype.render=function(a){md(a,this._internalRoot,null,null)};ef.prototype.unmount=function(){var a=this._internalRoot,b=a.containerInfo;md(null,a,null,function(){b[Lb]=null})};var Di=function(a){if(13===a.tag){var b=Fc(ka(),150,100);Ja(a,b);df(a,b)}};var Yf=function(a){13===a.tag&&(Ja(a,3),df(a,3))};var Bi=function(a){if(13===a.tag){var b=ka();b=Va(b,a,null);Ja(a,
b);df(a,b)}};sd=function(a,b,c){switch(b){case "input":Dd(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=ae(d);if(!e)throw Error(k(90));Gf(d);Dd(d,e)}}}break;case "textarea":Lf(a,c);break;case "select":b=c.value,null!=b&&hb(a,!!c.multiple,b,!1)}};(function(a,b,c,d){ee=a;eg=b;vd=c;vf=d})(Qh,function(a,b,c,d,e){var f=p;p|=4;
try{return Da(98,a.bind(null,b,c,d,e))}finally{p=f,p===H&&ha()}},function(){(p&(1|ca|ma))===H&&(uj(),xb())},function(a,b){var c=p;p|=2;try{return a(b)}finally{p=c,p===H&&ha()}});var mk={Events:[Hb,Pa,ae,pf,qd,lb,function(a){Kd(a,Ki)},sf,tf,sc,pc,xb,{current:!1}]};(function(a){var b=a.findFiberByHostInstance;return Ej(M({},a,{overrideHookState:null,overrideProps:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:da.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=Sf(a);
return null===a?null:a.stateNode},findFiberByHostInstance:function(a){return b?b(a):null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null}))})({findFiberByHostInstance:Bb,bundleType:0,version:"16.13.1",rendererPackageName:"react-dom"});I.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=mk;I.createPortal=Xh;I.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternalFiber;if(void 0===
b){if("function"===typeof a.render)throw Error(k(188));throw Error(k(268,Object.keys(a)));}a=Sf(b);a=null===a?null:a.stateNode;return a};I.flushSync=function(a,b){if((p&(ca|ma))!==H)throw Error(k(187));var c=p;p|=1;try{return Da(99,a.bind(null,b))}finally{p=c,ha()}};I.hydrate=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!0,c)};I.render=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!1,c)};I.unmountComponentAtNode=function(a){if(!bc(a))throw Error(k(40));return a._reactRootContainer?
(Rh(function(){nd(null,null,a,!1,function(){a._reactRootContainer=null;a[Lb]=null})}),!0):!1};I.unstable_batchedUpdates=Qh;I.unstable_createPortal=function(a,b){return Xh(a,b,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)};I.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!bc(c))throw Error(k(200));if(null==a||void 0===a._reactInternalFiber)throw Error(k(38));return nd(a,b,c,!1,d)};I.version="16.13.1"});
</script>
    <script>const e = React.createElement;

function pathToString(path) {
  if (path[0] === '/') {
    return '/' + path.slice(1).join('/');
  } else {
    return path.join('/');
  }
}

function findCommonPath(files) {
  if (!files || !files.length) {
    return [];
  }

  function isPrefix(arr, prefix) {
    if (arr.length < prefix.length) {
      return false;
    }
    for (let i = prefix.length - 1; i >= 0; --i) {
      if (arr[i] !== prefix[i]) {
        return false;
      }
    }
    return true;
  }

  let commonPath = files[0].path.slice(0, -1);
  while (commonPath.length) {
    if (files.every(file => isPrefix(file.path, commonPath))) {
      break;
    }
    commonPath.pop();
  }
  return commonPath;
}

function findFolders(files) {
  if (!files || !files.length) {
    return [];
  }

  let folders = files.filter(file => file.path.length > 1).map(file => file.path[0]);
  folders = [...new Set(folders)]; // unique
  folders.sort();

  folders = folders.map(folder => {
    let filesInFolder = files
      .filter(file => file.path[0] === folder)
      .map(file => ({
        ...file,
        path: file.path.slice(1),
        parent: [...file.parent, file.path[0]],
      }));

    const children = findFolders(filesInFolder); // recursion

    return {
      is_folder: true,
      path: [folder],
      parent: files[0].parent,
      children,
      covered: children.reduce((sum, file) => sum + file.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.coverable, 0),
      prevRun: {
        covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
        coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
      }
    };
  });

  return [
    ...folders,
    ...files.filter(file => file.path.length === 1),
  ];
}

class App extends React.Component {
  constructor(...args) {
    super(...args);

    this.state = {
      current: [],
    };
  }

  componentDidMount() {
    this.updateStateFromLocation();
    window.addEventListener("hashchange", () => this.updateStateFromLocation(), false);
  }

  updateStateFromLocation() {
    if (window.location.hash.length > 1) {
      const current = window.location.hash.substr(1).split('/');
      this.setState({current});
    } else {
      this.setState({current: []});
    }
  }

  getCurrentPath() {
    let file = this.props.root;
    let path = [file];
    for (let p of this.state.current) {
      file = file.children.find(file => file.path[0] === p);
      if (!file) {
        return path;
      }
      path.push(file);
    }
    return path;
  }

  render() {
    const path = this.getCurrentPath();
    const file = path[path.length - 1];

    let w = null;
    if (file.is_folder) {
      w = e(FilesList, {
        folder: file,
        onSelectFile: this.selectFile.bind(this),
        onBack: path.length > 1 ? this.back.bind(this) : null,
      });
    } else {
      w = e(DisplayFile, {
        file,
        onBack: this.back.bind(this),
      });
    }

    return e('div', {className: 'app'}, w);
  }

  selectFile(file) {
    this.setState(({current}) => {
      return {current: [...current, file.path[0]]};
    }, () => this.updateHash());
  }

  back(file) {
    this.setState(({current}) => {
      return {current: current.slice(0, current.length - 1)};
    }, () => this.updateHash());
  }

  updateHash() {
    if (!this.state.current || !this.state.current.length) {
      window.location = '#';
    } else {
      window.location = '#' + this.state.current.join('/');
    }
  }
}

function FilesList({folder, onSelectFile, onBack}) {
  let files = folder.children;
  return e('div', {className: 'display-folder'},
    e(FileHeader, {file: folder, onBack}),
    e('table', {className: 'files-list'},
      e('thead', {className: 'files-list__head'},
        e('tr', null,
          e('th', null, "Path"),
          e('th', null, "Coverage")
        )
      ),
      e('tbody', {className: 'files-list__body'},
        files.map(file => e(File, {file, onClick: onSelectFile}))
      )
    )
  );
}

function File({file, onClick}) {
  const coverage = file.coverable ? file.covered / file.coverable * 100 : -1;
  const coverageDelta = file.prevRun &&
    (file.covered / file.coverable * 100 - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('tr', {
      className: 'files-list__file'
        + (coverage >= 0 && coverage < 50 ? ' files-list__file_low': '')
        + (coverage >= 50 && coverage < 80 ? ' files-list__file_medium': '')
        + (coverage >= 80 ? ' files-list__file_high': '')
        + (file.is_folder ? ' files-list__file_folder': ''),
      onClick: () => onClick(file),
    },
    e('td', null, e('a', null, pathToString(file.path))),
    e('td', null,
      file.covered + ' / ' + file.coverable +
      (coverage >= 0 ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function DisplayFile({file, onBack}) {
  return e('div', {className: 'display-file'},
    e(FileHeader, {file, onBack}),
    e(FileContent, {file})
  );
}

function FileHeader({file, onBack}) {
  const coverage = file.covered / file.coverable * 100;
  const coverageDelta = file.prevRun && (coverage - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('div', {className: 'file-header'},
    onBack ? e('a', {className: 'file-header__back', onClick: onBack}, 'Back') : null,
    e('div', {className: 'file-header__name'}, pathToString([...file.parent, ...file.path])),
    e('div', {className: 'file-header__stat'},
      'Covered: ' + file.covered + ' of ' + file.coverable +
      (file.coverable ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function FileContent({file}) {
  return e('div', {className: 'file-content'},
    file.content.split(/\r?\n/).map((line, index) => {
      const trace = file.traces.find(trace => trace.line === index + 1);
      const covered = trace && trace.stats.Line;
      const uncovered = trace && !trace.stats.Line;
      return e('pre', {
          className: 'code-line'
            + (covered ? ' code-line_covered' : '')
            + (uncovered ? ' code-line_uncovered' : ''),
          title: trace ? JSON.stringify(trace.stats, null, 2) : null,
        }, line);
    })
  );
}

(function(){
  const commonPath = findCommonPath(data.files);
  const prevFilesMap = new Map();

  previousData && previousData.files.forEach((file) => {
    const path = file.path.slice(commonPath.length).join('/');
    prevFilesMap.set(path, file);
  });

  const files = data.files.map((file) => {
    const path = file.path.slice(commonPath.length);
    const { covered = 0, coverable = 0 } = prevFilesMap.get(path.join('/')) || {};
    return {
      ...file,
      path,
      parent: commonPath,
      prevRun: { covered, coverable },
    };
  });

  const children = findFolders(files);

  const root = {
    is_folder: true,
    children,
    path: commonPath,
    parent: [],
    covered: children.reduce((sum, file) => sum + file.covered, 0),
    coverable: children.reduce((sum, file) => sum + file.coverable, 0),
    prevRun: {
      covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
    }
  };

  ReactDOM.render(e(App, {root, prevFilesMap}), document.getElementById('root'));
}());
</script>
</body>
</html>